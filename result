./.git/hooks/commit-msg.sample:#!/bin/sh
./.git/hooks/commit-msg.sample:#
./.git/hooks/commit-msg.sample:# An example hook script to check the commit log message.
./.git/hooks/commit-msg.sample:# Called by "git commit" with one argument, the name of the file
./.git/hooks/commit-msg.sample:# that has the commit message.  The hook should exit with non-zero
./.git/hooks/commit-msg.sample:# status after issuing an appropriate message if it wants to stop the
./.git/hooks/commit-msg.sample:# commit.  The hook is allowed to edit the commit message file.
./.git/hooks/commit-msg.sample:#
./.git/hooks/commit-msg.sample:# To enable this hook, rename this file to "commit-msg".
./.git/hooks/commit-msg.sample:
./.git/hooks/commit-msg.sample:# Uncomment the below to add a Signed-off-by line to the message.
./.git/hooks/commit-msg.sample:# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
./.git/hooks/commit-msg.sample:# hook is more suited to it.
./.git/hooks/commit-msg.sample:#
./.git/hooks/commit-msg.sample:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
./.git/hooks/commit-msg.sample:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
./.git/hooks/commit-msg.sample:
./.git/hooks/commit-msg.sample:# This example catches duplicate Signed-off-by lines.
./.git/hooks/commit-msg.sample:
./.git/hooks/commit-msg.sample:test "" = "$(grep '^Signed-off-by: ' "$1" |
./.git/hooks/commit-msg.sample:	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
./.git/hooks/commit-msg.sample:	echo >&2 Duplicate Signed-off-by lines.
./.git/hooks/commit-msg.sample:	exit 1
./.git/hooks/commit-msg.sample:}
./.git/hooks/pre-rebase.sample:#!/bin/sh
./.git/hooks/pre-rebase.sample:#
./.git/hooks/pre-rebase.sample:# Copyright (c) 2006, 2008 Junio C Hamano
./.git/hooks/pre-rebase.sample:#
./.git/hooks/pre-rebase.sample:# The "pre-rebase" hook is run just before "git rebase" starts doing
./.git/hooks/pre-rebase.sample:# its job, and can prevent the command from running by exiting with
./.git/hooks/pre-rebase.sample:# non-zero status.
./.git/hooks/pre-rebase.sample:#
./.git/hooks/pre-rebase.sample:# The hook is called with the following parameters:
./.git/hooks/pre-rebase.sample:#
./.git/hooks/pre-rebase.sample:# $1 -- the upstream the series was forked from.
./.git/hooks/pre-rebase.sample:# $2 -- the branch being rebased (or empty when rebasing the current branch).
./.git/hooks/pre-rebase.sample:#
./.git/hooks/pre-rebase.sample:# This sample shows how to prevent topic branches that are already
./.git/hooks/pre-rebase.sample:# merged to 'next' branch from getting rebased, because allowing it
./.git/hooks/pre-rebase.sample:# would result in rebasing already published history.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:publish=next
./.git/hooks/pre-rebase.sample:basebranch="$1"
./.git/hooks/pre-rebase.sample:if test "$#" = 2
./.git/hooks/pre-rebase.sample:then
./.git/hooks/pre-rebase.sample:	topic="refs/heads/$2"
./.git/hooks/pre-rebase.sample:else
./.git/hooks/pre-rebase.sample:	topic=`git symbolic-ref HEAD` ||
./.git/hooks/pre-rebase.sample:	exit 0 ;# we do not interrupt rebasing detached HEAD
./.git/hooks/pre-rebase.sample:fi
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:case "$topic" in
./.git/hooks/pre-rebase.sample:refs/heads/??/*)
./.git/hooks/pre-rebase.sample:	;;
./.git/hooks/pre-rebase.sample:*)
./.git/hooks/pre-rebase.sample:	exit 0 ;# we do not interrupt others.
./.git/hooks/pre-rebase.sample:	;;
./.git/hooks/pre-rebase.sample:esac
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:# Now we are dealing with a topic branch being rebased
./.git/hooks/pre-rebase.sample:# on top of master.  Is it OK to rebase it?
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:# Does the topic really exist?
./.git/hooks/pre-rebase.sample:git show-ref -q "$topic" || {
./.git/hooks/pre-rebase.sample:	echo >&2 "No such branch $topic"
./.git/hooks/pre-rebase.sample:	exit 1
./.git/hooks/pre-rebase.sample:}
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:# Is topic fully merged to master?
./.git/hooks/pre-rebase.sample:not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
./.git/hooks/pre-rebase.sample:if test -z "$not_in_master"
./.git/hooks/pre-rebase.sample:then
./.git/hooks/pre-rebase.sample:	echo >&2 "$topic is fully merged to master; better remove it."
./.git/hooks/pre-rebase.sample:	exit 1 ;# we could allow it, but there is no point.
./.git/hooks/pre-rebase.sample:fi
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:# Is topic ever merged to next?  If so you should not be rebasing it.
./.git/hooks/pre-rebase.sample:only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
./.git/hooks/pre-rebase.sample:only_next_2=`git rev-list ^master           ${publish} | sort`
./.git/hooks/pre-rebase.sample:if test "$only_next_1" = "$only_next_2"
./.git/hooks/pre-rebase.sample:then
./.git/hooks/pre-rebase.sample:	not_in_topic=`git rev-list "^$topic" master`
./.git/hooks/pre-rebase.sample:	if test -z "$not_in_topic"
./.git/hooks/pre-rebase.sample:	then
./.git/hooks/pre-rebase.sample:		echo >&2 "$topic is already up-to-date with master"
./.git/hooks/pre-rebase.sample:		exit 1 ;# we could allow it, but there is no point.
./.git/hooks/pre-rebase.sample:	else
./.git/hooks/pre-rebase.sample:		exit 0
./.git/hooks/pre-rebase.sample:	fi
./.git/hooks/pre-rebase.sample:else
./.git/hooks/pre-rebase.sample:	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
./.git/hooks/pre-rebase.sample:	/usr/bin/perl -e '
./.git/hooks/pre-rebase.sample:		my $topic = $ARGV[0];
./.git/hooks/pre-rebase.sample:		my $msg = "* $topic has commits already merged to public branch:\n";
./.git/hooks/pre-rebase.sample:		my (%not_in_next) = map {
./.git/hooks/pre-rebase.sample:			/^([0-9a-f]+) /;
./.git/hooks/pre-rebase.sample:			($1 => 1);
./.git/hooks/pre-rebase.sample:		} split(/\n/, $ARGV[1]);
./.git/hooks/pre-rebase.sample:		for my $elem (map {
./.git/hooks/pre-rebase.sample:				/^([0-9a-f]+) (.*)$/;
./.git/hooks/pre-rebase.sample:				[$1 => $2];
./.git/hooks/pre-rebase.sample:			} split(/\n/, $ARGV[2])) {
./.git/hooks/pre-rebase.sample:			if (!exists $not_in_next{$elem->[0]}) {
./.git/hooks/pre-rebase.sample:				if ($msg) {
./.git/hooks/pre-rebase.sample:					print STDERR $msg;
./.git/hooks/pre-rebase.sample:					undef $msg;
./.git/hooks/pre-rebase.sample:				}
./.git/hooks/pre-rebase.sample:				print STDERR " $elem->[1]\n";
./.git/hooks/pre-rebase.sample:			}
./.git/hooks/pre-rebase.sample:		}
./.git/hooks/pre-rebase.sample:	' "$topic" "$not_in_next" "$not_in_master"
./.git/hooks/pre-rebase.sample:	exit 1
./.git/hooks/pre-rebase.sample:fi
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:<<\DOC_END
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:This sample hook safeguards topic branches that have been
./.git/hooks/pre-rebase.sample:published from being rewound.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:The workflow assumed here is:
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample: * Once a topic branch forks from "master", "master" is never
./.git/hooks/pre-rebase.sample:   merged into it again (either directly or indirectly).
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample: * Once a topic branch is fully cooked and merged into "master",
./.git/hooks/pre-rebase.sample:   it is deleted.  If you need to build on top of it to correct
./.git/hooks/pre-rebase.sample:   earlier mistakes, a new topic branch is created by forking at
./.git/hooks/pre-rebase.sample:   the tip of the "master".  This is not strictly necessary, but
./.git/hooks/pre-rebase.sample:   it makes it easier to keep your history simple.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample: * Whenever you need to test or publish your changes to topic
./.git/hooks/pre-rebase.sample:   branches, merge them into "next" branch.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:The script, being an example, hardcodes the publish branch name
./.git/hooks/pre-rebase.sample:to be "next", but it is trivial to make it configurable via
./.git/hooks/pre-rebase.sample:$GIT_DIR/config mechanism.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:With this workflow, you would want to know:
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:(1) ... if a topic branch has ever been merged to "next".  Young
./.git/hooks/pre-rebase.sample:    topic branches can have stupid mistakes you would rather
./.git/hooks/pre-rebase.sample:    clean up before publishing, and things that have not been
./.git/hooks/pre-rebase.sample:    merged into other branches can be easily rebased without
./.git/hooks/pre-rebase.sample:    affecting other people.  But once it is published, you would
./.git/hooks/pre-rebase.sample:    not want to rewind it.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:(2) ... if a topic branch has been fully merged to "master".
./.git/hooks/pre-rebase.sample:    Then you can delete it.  More importantly, you should not
./.git/hooks/pre-rebase.sample:    build on top of it -- other people may already want to
./.git/hooks/pre-rebase.sample:    change things related to the topic as patches against your
./.git/hooks/pre-rebase.sample:    "master", so if you need further changes, it is better to
./.git/hooks/pre-rebase.sample:    fork the topic (perhaps with the same name) afresh from the
./.git/hooks/pre-rebase.sample:    tip of "master".
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:Let's look at this example:
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:		   o---o---o---o---o---o---o---o---o---o "next"
./.git/hooks/pre-rebase.sample:		  /       /           /           /
./.git/hooks/pre-rebase.sample:		 /   a---a---b A     /           /
./.git/hooks/pre-rebase.sample:		/   /               /           /
./.git/hooks/pre-rebase.sample:	       /   /   c---c---c---c B         /
./.git/hooks/pre-rebase.sample:	      /   /   /             \         /
./.git/hooks/pre-rebase.sample:	     /   /   /   b---b C     \       /
./.git/hooks/pre-rebase.sample:	    /   /   /   /             \     /
./.git/hooks/pre-rebase.sample:    ---o---o---o---o---o---o---o---o---o---o---o "master"
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:A, B and C are topic branches.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample: * A has one fix since it was merged up to "next".
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample: * B has finished.  It has been fully merged up to "master" and "next",
./.git/hooks/pre-rebase.sample:   and is ready to be deleted.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample: * C has not merged to "next" at all.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:We would want to allow C to be rebased, refuse A, and encourage
./.git/hooks/pre-rebase.sample:B to be deleted.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:To compute (1):
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:	git rev-list ^master ^topic next
./.git/hooks/pre-rebase.sample:	git rev-list ^master        next
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:	if these match, topic has not merged in next at all.
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:To compute (2):
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:	git rev-list master..topic
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:	if this is empty, it is fully merged to "master".
./.git/hooks/pre-rebase.sample:
./.git/hooks/pre-rebase.sample:DOC_END
./.git/hooks/prepare-commit-msg.sample:#!/bin/sh
./.git/hooks/prepare-commit-msg.sample:#
./.git/hooks/prepare-commit-msg.sample:# An example hook script to prepare the commit log message.
./.git/hooks/prepare-commit-msg.sample:# Called by "git commit" with the name of the file that has the
./.git/hooks/prepare-commit-msg.sample:# commit message, followed by the description of the commit
./.git/hooks/prepare-commit-msg.sample:# message's source.  The hook's purpose is to edit the commit
./.git/hooks/prepare-commit-msg.sample:# message file.  If the hook fails with a non-zero status,
./.git/hooks/prepare-commit-msg.sample:# the commit is aborted.
./.git/hooks/prepare-commit-msg.sample:#
./.git/hooks/prepare-commit-msg.sample:# To enable this hook, rename this file to "prepare-commit-msg".
./.git/hooks/prepare-commit-msg.sample:
./.git/hooks/prepare-commit-msg.sample:# This hook includes three examples.  The first comments out the
./.git/hooks/prepare-commit-msg.sample:# "Conflicts:" part of a merge commit.
./.git/hooks/prepare-commit-msg.sample:#
./.git/hooks/prepare-commit-msg.sample:# The second includes the output of "git diff --name-status -r"
./.git/hooks/prepare-commit-msg.sample:# into the message, just before the "git status" output.  It is
./.git/hooks/prepare-commit-msg.sample:# commented because it doesn't cope with --amend or with squashed
./.git/hooks/prepare-commit-msg.sample:# commits.
./.git/hooks/prepare-commit-msg.sample:#
./.git/hooks/prepare-commit-msg.sample:# The third example adds a Signed-off-by line to the message, that can
./.git/hooks/prepare-commit-msg.sample:# still be edited.  This is rarely a good idea.
./.git/hooks/prepare-commit-msg.sample:
./.git/hooks/prepare-commit-msg.sample:case "$2,$3" in
./.git/hooks/prepare-commit-msg.sample:  merge,)
./.git/hooks/prepare-commit-msg.sample:    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
./.git/hooks/prepare-commit-msg.sample:
./.git/hooks/prepare-commit-msg.sample:# ,|template,)
./.git/hooks/prepare-commit-msg.sample:#   /usr/bin/perl -i.bak -pe '
./.git/hooks/prepare-commit-msg.sample:#      print "\n" . `git diff --cached --name-status -r`
./.git/hooks/prepare-commit-msg.sample:#	 if /^#/ && $first++ == 0' "$1" ;;
./.git/hooks/prepare-commit-msg.sample:
./.git/hooks/prepare-commit-msg.sample:  *) ;;
./.git/hooks/prepare-commit-msg.sample:esac
./.git/hooks/prepare-commit-msg.sample:
./.git/hooks/prepare-commit-msg.sample:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
./.git/hooks/prepare-commit-msg.sample:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
./.git/hooks/update.sample:#!/bin/sh
./.git/hooks/update.sample:#
./.git/hooks/update.sample:# An example hook script to blocks unannotated tags from entering.
./.git/hooks/update.sample:# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
./.git/hooks/update.sample:#
./.git/hooks/update.sample:# To enable this hook, rename this file to "update".
./.git/hooks/update.sample:#
./.git/hooks/update.sample:# Config
./.git/hooks/update.sample:# ------
./.git/hooks/update.sample:# hooks.allowunannotated
./.git/hooks/update.sample:#   This boolean sets whether unannotated tags will be allowed into the
./.git/hooks/update.sample:#   repository.  By default they won't be.
./.git/hooks/update.sample:# hooks.allowdeletetag
./.git/hooks/update.sample:#   This boolean sets whether deleting tags will be allowed in the
./.git/hooks/update.sample:#   repository.  By default they won't be.
./.git/hooks/update.sample:# hooks.allowmodifytag
./.git/hooks/update.sample:#   This boolean sets whether a tag may be modified after creation. By default
./.git/hooks/update.sample:#   it won't be.
./.git/hooks/update.sample:# hooks.allowdeletebranch
./.git/hooks/update.sample:#   This boolean sets whether deleting branches will be allowed in the
./.git/hooks/update.sample:#   repository.  By default they won't be.
./.git/hooks/update.sample:# hooks.denycreatebranch
./.git/hooks/update.sample:#   This boolean sets whether remotely creating branches will be denied
./.git/hooks/update.sample:#   in the repository.  By default this is allowed.
./.git/hooks/update.sample:#
./.git/hooks/update.sample:
./.git/hooks/update.sample:# --- Command line
./.git/hooks/update.sample:refname="$1"
./.git/hooks/update.sample:oldrev="$2"
./.git/hooks/update.sample:newrev="$3"
./.git/hooks/update.sample:
./.git/hooks/update.sample:# --- Safety check
./.git/hooks/update.sample:if [ -z "$GIT_DIR" ]; then
./.git/hooks/update.sample:	echo "Don't run this script from the command line." >&2
./.git/hooks/update.sample:	echo " (if you want, you could supply GIT_DIR then run" >&2
./.git/hooks/update.sample:	echo "  $0 <ref> <oldrev> <newrev>)" >&2
./.git/hooks/update.sample:	exit 1
./.git/hooks/update.sample:fi
./.git/hooks/update.sample:
./.git/hooks/update.sample:if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
./.git/hooks/update.sample:	echo "Usage: $0 <ref> <oldrev> <newrev>" >&2
./.git/hooks/update.sample:	exit 1
./.git/hooks/update.sample:fi
./.git/hooks/update.sample:
./.git/hooks/update.sample:# --- Config
./.git/hooks/update.sample:allowunannotated=$(git config --bool hooks.allowunannotated)
./.git/hooks/update.sample:allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
./.git/hooks/update.sample:denycreatebranch=$(git config --bool hooks.denycreatebranch)
./.git/hooks/update.sample:allowdeletetag=$(git config --bool hooks.allowdeletetag)
./.git/hooks/update.sample:allowmodifytag=$(git config --bool hooks.allowmodifytag)
./.git/hooks/update.sample:
./.git/hooks/update.sample:# check for no description
./.git/hooks/update.sample:projectdesc=$(sed -e '1q' "$GIT_DIR/description")
./.git/hooks/update.sample:case "$projectdesc" in
./.git/hooks/update.sample:"Unnamed repository"* | "")
./.git/hooks/update.sample:	echo "*** Project description file hasn't been set" >&2
./.git/hooks/update.sample:	exit 1
./.git/hooks/update.sample:	;;
./.git/hooks/update.sample:esac
./.git/hooks/update.sample:
./.git/hooks/update.sample:# --- Check types
./.git/hooks/update.sample:# if $newrev is 0000...0000, it's a commit to delete a ref.
./.git/hooks/update.sample:zero="0000000000000000000000000000000000000000"
./.git/hooks/update.sample:if [ "$newrev" = "$zero" ]; then
./.git/hooks/update.sample:	newrev_type=delete
./.git/hooks/update.sample:else
./.git/hooks/update.sample:	newrev_type=$(git cat-file -t $newrev)
./.git/hooks/update.sample:fi
./.git/hooks/update.sample:
./.git/hooks/update.sample:case "$refname","$newrev_type" in
./.git/hooks/update.sample:	refs/tags/*,commit)
./.git/hooks/update.sample:		# un-annotated tag
./.git/hooks/update.sample:		short_refname=${refname##refs/tags/}
./.git/hooks/update.sample:		if [ "$allowunannotated" != "true" ]; then
./.git/hooks/update.sample:			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
./.git/hooks/update.sample:			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
./.git/hooks/update.sample:			exit 1
./.git/hooks/update.sample:		fi
./.git/hooks/update.sample:		;;
./.git/hooks/update.sample:	refs/tags/*,delete)
./.git/hooks/update.sample:		# delete tag
./.git/hooks/update.sample:		if [ "$allowdeletetag" != "true" ]; then
./.git/hooks/update.sample:			echo "*** Deleting a tag is not allowed in this repository" >&2
./.git/hooks/update.sample:			exit 1
./.git/hooks/update.sample:		fi
./.git/hooks/update.sample:		;;
./.git/hooks/update.sample:	refs/tags/*,tag)
./.git/hooks/update.sample:		# annotated tag
./.git/hooks/update.sample:		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
./.git/hooks/update.sample:		then
./.git/hooks/update.sample:			echo "*** Tag '$refname' already exists." >&2
./.git/hooks/update.sample:			echo "*** Modifying a tag is not allowed in this repository." >&2
./.git/hooks/update.sample:			exit 1
./.git/hooks/update.sample:		fi
./.git/hooks/update.sample:		;;
./.git/hooks/update.sample:	refs/heads/*,commit)
./.git/hooks/update.sample:		# branch
./.git/hooks/update.sample:		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
./.git/hooks/update.sample:			echo "*** Creating a branch is not allowed in this repository" >&2
./.git/hooks/update.sample:			exit 1
./.git/hooks/update.sample:		fi
./.git/hooks/update.sample:		;;
./.git/hooks/update.sample:	refs/heads/*,delete)
./.git/hooks/update.sample:		# delete branch
./.git/hooks/update.sample:		if [ "$allowdeletebranch" != "true" ]; then
./.git/hooks/update.sample:			echo "*** Deleting a branch is not allowed in this repository" >&2
./.git/hooks/update.sample:			exit 1
./.git/hooks/update.sample:		fi
./.git/hooks/update.sample:		;;
./.git/hooks/update.sample:	refs/remotes/*,commit)
./.git/hooks/update.sample:		# tracking branch
./.git/hooks/update.sample:		;;
./.git/hooks/update.sample:	refs/remotes/*,delete)
./.git/hooks/update.sample:		# delete tracking branch
./.git/hooks/update.sample:		if [ "$allowdeletebranch" != "true" ]; then
./.git/hooks/update.sample:			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
./.git/hooks/update.sample:			exit 1
./.git/hooks/update.sample:		fi
./.git/hooks/update.sample:		;;
./.git/hooks/update.sample:	*)
./.git/hooks/update.sample:		# Anything else (is there anything else?)
./.git/hooks/update.sample:		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
./.git/hooks/update.sample:		exit 1
./.git/hooks/update.sample:		;;
./.git/hooks/update.sample:esac
./.git/hooks/update.sample:
./.git/hooks/update.sample:# --- Finished
./.git/hooks/update.sample:exit 0
./.git/hooks/pre-commit.sample:#!/bin/sh
./.git/hooks/pre-commit.sample:#
./.git/hooks/pre-commit.sample:# An example hook script to verify what is about to be committed.
./.git/hooks/pre-commit.sample:# Called by "git commit" with no arguments.  The hook should
./.git/hooks/pre-commit.sample:# exit with non-zero status after issuing an appropriate message if
./.git/hooks/pre-commit.sample:# it wants to stop the commit.
./.git/hooks/pre-commit.sample:#
./.git/hooks/pre-commit.sample:# To enable this hook, rename this file to "pre-commit".
./.git/hooks/pre-commit.sample:
./.git/hooks/pre-commit.sample:if git rev-parse --verify HEAD >/dev/null 2>&1
./.git/hooks/pre-commit.sample:then
./.git/hooks/pre-commit.sample:	against=HEAD
./.git/hooks/pre-commit.sample:else
./.git/hooks/pre-commit.sample:	# Initial commit: diff against an empty tree object
./.git/hooks/pre-commit.sample:	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
./.git/hooks/pre-commit.sample:fi
./.git/hooks/pre-commit.sample:
./.git/hooks/pre-commit.sample:# If you want to allow non-ascii filenames set this variable to true.
./.git/hooks/pre-commit.sample:allownonascii=$(git config hooks.allownonascii)
./.git/hooks/pre-commit.sample:
./.git/hooks/pre-commit.sample:# Redirect output to stderr.
./.git/hooks/pre-commit.sample:exec 1>&2
./.git/hooks/pre-commit.sample:
./.git/hooks/pre-commit.sample:# Cross platform projects tend to avoid non-ascii filenames; prevent
./.git/hooks/pre-commit.sample:# them from being added to the repository. We exploit the fact that the
./.git/hooks/pre-commit.sample:# printable range starts at the space character and ends with tilde.
./.git/hooks/pre-commit.sample:if [ "$allownonascii" != "true" ] &&
./.git/hooks/pre-commit.sample:	# Note that the use of brackets around a tr range is ok here, (it's
./.git/hooks/pre-commit.sample:	# even required, for portability to Solaris 10's /usr/bin/tr), since
./.git/hooks/pre-commit.sample:	# the square bracket bytes happen to fall in the designated range.
./.git/hooks/pre-commit.sample:	test $(git diff --cached --name-only --diff-filter=A -z $against |
./.git/hooks/pre-commit.sample:	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
./.git/hooks/pre-commit.sample:then
./.git/hooks/pre-commit.sample:	echo "Error: Attempt to add a non-ascii file name."
./.git/hooks/pre-commit.sample:	echo
./.git/hooks/pre-commit.sample:	echo "This can cause problems if you want to work"
./.git/hooks/pre-commit.sample:	echo "with people on other platforms."
./.git/hooks/pre-commit.sample:	echo
./.git/hooks/pre-commit.sample:	echo "To be portable it is advisable to rename the file ..."
./.git/hooks/pre-commit.sample:	echo
./.git/hooks/pre-commit.sample:	echo "If you know what you are doing you can disable this"
./.git/hooks/pre-commit.sample:	echo "check using:"
./.git/hooks/pre-commit.sample:	echo
./.git/hooks/pre-commit.sample:	echo "  git config hooks.allownonascii true"
./.git/hooks/pre-commit.sample:	echo
./.git/hooks/pre-commit.sample:	exit 1
./.git/hooks/pre-commit.sample:fi
./.git/hooks/pre-commit.sample:
./.git/hooks/pre-commit.sample:# If there are whitespace errors, print the offending file names and fail.
./.git/hooks/pre-commit.sample:exec git diff-index --check --cached $against --
./.git/hooks/pre-applypatch.sample:#!/bin/sh
./.git/hooks/pre-applypatch.sample:#
./.git/hooks/pre-applypatch.sample:# An example hook script to verify what is about to be committed
./.git/hooks/pre-applypatch.sample:# by applypatch from an e-mail message.
./.git/hooks/pre-applypatch.sample:#
./.git/hooks/pre-applypatch.sample:# The hook should exit with non-zero status after issuing an
./.git/hooks/pre-applypatch.sample:# appropriate message if it wants to stop the commit.
./.git/hooks/pre-applypatch.sample:#
./.git/hooks/pre-applypatch.sample:# To enable this hook, rename this file to "pre-applypatch".
./.git/hooks/pre-applypatch.sample:
./.git/hooks/pre-applypatch.sample:. git-sh-setup
./.git/hooks/pre-applypatch.sample:test -x "$GIT_DIR/hooks/pre-commit" &&
./.git/hooks/pre-applypatch.sample:	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
./.git/hooks/pre-applypatch.sample::
./.git/hooks/post-update.sample:#!/bin/sh
./.git/hooks/post-update.sample:#
./.git/hooks/post-update.sample:# An example hook script to prepare a packed repository for use over
./.git/hooks/post-update.sample:# dumb transports.
./.git/hooks/post-update.sample:#
./.git/hooks/post-update.sample:# To enable this hook, rename this file to "post-update".
./.git/hooks/post-update.sample:
./.git/hooks/post-update.sample:exec git update-server-info
./.git/hooks/applypatch-msg.sample:#!/bin/sh
./.git/hooks/applypatch-msg.sample:#
./.git/hooks/applypatch-msg.sample:# An example hook script to check the commit log message taken by
./.git/hooks/applypatch-msg.sample:# applypatch from an e-mail message.
./.git/hooks/applypatch-msg.sample:#
./.git/hooks/applypatch-msg.sample:# The hook should exit with non-zero status after issuing an
./.git/hooks/applypatch-msg.sample:# appropriate message if it wants to stop the commit.  The hook is
./.git/hooks/applypatch-msg.sample:# allowed to edit the commit message file.
./.git/hooks/applypatch-msg.sample:#
./.git/hooks/applypatch-msg.sample:# To enable this hook, rename this file to "applypatch-msg".
./.git/hooks/applypatch-msg.sample:
./.git/hooks/applypatch-msg.sample:. git-sh-setup
./.git/hooks/applypatch-msg.sample:test -x "$GIT_DIR/hooks/commit-msg" &&
./.git/hooks/applypatch-msg.sample:	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
./.git/hooks/applypatch-msg.sample::
./.git/description:Unnamed repository; edit this file 'description' to name the repository.
Binary file ./.git/objects/4f/9f93ad13a4ffa37c89bdfd2add6a75b3a410a0 matches
Binary file ./.git/objects/4f/7fe5bb019d9312118bac772deca073f8506e13 matches
Binary file ./.git/objects/af/41f1172ddff2e2a0aefddeafdecb1956de0b47 matches
./.git/objects/62/67fa183ea25b55dc86aed656cea66f36c7c8ba:x­“Ko‚@Ç{İıS<ÈCy‰m²Ö¦i¯¦7O­1
./.git/objects/62/67fa183ea25b55dc86aed656cea66f36c7c8ba:K!A0°¤1ß½³À¢‡&5ÑáõŸİÿüvxm³bïw	æÍL‡"ğ†q1Ö¶‚¢	ÌpŠ´È+;¼¼Yf)\+Ú\/çtN‹Y J+àëAVY—)<)õR‰:â¹°ßËgU`¥]ÚÎ*àÉ{BœÚĞİÀû*|+ùFğˆïzãúçƒç±IÀ¼GØNİ÷•ˆ”º»ôÃ
./.git/objects/62/67fa183ea25b55dc86aed656cea66f36c7c8ba:¸ÜGçÀ‰ãOğ+eÓ)óş’‡ç&ğtHìW¸V´À›ı(øÓ9”Ò<Ìğm‚fÛî]Z9»*±Ò0Ù”ÄŒx¶u©Á,yUgbi.ÀLúC	JBÄn?£¨cĞÍîçà”àäÙˆ‡#„Äb½¯E%J]|ñæªe\Áûr±0ŒZşwŒÇf*¸(Ì±©¿“4ã ·ı}`x+¹¢l‚ôÃ+,è“Æ#‹‰eµ”#&ı´ô?İ¡t pÍMô”\Ôe®VÃ®ôöBîÅ
Binary file ./.git/objects/d0/c68b2d076dbc2a2007cf7fa55e636d899286ac matches
Binary file ./.git/objects/f3/5b1a8226f40b23d603f4458c6d3fbb8c48fad4 matches
Binary file ./.git/objects/f3/7036c7f8e2cfe75a223a0cbb5f36fe20be0d53 matches
Binary file ./.git/objects/f3/745a50aea8261ec55474a2732c89da50f68901 matches
Binary file ./.git/objects/e8/a86bc2f667549b7bb499896e389f457881310b matches
Binary file ./.git/objects/dd/90aaf4e8d2395f6ff3c7c108aa74f90a0b7cc3 matches
Binary file ./.git/objects/99/96ad7d186f587e977025ad61aada1bc20a73ed matches
./.git/objects/3d/a78d19a886059228bc787bf424f95b9e5b0933:xÎAjÃ0@Ñ¬u
./.git/objects/3d/a78d19a886059228bc787bf424f95b9e5b0933:ía$Æ”’U]ô#yÔlO(>}}†n?<øE×uîÖã¥7[	1‚‡<¥ÌÄ1W”1º±D®uŠCóâ&Û	‰ØÁy¦Z(Hõ˜h
./.git/objects/3d/a78d19a886059228bc787bf424f95b9e5b0933:4ğ‚‘3•høİŸÚì·€õCšÚå¶ë¢µÍÇ¡÷Ÿ•çåVtı´nH!$ôí€9ë9ÙåŸÜ|iŞmÑ­7]ìcş•İük¥KÜ
Binary file ./.git/objects/c3/5057a4717eb9e959751c2c0e8832ef4e78cc29 matches
Binary file ./.git/objects/7c/9ded3e8e23ef87bb75f804d26cd7442e900852 matches
Binary file ./.git/objects/38/995d07315b1c96c0b6df910d5d5ebbac97670c matches
Binary file ./.git/objects/41/cbbf05b75a35969c30d5cc82a33c3fda20aacf matches
Binary file ./.git/objects/3e/9ae50eaa247df1c1c123f2bae613f8651cf284 matches
Binary file ./.git/objects/b7/8addd7e34ad1f129d83486a1c9b5fc31b9ada6 matches
Binary file ./.git/objects/b7/ac52bf5e2d9c5eae97ed2052a158eb4b536732 matches
Binary file ./.git/objects/a2/74fd64c2d10f3ffe1c52c89ec4f87b59c6434e matches
Binary file ./.git/objects/91/142520ebe2183e0d70a8d532a8afc6b55dc1e4 matches
Binary file ./.git/objects/90/2c1ed1f691ee723cb40271ca4186b2ae1e347f matches
Binary file ./.git/objects/c7/ff1a228540b72c2e9938c2781b451d6328fa01 matches
Binary file ./.git/objects/17/187d7ed518f0fc8b53efbb5e010f587ad52e1c matches
./.git/objects/24/180e7eb57eb8d57dd93688a1cf4daf09467bd8:xAj!E³öîƒZ]­!ä“;TY:ièãlúôB.şîñÿƒŸÛqlÃ†H/£—b—J•€Õ/µ2ÄœH´j`Õ•#ÊäŞ±3îå>,(Ç¤8¥Õ!…$Ç¥.aªP¨ 8øë«¬˜h¤Ù1 —8ãu„À’G­Y?ÇWëö³¸ğgéÍ¾í—ï¶·Ú·ól·ƒ·ı’Ûñn="-!‚}uŞ93é<5Ê?çæZú­Ø_‹ùf‚W¼
Binary file ./.git/objects/24/3e01e5ae6db352820b4a31c3b7ef018b8fab7c matches
Binary file ./.git/objects/f4/66d5e258f8ba3878a81f6d8003c103dba06b3a matches
Binary file ./.git/objects/19/8265b8f90d406b09e0e6fe6f3d274e62fb902d matches
Binary file ./.git/objects/f9/57d224c0d81592e53bfd7105713bdba25086a2 matches
Binary file ./.git/objects/78/f727bf6431559c43b12d8f985ef1b8bc7e765a matches
Binary file ./.git/objects/5d/c37cc321144381237d19bf301a5e0e0ee1591c matches
Binary file ./.git/objects/e5/823840feaf2ebaccc6ecc6d4b24f7f2b2011b6 matches
Binary file ./.git/objects/8e/865932c99a6b0d11efea4a7deaacb403a3a706 matches
Binary file ./.git/objects/4b/839f561e1009a7f5e7775f53adb33789c33a57 matches
Binary file ./.git/objects/f7/74f56808ff2ed28e59c57a536f090203c513eb matches
Binary file ./.git/objects/43/c7f02cf80f36057647bb68dea1449d80021073 matches
Binary file ./.git/objects/f5/41b6c49ff77b169d8975333725ffa06d31274b matches
Binary file ./.git/objects/a5/77ccc29dfaa48c9489b320d665c2e1eddddea3 matches
Binary file ./.git/objects/2d/b2e3e0377c4cdcdd5786a9178d8596aa244e6d matches
Binary file ./.git/objects/6b/5c11e55be40ffdc0b711bdfcf9a5a4b2ab69d1 matches
Binary file ./.git/objects/f6/44be4020bd9ba6a0b4bf4e7817c544affd839e matches
Binary file ./.git/objects/d8/fa9abb33b353b02d77365daa0084727cdd0fcd matches
./.git/objects/d8/6153160507ec097099a82ee1fbe7c6ea58885d:x­”]oÚ0†wÿŠ3¸	$MH
./.git/objects/d8/6153160507ec097099a82ee1fbe7c6ea58885d:Ó>4m·ÕîzUM($Fx	³¦jâ¿ïØ“”C+.mŸç¼~}Ìª¨V&ïÂ!o6`Şp¼	˜$‰‘‚8³Àµ\²RP.—2]Ù5’ÏâL`æxáÕ/ñ@ıÚacüü’@!ª¢Zs3}rŸÓRã8Xó…Mğúˆ²ŒzjŞZ`»öŠqöWkx“e_8M%Íì¤hîÃÑ¢q}L&°ziÕ7™ˆTqı¯ylO»ü50¾‡8JÆ’8>	ì÷ÿê†ÔHl*¼50À›]¼t!!}Vf&ô‚ ÄO=áVl‚M¯}?2gU°Y’mRî¿W¬T»;êªGx‰qê+%™riBZæò›8&‹S±/ä”ÇD0‡¯OSâ°5¸˜ÿ¬S¿ˆƒ9Î¯+(¸úÌ@³ıF¯o ¸GÄ{%$Wú:@zĞ`Ç¡… g3:É˜àC]Á‡Î‹V¦¡¬éyªÄ¨§rÏKpkÄ”½‹;Æ]eRí‡2ºvHÙÖµá”Fz¾ß¹:±µÂ:q>I»xÖsàÊXmªÒû¿¸÷!ªi¿ö¬‚g>Ô]”,¦yØ	W¹Ìªí6-sgX0¡›I¹À`>‡QmK³#Û¦±«±Z§ZŸ#Õf¦›šõc6Ï|°İéZh¤Û·[ĞR‘fÿæØ•© EÕ`à®£Ú¹©ò7rtŒ„;ˆ´Ú&é‚4»;•€*Ì¹ş»"û¯í6.(jÍÒïN†JÕâwÀÏ=Ë~,w)´½.ÍR‹îÙ6G¹òp>	]
Binary file ./.git/objects/d8/acb479c6474c2755d4ce6edf2ef7e0c37cbb37 matches
Binary file ./.git/objects/c1/23149274d8a1334a82138b1624f239435126ee matches
./.git/objects/26/6a1647512a0a6fc65ef2496d563502e48ab6c8:xÎMj1@á®}
./.git/objects/26/6a1647512a0a6fc65ef2496d563502e48ab6c8:ïÁÿ²!”®»èdInf¢à¸PæôÍº}ğÁ#=mÙËËš"–+ROĞ¨$H gN$Ex "PïÌ§Ü–íP‘™AbBöÃ‡Æ5¦ZĞSëyPô½!c1ø³¾uÚOqá¾N™j¯ûå¡»¹§¾¸íÒãÍúØr®©A¶¯Î;gõ9¹äŸÜ|h·¤·5u·cû•‡ù1õM"
Binary file ./.git/objects/03/9d05f37d7b582afb2992ab199dd9084eee99ba matches
Binary file ./.git/objects/03/9727ec5a50d0ed45ff67e6f4c9b953bd23c17d matches
Binary file ./.git/objects/a4/d75f670615a55ea0f4eb05194b8705e2bafb55 matches
Binary file ./.git/objects/a4/ad07bfa797d51f950b47b8683eeb4f9db9f434 matches
Binary file ./.git/objects/7a/5ff2f38d92a151a910c5845a3da8c0042447f2 matches
Binary file ./.git/objects/7a/17d7dc72fad5a331f2848663a810cdc6032b8f matches
Binary file ./.git/objects/25/181831dcd5f726abf4efbdde1ebdb0c6402227 matches
Binary file ./.git/objects/ac/566fe457c274cbec09fbf7e61be8ec6b4a9cf1 matches
./.git/objects/ac/a275d440d8a46fe4f41bcc5e94e2716d3f4cb8:x­TïoÚ0İWû¯¸‚TQ „@»Ué@ÛºišTuÒÖjÚ
./.git/objects/ac/a275d440d8a46fe4f41bcc5e94e2716d3f4cb8:%Ä€GHPbÖUUÿ÷İí€¶/«ZóÃöİ»ç÷Î$+O^÷_mh¿Ø€v ‘ğÇ³£(²RpÁwğg‘T½é“”FOgvï	ŸDEàNÔá/¤=Oøá>‚8.ÓŸÅ&‡·~õ®2›Tå¦w4èÍÊ±/Fº&–{·µYO¸ÅşÇ
./.git/objects/ac/a275d440d8a46fe4f41bcc5e94e2716d3f4cb8:éüÑL^WyÂ³RÅF¥úáQĞƒ£ğ$
./.git/objects/ac/a275d440d8a46fe4f41bcc5e94e2716d3f4cb8:!¹ßª¯+‘’ÖnªÃğjîƒÁÂ7Ññ0
./.git/objects/ac/a275d440d8a46fe4f41bcc5e94e2716d3f4cb8:‡D˜UEVÌJ]6›Ä‡ß<°!.ã	kàs–ğÅ~(ø£¤lê|šámB£×ğí¶U°ª½ECJ!*—ÓÅ„Ø–á	Ú™®L0kÈ)lFˆ¶Y­O%îWkÁœñ§Rè´¨è@
./.git/objects/ac/a275d440d8a46fe4f41bcc5e94e2716d3f4cb8:q·Ğ™‚¡ö÷§Ã12ÁŞÈ"Â1p*W¿’0DˆR™M™3×@e•ÚMö)ú(k0í¥üUèTˆÙ|’ÌkKä¯ÓE\â’‰koÉæ¸x ’ñRûj&³˜B³}Šúı#ŒFpqu~î|ch¢Ê²([KÖëLX‘Ô#<ø:¼uhß$]k
./.git/objects/ac/a275d440d8a46fe4f41bcc5e94e2716d3f4cb8:Ûîrof&ºJõ\WEnÓ"­©¥&pûXêÂš-8Iîl®Ú
./.git/objects/ac/a275d440d8a46fe4f41bcc5e94e2716d3f4cb8:ãJßWº£ì>ö†»€jbSho€Üá‘¶îÏv^¨'‡cºOºk×!l«`›%ö0ãF#Yçö=5nÿu°5€E(n½1•)[ëI³<)ù’ÇxÈ6Ì¸Û ‡¦Ent¾Qé¹1;I•§™#Îã•"æ¥Î2Òİ…ï_>Ÿ}½¸¤ yYÒÂ·qkƒ‹ÚGı]øquqùíıÙ§„.Ôt9±¾ZœF4&å®¥[
./.git/objects/f1/c97c985f2110bf3c084fda3c51c11e8bfe4827:xKj1³Ö)z0İú&d•eî OO"¬A–M˜ÓG¹BoSPP/õÖÊ©İËÌ 3E'‘%f6L
./.git/objects/f1/c97c985f2110bf3c084fda3c51c11e8bfe4827:‰)íÖiRd·’Œ³G|ûÉ!oÍšËfËÙ+ë\X–ÎaG¯í³á1¿û€OFyÌ“G‡k½Ü{íû(çÙß¿Z(õ’z{RŞï¬òğŠ„(]‘“ÿ©‹òÃwè7x†QB¬ƒ·uAü¢P(
Binary file ./.git/objects/4d/1b820e20de5e1301e1cf68413167e13c2bb0d5 matches
Binary file ./.git/objects/b6/de55b056e9a72673a5c7ee3094c2f2abfcfdf4 matches
Binary file ./.git/objects/8a/7ae30441fdbca33a9eaff3e659966d91ae61cf matches
Binary file ./.git/objects/8a/fbadfc08c096d0c3133230d750a2b6320680f8 matches
Binary file ./.git/objects/3c/5670a62a1a46315b6b2f06d77564ed12f194ca matches
Binary file ./.git/objects/3c/ccda73290cf488477f50b49c5f71644594a7d8 matches
Binary file ./.git/objects/58/381bb4031c86bcae5f27212a765d010e645bcc matches
Binary file ./.git/objects/58/ced1341b56cd463dfaa1c0e8bddbd2b8fffb61 matches
Binary file ./.git/objects/57/d37a8d2ccb980771ab4c4b5829e97c0927765e matches
Binary file ./.git/objects/2b/6aff29a775f871832438c98dea193612c41ce2 matches
Binary file ./.git/objects/ef/8879cbfdb2309562d63f86704d5600be5f47a9 matches
Binary file ./.git/objects/ab/b02f2165fd7306fbd2fbf27093ecd5587ba1e4 matches
Binary file ./.git/objects/85/0882428f5fe5d74e4ce8cb9d0e2f023bb76bc2 matches
Binary file ./.git/objects/b5/c339e9fd5fac08757e749e0f9a10721d1d505a matches
Binary file ./.git/objects/c0/69148900b98cbaba9c31515d215cffa056969e matches
Binary file ./.git/objects/02/c5a9a201957c6d2e3fbbfecff1df97b323b891 matches
Binary file ./.git/objects/36/caeda8192b35f51e97395c0b114e95ebdd5731 matches
Binary file ./.git/objects/36/4446fb5fd12ef542cdd5b5c7f81fad296cb989 matches
Binary file ./.git/objects/36/5a65dcc668594e03372538b89660ed4bd55e1a matches
Binary file ./.git/objects/2e/9da36962486d279f7c254d020bea41476c0ef8 matches
./.git/objects/66/a8b426c6c1d04545cdeeca95a7ec076df75749:x­“Mo›@†{]~ÅK	6Çn+ÜXı¸ôU=4§ªBÖ6‹Ó(ÊïÌ.‹©âƒ¥xm³³;³Ï¼3‹×y¹†àıÍâï€s±o ğ‚ãUÀ0•4äÀ•6âV”I¹¯¼ä,Å¡«qÊPk<1rCè§‡¶5ğËcySæå¦Îà£¶>5¢My!¼ùÌÛÔ+}À!J3º¥òjà1öqúƒÑŞŸÒÀ¯5OC˜Mƒ¹?½Á/‹0Âù;X?Õ÷'Iv7õÛx_¥ÿgœ‡³áb~8Ÿr`C:¤ö^k(àÅş(ø§óc”I·	¦çùøí–¿ovŞÎ4Œd×Ì¾ªm“ìÓ1d…€œ¶ñd°FÄ"K@DyÖæĞs	/¶×|;ØÅóŒ–}”Ì†éD{ÒÉX†¦ÚgNÍ›6KpS
./.git/objects/66/a8b426c6c1d04545cdeeca95a7ec076df75749:Ú€u€[\Ø{2Ê¨Ñµi[Y¨ÓÆ8FzĞQó¤­¢ª.·äwM•gÂÚdEâ¼å/YmmiƒùãóÏo¦=†ëğŸD’H¬‰²Pƒ=+-o¥÷˜êUÎAvYÎÁ¢Éªˆ÷üWö›j@Ed]]IèÑ…Ê…52æºÔ¦zÑ×ú§Ì
./.git/objects/66/a8b426c6c1d04545cdeeca95a7ec076df75749:kîKj×ƒxUÚ÷5pØö°;"ş{Œãº4Q‹ñ¬ºf@%·ai¢¢ÅLtëAÄèK&º¬îÃ«ªZÊ-±år6snáûıİ'Ñ“‰ä`›©ÕŒçÇ©O|"/ŠC/²+Åêä ¹	¦ìÄ©d5m]€®‘(AoªìÙø3yˆÏ
Binary file ./.git/objects/89/c2488f359fc070e4c9b0ace32bd2c346195d45 matches
Binary file ./.git/objects/ff/1afe845f85c6b639da343991d14b488ad58ba8 matches
Binary file ./.git/objects/ff/eeeeca3a78a7340db7ecd72fb4ebb8884174ae matches
Binary file ./.git/objects/df/b4b285e1c093177adb76700d7598fb651000e4 matches
Binary file ./.git/objects/bd/3ff8c86e7fa5d0a545bafc2f94edc8c43d6414 matches
Binary file ./.git/objects/1f/3b4fc194ec85cd63d639b484a7313f2e26367d matches
Binary file ./.git/objects/75/0e4baf08fba90c6ace0e8f7553339cb938faa6 matches
Binary file ./.git/objects/75/40ce4944bded11fa471c8240f5311a5eac3f45 matches
./.git/objects/4c/c7acd93a4c23fccf8940cef3a7ac3005f13937:xAN!E]sŠÚ›L¨‚ 1Æèª‹b¦c#5éÓËÜş—÷ò¥Õº ŸFWZ¯\
./.git/objects/4c/c7acd93a4c23fccf8940cef3a7ac3005f13937:%a)1`tä]”³2&wE¢dÜõk€m¿fÎ‹Š '$¤ÌÊ²rv«N´”`ø{Ü[‡µô§ö/ûåh{+};Ïöv«¼íiõĞ¥ÅyrDğlÑZ3×yrè?uó®ı¦°+¥uı™¡ßmÜ¡ò1£æ®æQ¥
Binary file ./.git/objects/ec/183ccd2563c9ea6c197dffed0ca555fe0b24da matches
Binary file ./.git/objects/93/00f820bff3707aa6bb86196c7d48769f1cfb46 matches
Binary file ./.git/objects/fa/89013a0e8966de5ecdf6c8a6052d650298756f matches
Binary file ./.git/objects/fa/c6789a3bab2313540b4c15340e9b42465bf693 matches
Binary file ./.git/objects/a6/30c559b601c1dc7fb106f9d5d773eb6327f1f6 matches
Binary file ./.git/objects/6c/9c218ca1fe3556c1ff0f8c7c62bcb31b93a12d matches
Binary file ./.git/objects/db/6589629dc0a351b7b7b1b5d63532a19815dfcb matches
Binary file ./.git/objects/e2/2c9742608246ea707a73abd6a29d1d3a0836c6 matches
Binary file ./.git/objects/c5/13ca7539e3d0056a7945511144474ef982a96c matches
Binary file ./.git/objects/b9/3799488d5c1bb25a679817173723f3138df54d matches
Binary file ./.git/objects/a9/e1da9a3b8e91ca6cffb362eaa2c9d4b1ec2141 matches
Binary file ./.git/objects/96/0bebf6f918275dce3a240977c3260e1110c78b matches
Binary file ./.git/objects/c4/421b0f1e9bbe72f5bd0d38efd1f4b7eb28967d matches
Binary file ./.git/objects/34/3a968d81fc8ed23aac2f368d6f08a29879658b matches
Binary file ./.git/objects/34/7e166c04e507ba6a68e0146423b4b95dd9a026 matches
Binary file ./.git/objects/e9/7efad3b1295f2e911d9489b9074b3c7f38b24c matches
Binary file ./.git/objects/15/babd49b67826cb72b67b9558976679b2c4820a matches
Binary file ./.git/objects/07/8e416574e3f67eebb6058136f33835bcdf91f2 matches
Binary file ./.git/objects/06/bc42e3e1e55a76a92dfa5a23a9d254ee0361e0 matches
./.git/objects/06/4927799208e3d295a431148780a4382cdbdc8f:xË
./.git/objects/06/4927799208e3d295a431148780a4382cdbdc8f:Â0E]ç+f/H2i^ âÊ¥Û®3ÉT­)1‚ôëÍ7¸»8œ›ÊºÎP»C«Ì EÊC ë<ÚDû¢`ŒÎZÓàQF±ÅÊ¯Z³ÊÎØœ0£ì¤˜i* ˜İ@9‘ˆŸö,î,qk;×çåô.K™ê¼ïåúXã¼œRY/ tï9ã5ÂQ*)E§ıdã?uq›¿ü†©çÇq„i‰ñ*çK2
Binary file ./.git/objects/1a/b31d772f0d2d4e14d60c36b2555d0924a28eac matches
Binary file ./.git/objects/fb/6a1c53e715b2aca1ec9d84f8e31bec41bb0b1c matches
Binary file ./.git/objects/pack/pack-a8780dc4b5a57d1871fb9f6dfbcc3500d6bd138e.idx matches
Binary file ./.git/objects/pack/pack-81d6cedb4bbb91490263e488ed35a4f02c78a274.idx matches
Binary file ./.git/objects/pack/pack-a8780dc4b5a57d1871fb9f6dfbcc3500d6bd138e.pack matches
Binary file ./.git/objects/pack/pack-81d6cedb4bbb91490263e488ed35a4f02c78a274.pack matches
Binary file ./.git/objects/b8/3170c982676a82c59221ef912c76aa6afb512d matches
Binary file ./.git/objects/84/f9c6a23976edefb02d6a1540ebc42a4d9ee06a matches
./.git/objects/22/2a37157e16202c005965d33cc7ccfa3c8ef3a2:xÎAŠÃ0@Ñ®}
./.git/objects/22/2a37157e16202c005965d33cc7ccfa3c8ef3a2:ïE¶£8†2ÌªËŞAr¤ÖÔÁñÀÓ·gèöÃƒŸëº–n}ğ§ŞDìÈ˜D–TçãY³&BØivf£&¯n#‚L
./.git/objects/22/2a37157e16202c005965d33cc7ccfa3c8ef3a2:“2%È#e™4"†Ræ&%ıõgmö.à·~H«öº\öºTmå8êïc¥²\r]¬	ÑGˆÑÁ˜OıLvù’›[ù—İÒRh—İ¼GK¢
Binary file ./.git/objects/05/b222b319b1b01c8e6dfd992e156396ed9e0653 matches
Binary file ./.git/objects/05/f24055a0b79881012da2820a5fc0532aa74669 matches
Binary file ./.git/objects/21/8c6db7d04f8715a64673bfee64804be06bcf1f matches
Binary file ./.git/objects/b1/6d59a88a319917ac80414a34f15d0932abc68f matches
Binary file ./.git/objects/e0/0a6548a76b739e06eff1c2269d5ee77515bc8c matches
./.git/ORIG_HEAD:33e1d756dc2d2398b6f1ee1b3ea192692d74bdcb
./.git/logs/refs/remotes/origin/HEAD:0000000000000000000000000000000000000000 08e807c4bdad5ecc1a91212daeacbad3be4bd5f7 Ne02ptzero <l.solofrizzo@gmail.com> 1395342241 +0100	clone: from https://github.com/Ne02ptzero/msh.git
./.git/logs/refs/remotes/origin/master:08e807c4bdad5ecc1a91212daeacbad3be4bd5f7 4cc7acd93a4c23fccf8940cef3a7ac3005f13937 Ne02ptzero <l.solofrizzo@gmail.com> 1395342330 +0100	update by push
./.git/logs/refs/remotes/origin/master:4cc7acd93a4c23fccf8940cef3a7ac3005f13937 33e1d756dc2d2398b6f1ee1b3ea192692d74bdcb ne02ptzero <ne02ptzero@dev-box> 1395413258 +0100	pull: fast-forward
./.git/logs/refs/remotes/origin/master:33e1d756dc2d2398b6f1ee1b3ea192692d74bdcb 750e4baf08fba90c6ace0e8f7553339cb938faa6 ne02ptzero <ne02ptzero@dev-box> 1395524551 +0100	pull: fast-forward
./.git/logs/refs/remotes/origin/master:750e4baf08fba90c6ace0e8f7553339cb938faa6 222a37157e16202c005965d33cc7ccfa3c8ef3a2 Ne02ptzero <l.solofrizzo@gmail.com> 1395527097 +0100	update by push
./.git/logs/refs/remotes/origin/master:222a37157e16202c005965d33cc7ccfa3c8ef3a2 4b839f561e1009a7f5e7775f53adb33789c33a57 Ne02ptzero <l.solofrizzo@gmail.com> 1395529716 +0100	update by push
./.git/logs/refs/heads/master:0000000000000000000000000000000000000000 08e807c4bdad5ecc1a91212daeacbad3be4bd5f7 Ne02ptzero <l.solofrizzo@gmail.com> 1395342241 +0100	clone: from https://github.com/Ne02ptzero/msh.git
./.git/logs/refs/heads/master:08e807c4bdad5ecc1a91212daeacbad3be4bd5f7 4cc7acd93a4c23fccf8940cef3a7ac3005f13937 Ne02ptzero <l.solofrizzo@gmail.com> 1395342322 +0100	commit: Merge leaksforever with master
./.git/logs/refs/heads/master:4cc7acd93a4c23fccf8940cef3a7ac3005f13937 33e1d756dc2d2398b6f1ee1b3ea192692d74bdcb Ne02ptzero <l.solofrizzo@gmail.com> 1395413258 +0100	pull: Fast-forward
./.git/logs/refs/heads/master:33e1d756dc2d2398b6f1ee1b3ea192692d74bdcb 750e4baf08fba90c6ace0e8f7553339cb938faa6 Ne02ptzero <l.solofrizzo@gmail.com> 1395524551 +0100	pull: Fast-forward
./.git/logs/refs/heads/master:750e4baf08fba90c6ace0e8f7553339cb938faa6 222a37157e16202c005965d33cc7ccfa3c8ef3a2 Ne02ptzero <l.solofrizzo@gmail.com> 1395527077 +0100	commit: Fixes aliases
./.git/logs/refs/heads/master:222a37157e16202c005965d33cc7ccfa3c8ef3a2 4b839f561e1009a7f5e7775f53adb33789c33a57 Ne02ptzero <l.solofrizzo@gmail.com> 1395529703 +0100	commit: Final aliases commit
./.git/logs/HEAD:0000000000000000000000000000000000000000 08e807c4bdad5ecc1a91212daeacbad3be4bd5f7 Ne02ptzero <l.solofrizzo@gmail.com> 1395342241 +0100	clone: from https://github.com/Ne02ptzero/msh.git
./.git/logs/HEAD:08e807c4bdad5ecc1a91212daeacbad3be4bd5f7 4cc7acd93a4c23fccf8940cef3a7ac3005f13937 Ne02ptzero <l.solofrizzo@gmail.com> 1395342322 +0100	commit: Merge leaksforever with master
./.git/logs/HEAD:4cc7acd93a4c23fccf8940cef3a7ac3005f13937 33e1d756dc2d2398b6f1ee1b3ea192692d74bdcb Ne02ptzero <l.solofrizzo@gmail.com> 1395413258 +0100	pull: Fast-forward
./.git/logs/HEAD:33e1d756dc2d2398b6f1ee1b3ea192692d74bdcb 750e4baf08fba90c6ace0e8f7553339cb938faa6 Ne02ptzero <l.solofrizzo@gmail.com> 1395524551 +0100	pull: Fast-forward
./.git/logs/HEAD:750e4baf08fba90c6ace0e8f7553339cb938faa6 222a37157e16202c005965d33cc7ccfa3c8ef3a2 Ne02ptzero <l.solofrizzo@gmail.com> 1395527077 +0100	commit: Fixes aliases
./.git/logs/HEAD:222a37157e16202c005965d33cc7ccfa3c8ef3a2 4b839f561e1009a7f5e7775f53adb33789c33a57 Ne02ptzero <l.solofrizzo@gmail.com> 1395529703 +0100	commit: Final aliases commit
./.git/FETCH_HEAD:750e4baf08fba90c6ace0e8f7553339cb938faa6		branch 'master' of https://github.com/Ne02ptzero/msh
./.git/config:[core]
./.git/config:	repositoryformatversion = 0
./.git/config:	filemode = true
./.git/config:	bare = false
./.git/config:	logallrefupdates = true
./.git/config:[remote "origin"]
./.git/config:	fetch = +refs/heads/*:refs/remotes/origin/*
./.git/config:	url = https://github.com/Ne02ptzero/msh.git
./.git/config:[branch "master"]
./.git/config:	remote = origin
./.git/config:	merge = refs/heads/master
Binary file ./.git/index matches
./.git/refs/remotes/origin/HEAD:ref: refs/remotes/origin/master
./.git/refs/remotes/origin/master:4b839f561e1009a7f5e7775f53adb33789c33a57
./.git/refs/heads/master:4b839f561e1009a7f5e7775f53adb33789c33a57
./.git/packed-refs:# pack-refs with: peeled 
./.git/packed-refs:e483e3ab07f779f387eb1ba592bcb8076f0b935f refs/remotes/origin/leaksforever
./.git/packed-refs:08e807c4bdad5ecc1a91212daeacbad3be4bd5f7 refs/remotes/origin/master
./.git/COMMIT_EDITMSG:Final aliases commit
./.git/HEAD:ref: refs/heads/master
./.git/info/exclude:# git ls-files --others --exclude-from=.git/info/exclude
./.git/info/exclude:# Lines that start with '#' are comments.
./.git/info/exclude:# For a project mostly in C, the following would be a good set of
./.git/info/exclude:# exclude patterns (uncomment them if you want to use them):
./.git/info/exclude:# *.[oa]
./.git/info/exclude:# *~
./includes/msh.h:/* ************************************************************************** */
./includes/msh.h:/*                                                                            */
./includes/msh.h:/*                                                        :::      ::::::::   */
./includes/msh.h:/*   msh.h                                              :+:      :+:    :+:   */
./includes/msh.h:/*                                                    +:+ +:+         +:+     */
./includes/msh.h:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./includes/msh.h:/*                                                +#+#+#+#+#+   +#+           */
./includes/msh.h:/*   Created: 2014/02/11 14:54:36 by lsolofri          #+#    #+#             */
./includes/msh.h:/*   Updated: 2014/03/23 20:40:01 by lsolofri         ###   ########.fr       */
./includes/msh.h:/*                                                                            */
./includes/msh.h:/* ************************************************************************** */
./includes/msh.h:
./includes/msh.h:#ifndef MSH_H
./includes/msh.h:# define MSH_H
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** GLOBAL LIST
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:typedef struct		s_env
./includes/msh.h:{
./includes/msh.h:	char			*name;
./includes/msh.h:	char			*value;
./includes/msh.h:	int				protect;
./includes/msh.h:	struct s_env	*next;
./includes/msh.h:}					t_env;
./includes/msh.h:
./includes/msh.h:t_env	*g_env;
./includes/msh.h:
./includes/msh.h:typedef unsigned int		t_ui;
./includes/msh.h:/*
./includes/msh.h: ** DEFINES
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:# define GC_NBSTART 100
./includes/msh.h:# define GRAY "\033[1;30m"
./includes/msh.h:# define GRAY2 "\033[0;30m"
./includes/msh.h:# define RED "\033[1;31m"
./includes/msh.h:# define RED2 "\033[0;31m"
./includes/msh.h:# define GRE "\033[1;32m"
./includes/msh.h:# define GRE2 "\033[0;32m"
./includes/msh.h:# define YEL "\033[1;33m"
./includes/msh.h:# define BLUE "\033[1;34m"
./includes/msh.h:# define BLUE2 "\033[0;34m"
./includes/msh.h:# define MAG "\033[1;35m"
./includes/msh.h:# define SBLUE "\033[1;36m"
./includes/msh.h:# define SBLUE2 "\e[4;36m"
./includes/msh.h:# define DEF "\033[0m"
./includes/msh.h:
./includes/msh.h:# define GNL_LEN 1024
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** INCLUDE OF LIBS
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:# include <unistd.h>
./includes/msh.h:# include <stdlib.h>
./includes/msh.h:# include <termios.h>
./includes/msh.h:# include <termcap.h>
./includes/msh.h:# include <sys/types.h>
./includes/msh.h:# include <sys/wait.h>
./includes/msh.h:# include <dirent.h>
./includes/msh.h:# include <fcntl.h>
./includes/msh.h:# include <signal.h>
./includes/msh.h:# include <glob.h>
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** LIST FOR VARIABLES
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:typedef struct		s_var
./includes/msh.h:{
./includes/msh.h:	char			*name;
./includes/msh.h:	char			*value;
./includes/msh.h:	struct s_var	*next;
./includes/msh.h:}					t_var;
./includes/msh.h:
./includes/msh.h:t_var	*g_var;
./includes/msh.h:char	*search_var(t_var *list, char *name);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** LIST FOR JOBS CONTROL
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:typedef struct		s_jobs
./includes/msh.h:{
./includes/msh.h:	char			*name;	/* name */
./includes/msh.h:	int				job;	/* nb job */ 
./includes/msh.h:	int				pid;	/* pid */
./includes/msh.h:	int				status; /* fg 1/ bg 2/ ^Z 0*/
./includes/msh.h:	struct s_jobs	*next;
./includes/msh.h:}					t_jobs;
./includes/msh.h:
./includes/msh.h:t_jobs	*g_jobs;
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** LIST FOR AUTOCOMP
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:typedef struct		s_struct
./includes/msh.h:{
./includes/msh.h:	char			*name;
./includes/msh.h:	char			*type;
./includes/msh.h:	struct s_struct	*next;
./includes/msh.h:}					t_list;
./includes/msh.h:
./includes/msh.h:typedef struct		s_option
./includes/msh.h:{
./includes/msh.h:	char			option;
./includes/msh.h:	char			*description;
./includes/msh.h:	struct s_option	*next;
./includes/msh.h:}					t_option;
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** ALIASES
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:typedef struct		s_alias
./includes/msh.h:{
./includes/msh.h:	char			*alias;
./includes/msh.h:	char			*value;
./includes/msh.h:	struct s_alias	*next;
./includes/msh.h:}					t_alias;
./includes/msh.h:
./includes/msh.h:t_alias	*g_alias;
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** PARSER
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:typedef struct		s_parse
./includes/msh.h:{
./includes/msh.h:	char			*str;
./includes/msh.h:	struct s_parse	*next;
./includes/msh.h:}					t_parse;
./includes/msh.h:
./includes/msh.h:typedef struct			s_command
./includes/msh.h:{
./includes/msh.h:	char				**cmd;
./includes/msh.h:	struct s_command	*next;
./includes/msh.h:}						t_command;
./includes/msh.h:
./includes/msh.h:t_command	*quick_parse(char *str);
./includes/msh.h:t_parse		*add_word(t_parse *list, char *str);
./includes/msh.h:t_parse		*tokenize(char *str);
./includes/msh.h:int			iswhite(char c);
./includes/msh.h:char		*escape_char(char *str);
./includes/msh.h:int			check_line(char *str);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** LEAKS
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:typedef struct s_gc		t_gc;
./includes/msh.h:typedef struct s_gcinfo	t_gcinfo;
./includes/msh.h:
./includes/msh.h:struct  s_gcinfo
./includes/msh.h:{
./includes/msh.h:	int     nb;
./includes/msh.h:	int     size;
./includes/msh.h:	t_gc    *first_avail;
./includes/msh.h:	t_gc    *first;
./includes/msh.h:};
./includes/msh.h:
./includes/msh.h:typedef enum	e_gcop
./includes/msh.h:{
./includes/msh.h:	E_GCADD,
./includes/msh.h:	E_GCFREE,
./includes/msh.h:	E_GCFREEALL,
./includes/msh.h:	E_GCFREEGC
./includes/msh.h:}				t_gcop;
./includes/msh.h:
./includes/msh.h:struct	s_gc
./includes/msh.h:{
./includes/msh.h:	void	*p;
./includes/msh.h:	t_gc	*next;
./includes/msh.h:};
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** ERRORS
./includes/msh.h: */
./includes/msh.h:typedef struct		s_error
./includes/msh.h:{
./includes/msh.h:	int				dquote;
./includes/msh.h:	int				squote;
./includes/msh.h:	int				pipe;
./includes/msh.h:	int				bquote;
./includes/msh.h:}					t_error;
./includes/msh.h:
./includes/msh.h:void		show_error(char *str);
./includes/msh.h:void		show_error_exit(char *str);
./includes/msh.h:void		exit_error(char **tab);
./includes/msh.h:void		unknow_cmd(char *str);
./includes/msh.h:int			cd_error(char *str);
./includes/msh.h:void		err_no_file(char *str);
./includes/msh.h:void		pid_error(char *tab);
./includes/msh.h:void		job_error(int k);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** READ
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:char		*read_cmd(void);
./includes/msh.h:void		init_flag(struct termios *term);
./includes/msh.h:void		re_flag(struct termios *term);
./includes/msh.h:char		*init_buffer(char *buffer);
./includes/msh.h:char		*history(int choice, char *str);
./includes/msh.h:char		*char_to_string(char c);
./includes/msh.h:char		*char_to_string2(char c);
./includes/msh.h:char		*del_c(char *result, int *i);
./includes/msh.h:void		show_complete(char *str, char *cmd);
./includes/msh.h:void		show_options(char c);
./includes/msh.h:void		show_rest(char *str, char *cmd);
./includes/msh.h:int			a_right(int i, int len);
./includes/msh.h:int			a_left(int i, int len);
./includes/msh.h:void		clear_line(int i, int v);
./includes/msh.h:void		replace_cursor(int i, int v);
./includes/msh.h:int			arrow(int i, char key, int len, char **result);
./includes/msh.h:char		*get_options(int fd);
./includes/msh.h:char		*read_description(int fd, char *c);
./includes/msh.h:t_option	*get_description(char *options, char *path);
./includes/msh.h:t_option	*return_options(char *cmd);
./includes/msh.h:char		*change_cmd(int i, char *result, char letter);
./includes/msh.h:int			distrib_buttons(int i, char **result, char *buffer, int *v);
./includes/msh.h:char		*take_cmd(int choice);
./includes/msh.h:t_list		*add_type(t_list *list, char *str, char *type);
./includes/msh.h:t_list		*recup_prog(char *str, char **tab, t_list *list);
./includes/msh.h:void		show_cmd(char *str);
./includes/msh.h:t_option	*add_option(t_option *list, char option, char *description);
./includes/msh.h:char		*get_cmd_description(char *cmd);
./includes/msh.h:char		*show_autocomplete(char *str, int v);
./includes/msh.h:void		show_options_in_line(char *cmd);
./includes/msh.h:void		show_diff_option(char *str);
./includes/msh.h:void		syntax_color_rest(char *str);
./includes/msh.h:void		write_cmd(char *str, int i, int command);
./includes/msh.h:int			check_prog(char *str);
./includes/msh.h:int			auto_comp_choice(int i);
./includes/msh.h:char		*spe_autocomp(char *cmd, int len);
./includes/msh.h:char		*argument_completion(char *str);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** FUNCTIONS
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:int			ft_putchar(char c);
./includes/msh.h:char		*ft_strjoin(char const *s1, char const *s2);
./includes/msh.h:char		*ft_spe_strjoin(char const *s1, char const *s2);
./includes/msh.h:char		*ft_strsub(char const *s, unsigned int start, size_t len);
./includes/msh.h:char		*ft_spe_strsub(char const *s, unsigned int start, size_t len);
./includes/msh.h:int			ft_strlen(char *s);
./includes/msh.h:char		**ft_new_tab(int i);
./includes/msh.h:int			ft_tablen(char **tab);
./includes/msh.h:int			ft_tabncmp(char **env, char **av);
./includes/msh.h:char		*ft_strdup(const char *s1);
./includes/msh.h:int			ft_strcmp(const char *s1, const char *s2);
./includes/msh.h:int			ft_strncmp(const char *s1, const char *s2, size_t n);
./includes/msh.h:int			ft_isprint(int c);
./includes/msh.h:void		ft_putendl(char const *s);
./includes/msh.h:void		ft_putnbr(int nb);
./includes/msh.h:void		ft_putstr(char const *s);
./includes/msh.h:int			ft_strcmp(const char *s1, const char *s2);
./includes/msh.h:char		*ft_strdup(const char *s);
./includes/msh.h:char		*ft_strjoin(char const *s1, char const *s2);
./includes/msh.h:int			ft_strlen(char *s);
./includes/msh.h:char		**ft_strsplit(char const *s, char c);
./includes/msh.h:char		**ft_spe_strsplit(char const *s, char c);
./includes/msh.h:char		*ft_strsub(char const *s, unsigned int start, size_t len);
./includes/msh.h:char		*get_next_line(int fd);
./includes/msh.h:char		*get_man_path(void);
./includes/msh.h:int			ft_isdigit(char c);
./includes/msh.h:int			ft_atoi(const char *str);
./includes/msh.h:char		*result_cmd(char *tab);
./includes/msh.h:void		welcome(void);
./includes/msh.h:char		**ft_insert_tab(char **src, char **tab, int i);
./includes/msh.h:void		*ft_memalloc(size_t size);
./includes/msh.h:void		ft_gc(void *p, t_gcop op);
./includes/msh.h:void		ft_bzero(void *s, size_t n);
./includes/msh.h:void		ft_gcrealloc(t_gc **ring, t_gcinfo **info, int init_size);
./includes/msh.h:void		ft_gcinit(t_gc **ring, int init_size, t_gcinfo **info);
./includes/msh.h:char		*ft_itoa(long n);
./includes/msh.h:char		*join_spe_tab(char **tab, int beg, int end);
./includes/msh.h:char		*ft_strnew(size_t size);
./includes/msh.h:void		*ft_memcpy(void *s1, const void *s2, size_t n);
./includes/msh.h:int			ft_isalpha(char c);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** ENVIRON
./includes/msh.h: */
./includes/msh.h:t_env	*add_env(t_env *env, char *name, char *value, int protect);
./includes/msh.h:void	new_env(char **env);
./includes/msh.h:void	print_list(t_env *env);
./includes/msh.h:char	*find_value_envir(t_env *env, char *str);
./includes/msh.h:t_env	*ft_unsetenv(t_env *env, char *str);
./includes/msh.h:t_env	*ft_setenv(t_env *env, char *name, char *value);
./includes/msh.h:char	**make_env_tab(t_env *env);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** BUILTIN
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:void		ft_echo(char **tab);
./includes/msh.h:int			ft_exit(char **tab);
./includes/msh.h:int			ft_cd(char **tab);
./includes/msh.h:void		load_conf_file(void);
./includes/msh.h:char		**is_alias(t_alias *list, char **tab);
./includes/msh.h:void		ft_alias(char **tab);
./includes/msh.h:t_var		*add_var(t_var *list, char *name, char *value);
./includes/msh.h:t_var		*del_var(t_var *list, char *name);
./includes/msh.h:void		show_var(t_var *list);
./includes/msh.h:void		set_var(char *name, char *value);
./includes/msh.h:void		unset_var(char *name);
./includes/msh.h:void		ft_set(char **tab);
./includes/msh.h:void		export_var(t_var *list, char *name);
./includes/msh.h:void		no_conf(void);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** MAIN
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:void		ft_mishell(char *line);
./includes/msh.h:char		**ft_get_path(char **env, char *line);
./includes/msh.h:void		exec_cmd(char **tab);
./includes/msh.h:int			detect_built(char **tab);
./includes/msh.h:int			pre_exec(char *str);
./includes/msh.h:int			pre_exec_nofork(char *str);
./includes/msh.h:int			pre_exec_nowait(char *str);
./includes/msh.h:void		main_options(char **av, int *choice);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** PROMPT
./includes/msh.h: */
./includes/msh.h:void	basic_prompt(void);
./includes/msh.h:void	prompt(void);
./includes/msh.h:void	prompt_interpreter(char *str);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** PIPE
./includes/msh.h: */
./includes/msh.h:int	check_redirection(char **tab);
./includes/msh.h:void	infile(char *str);
./includes/msh.h:char	**re_tab(char **tab, int i);
./includes/msh.h:void	outfile(char *str);
./includes/msh.h:void	spe_outfile(char *str);
./includes/msh.h:void	go_pipe(char	**tab);
./includes/msh.h:t_command *split_pipe(t_command *list);
./includes/msh.h:char	**join_tab(char **tab);
./includes/msh.h:void	spe_infile(char *str);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h: ** SIGNALS
./includes/msh.h: */
./includes/msh.h:
./includes/msh.h:void	interrupt_process(int s);
./includes/msh.h:void	interrupt_cmd(int s);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h:** JOBS
./includes/msh.h:*/
./includes/msh.h:
./includes/msh.h:t_jobs		*add_job(t_jobs *list, char *name, int pid);
./includes/msh.h:t_jobs		*remove_jobs(t_jobs *jobs, int pid);
./includes/msh.h:void		show_jobs(t_jobs *jobs);
./includes/msh.h:void		check_return(int ret, int pid);
./includes/msh.h:void		show_stop(int sig);
./includes/msh.h:char		*find_prog(t_jobs *jobs, int pid);
./includes/msh.h:void		fg_bg(t_jobs *jobs, char **tab, int k);
./includes/msh.h:int			search_job(t_jobs *jobs, char *tab, int rt);
./includes/msh.h:
./includes/msh.h:/*
./includes/msh.h:** OPERATORS
./includes/msh.h:*/
./includes/msh.h:
./includes/msh.h:void	check_operators(char **tab);
./includes/msh.h:
./includes/msh.h:#endif /* MSH_H */
Binary file ./srcs/parser/parser.o matches
./srcs/parser/check_line.c:/* ************************************************************************** */
./srcs/parser/check_line.c:/*                                                                            */
./srcs/parser/check_line.c:/*                                                        :::      ::::::::   */
./srcs/parser/check_line.c:/*   lex.c                                              :+:      :+:    :+:   */
./srcs/parser/check_line.c:/*                                                    +:+ +:+         +:+     */
./srcs/parser/check_line.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/parser/check_line.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/parser/check_line.c:/*   Created: 2014/02/28 13:10:28 by rkharif           #+#    #+#             */
./srcs/parser/check_line.c:/*   Updated: 2014/03/23 20:15:18 by lsolofri         ###   ########.fr       */
./srcs/parser/check_line.c:/*                                                                            */
./srcs/parser/check_line.c:/* ************************************************************************** */
./srcs/parser/check_line.c:
./srcs/parser/check_line.c:#include "../../includes/msh.h"
./srcs/parser/check_line.c:
./srcs/parser/check_line.c:char	*escape_char(char *str)
./srcs/parser/check_line.c:{
./srcs/parser/check_line.c:	int		i;
./srcs/parser/check_line.c:	char	replace;
./srcs/parser/check_line.c:	int		flag;
./srcs/parser/check_line.c:
./srcs/parser/check_line.c:	i = 0;
./srcs/parser/check_line.c:	flag = 0;
./srcs/parser/check_line.c:	while (str[i])
./srcs/parser/check_line.c:	{
./srcs/parser/check_line.c:		if (str[i] == '\'')
./srcs/parser/check_line.c:			flag = (flag ? 0 : 1);
./srcs/parser/check_line.c:		else if (str[i] == '"')
./srcs/parser/check_line.c:			flag = (flag ? 0 : 2);
./srcs/parser/check_line.c:		if (str[i] == '\\')
./srcs/parser/check_line.c:		{
./srcs/parser/check_line.c:			if (str[i + 1] == 'a')
./srcs/parser/check_line.c:				replace = '\a';
./srcs/parser/check_line.c:			else if (str[i + 1] == 'b')
./srcs/parser/check_line.c:				replace = '\b';
./srcs/parser/check_line.c:			else if (str[i + 1] == 'n')
./srcs/parser/check_line.c:				replace = '\n';
./srcs/parser/check_line.c:			else if (str[i + 1] == 't')
./srcs/parser/check_line.c:				replace = '\t';
./srcs/parser/check_line.c:			else if (str[i + 1] == 'v')
./srcs/parser/check_line.c:				replace = '\v';
./srcs/parser/check_line.c:			else if (str[i + 1] == 'f')
./srcs/parser/check_line.c:				replace = '\f';
./srcs/parser/check_line.c:			else if (str[i + 1] == 'r')
./srcs/parser/check_line.c:				replace = '\r';
./srcs/parser/check_line.c:			else
./srcs/parser/check_line.c:				replace = str[i + 1];
./srcs/parser/check_line.c:			++i;
./srcs/parser/check_line.c:			str = del_c(str, &i);
./srcs/parser/check_line.c:			if (replace != str[i] && flag)
./srcs/parser/check_line.c:			{
./srcs/parser/check_line.c:				++i;
./srcs/parser/check_line.c:				str = del_c(str, &i);
./srcs/parser/check_line.c:				str = change_cmd(i, ft_strdup(str), replace);
./srcs/parser/check_line.c:			}
./srcs/parser/check_line.c:			++i;
./srcs/parser/check_line.c:		}
./srcs/parser/check_line.c:		if (str[i])
./srcs/parser/check_line.c:			i++;
./srcs/parser/check_line.c:	}
./srcs/parser/check_line.c:	return (str);
./srcs/parser/check_line.c:}
./srcs/parser/check_line.c:
./srcs/parser/check_line.c:int		check_line(char *str)
./srcs/parser/check_line.c:{
./srcs/parser/check_line.c:	t_error		err;
./srcs/parser/check_line.c:	int		i;
./srcs/parser/check_line.c:
./srcs/parser/check_line.c:	i = 0;
./srcs/parser/check_line.c:	err.dquote = 0;
./srcs/parser/check_line.c:	err.squote = 0;
./srcs/parser/check_line.c:	err.pipe = 0;
./srcs/parser/check_line.c:	err.bquote = 0;
./srcs/parser/check_line.c:	while (str[i])
./srcs/parser/check_line.c:	{
./srcs/parser/check_line.c:		if (str[i] == '"' && str[i - 1] != '\\')
./srcs/parser/check_line.c:		{
./srcs/parser/check_line.c:			err.dquote = 1;
./srcs/parser/check_line.c:			++i;
./srcs/parser/check_line.c:			while (str[i] != '"' && str[i])
./srcs/parser/check_line.c:			{
./srcs/parser/check_line.c:				if (str[i] == '\\')
./srcs/parser/check_line.c:					++i;
./srcs/parser/check_line.c:				++i;
./srcs/parser/check_line.c:			}
./srcs/parser/check_line.c:			if (str[i] == '"')
./srcs/parser/check_line.c:				err.dquote = 0;
./srcs/parser/check_line.c:		}
./srcs/parser/check_line.c:		else if (str[i] == '\'' && str[i] != '\\')
./srcs/parser/check_line.c:		{
./srcs/parser/check_line.c:			err.squote = 1;
./srcs/parser/check_line.c:			++i;
./srcs/parser/check_line.c:			while (str[i] != '\'' && str[i])
./srcs/parser/check_line.c:				++i;
./srcs/parser/check_line.c:			if (str[i] == '\'')
./srcs/parser/check_line.c:				err.squote = 0;
./srcs/parser/check_line.c:		}
./srcs/parser/check_line.c:		else if (str[i] == '`' && str[i - 1] != '\\')
./srcs/parser/check_line.c:		{
./srcs/parser/check_line.c:			err.bquote = 1;
./srcs/parser/check_line.c:			++i;
./srcs/parser/check_line.c:			while (str[i] != '`' && str[i])
./srcs/parser/check_line.c:				++i;
./srcs/parser/check_line.c:			if (str[i] == '`')
./srcs/parser/check_line.c:				err.bquote = 0;
./srcs/parser/check_line.c:		}
./srcs/parser/check_line.c:		else if (str[i] == '|' && str[i - 1] != '\\')
./srcs/parser/check_line.c:		{
./srcs/parser/check_line.c:			err.pipe = 1;
./srcs/parser/check_line.c:			++i;
./srcs/parser/check_line.c:			while (iswhite(str[i]))
./srcs/parser/check_line.c:				++i;
./srcs/parser/check_line.c:			if (str[i])
./srcs/parser/check_line.c:				err.pipe = 0;
./srcs/parser/check_line.c:		}
./srcs/parser/check_line.c:		++i;
./srcs/parser/check_line.c:	}
./srcs/parser/check_line.c:	if (err.dquote == 1)
./srcs/parser/check_line.c:	{
./srcs/parser/check_line.c:		ft_putendl("Missing double quote.");
./srcs/parser/check_line.c:		return (1);
./srcs/parser/check_line.c:	}
./srcs/parser/check_line.c:	if (err.squote == 1)
./srcs/parser/check_line.c:	{
./srcs/parser/check_line.c:		ft_putendl("Missing single quote.");
./srcs/parser/check_line.c:		return (1);
./srcs/parser/check_line.c:	}
./srcs/parser/check_line.c:	if (err.pipe == 1)
./srcs/parser/check_line.c:	{
./srcs/parser/check_line.c:		ft_putendl("Invalid null command");
./srcs/parser/check_line.c:		return (1);
./srcs/parser/check_line.c:	}
./srcs/parser/check_line.c:	if (err.bquote == 1)
./srcs/parser/check_line.c:	{
./srcs/parser/check_line.c:		ft_putendl("Missing back quote.");
./srcs/parser/check_line.c:		return (1);
./srcs/parser/check_line.c:	}
./srcs/parser/check_line.c:	return (0);
./srcs/parser/check_line.c:}
./srcs/parser/lex.c:/* ************************************************************************** */
./srcs/parser/lex.c:/*                                                                            */
./srcs/parser/lex.c:/*                                                        :::      ::::::::   */
./srcs/parser/lex.c:/*   lex.c                                              :+:      :+:    :+:   */
./srcs/parser/lex.c:/*                                                    +:+ +:+         +:+     */
./srcs/parser/lex.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/parser/lex.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/parser/lex.c:/*   Created: 2014/02/28 13:10:28 by rkharif           #+#    #+#             */
./srcs/parser/lex.c:/*   Updated: 2014/03/23 21:24:14 by lsolofri         ###   ########.fr       */
./srcs/parser/lex.c:/*                                                                            */
./srcs/parser/lex.c:/* ************************************************************************** */
./srcs/parser/lex.c:
./srcs/parser/lex.c:#include "../../includes/msh.h"
./srcs/parser/lex.c:
./srcs/parser/lex.c:int		iswhite(char c)
./srcs/parser/lex.c:{
./srcs/parser/lex.c:	if (c == ' ')
./srcs/parser/lex.c:		return (1);
./srcs/parser/lex.c:	if (c == '\t')
./srcs/parser/lex.c:		return (1);
./srcs/parser/lex.c:	if (c == '\v')
./srcs/parser/lex.c:		return (1);
./srcs/parser/lex.c:	if (c == '\r')
./srcs/parser/lex.c:		return (1);
./srcs/parser/lex.c:	if (c == '\n')
./srcs/parser/lex.c:		return (1);
./srcs/parser/lex.c:	return (0);
./srcs/parser/lex.c:}
./srcs/parser/lex.c:
./srcs/parser/lex.c:int		isop(char c)
./srcs/parser/lex.c:{
./srcs/parser/lex.c:	char	optab[] = "$;^()=><`|&{}~"; 
./srcs/parser/lex.c:	int		i;
./srcs/parser/lex.c:
./srcs/parser/lex.c:	i = 0;
./srcs/parser/lex.c:	while (optab[i])
./srcs/parser/lex.c:	{
./srcs/parser/lex.c:		if (c == optab[i])
./srcs/parser/lex.c:			return (1);
./srcs/parser/lex.c:		++i;
./srcs/parser/lex.c:	}
./srcs/parser/lex.c:	return (0);
./srcs/parser/lex.c:}
./srcs/parser/lex.c:
./srcs/parser/lex.c:int		iskey(char *str)
./srcs/parser/lex.c:{
./srcs/parser/lex.c:	char	*keyword[] = {"if", "do", "while", "in", "case", "done", "elif",
./srcs/parser/lex.c:		"else", "esac", "fi", "for", "then", "until"};
./srcs/parser/lex.c:	int		i;
./srcs/parser/lex.c:
./srcs/parser/lex.c:	i = 0;
./srcs/parser/lex.c:	while (ft_strcmp(keyword[i], str) != 0 && keyword[i])
./srcs/parser/lex.c:		++i;
./srcs/parser/lex.c:	if (keyword[i])
./srcs/parser/lex.c:		return (1);
./srcs/parser/lex.c:	return (0);
./srcs/parser/lex.c:}
./srcs/parser/lex.c:
./srcs/parser/lex.c:char	*spe_quote(char *str, int *i, char quote, int start)
./srcs/parser/lex.c:{
./srcs/parser/lex.c:	char	*result;
./srcs/parser/lex.c:	char	*spe_result;
./srcs/parser/lex.c:	int		j;
./srcs/parser/lex.c:
./srcs/parser/lex.c:	while (str[*i] != ' ' && isop(str[*i]) && str[*i] != ';' && str[*i])
./srcs/parser/lex.c:		++*i;
./srcs/parser/lex.c:	result = ft_strsub(str, start, (ft_strlen(str) - start));
./srcs/parser/lex.c:	ft_putendl(result);
./srcs/parser/lex.c:	start = j = 0;
./srcs/parser/lex.c:	spe_result = (char *)malloc(sizeof(char) * ft_strlen(result));
./srcs/parser/lex.c:	while (result[start])
./srcs/parser/lex.c:	{
./srcs/parser/lex.c:		if (result[start] == quote && result[start - 1] != '\\')
./srcs/parser/lex.c:			start++;
./srcs/parser/lex.c:		if (result[start])
./srcs/parser/lex.c:			spe_result[j] = result[start];
./srcs/parser/lex.c:		start++;
./srcs/parser/lex.c:		j++;
./srcs/parser/lex.c:	}
./srcs/parser/lex.c:	result[j] = '\0';
./srcs/parser/lex.c:	return (spe_result);
./srcs/parser/lex.c:}
./srcs/parser/lex.c:
./srcs/parser/lex.c:char	*quote(char *str, int *i, char quote)
./srcs/parser/lex.c:{
./srcs/parser/lex.c:	char	*result;
./srcs/parser/lex.c:	int		flag;
./srcs/parser/lex.c:	int		j;
./srcs/parser/lex.c:	char	*tmp;
./srcs/parser/lex.c:	int		v;
./srcs/parser/lex.c:
./srcs/parser/lex.c:	flag = j = 0;
./srcs/parser/lex.c:	result = malloc(1024);
./srcs/parser/lex.c:	++*i;
./srcs/parser/lex.c:	while (flag == 0)
./srcs/parser/lex.c:	{
./srcs/parser/lex.c:		if (!str[*i])
./srcs/parser/lex.c:			flag = 1;
./srcs/parser/lex.c:		else if (str[*i] == quote && str[*i - 1] != '\\')
./srcs/parser/lex.c:		{
./srcs/parser/lex.c:			if (str[*i + 1] && !ft_isalpha(str[*i + 1]))
./srcs/parser/lex.c:				flag = 1;
./srcs/parser/lex.c:			else if (!str[*i + 1])
./srcs/parser/lex.c:				flag = 1;
./srcs/parser/lex.c:			else
./srcs/parser/lex.c:				++*i;
./srcs/parser/lex.c:		}
./srcs/parser/lex.c:		else if (str[*i] == '$' && str[*i - 1] != '\\')
./srcs/parser/lex.c:		{
./srcs/parser/lex.c:			v = *i + 1;
./srcs/parser/lex.c:			while (ft_isalpha(str[v]))
./srcs/parser/lex.c:				++v;
./srcs/parser/lex.c:			tmp = search_var(g_var, ft_strsub(str, *i + 1, (v - *i - 1)));
./srcs/parser/lex.c:			*i = v;
./srcs/parser/lex.c:			v = 0;
./srcs/parser/lex.c:			if (tmp)
./srcs/parser/lex.c:			{
./srcs/parser/lex.c:				while (tmp[v])
./srcs/parser/lex.c:				{
./srcs/parser/lex.c:					result[j] = tmp[v];
./srcs/parser/lex.c:					++j;
./srcs/parser/lex.c:					++v;
./srcs/parser/lex.c:				}
./srcs/parser/lex.c:				result[j] = '\0';
./srcs/parser/lex.c:			}
./srcs/parser/lex.c:		}
./srcs/parser/lex.c:		else
./srcs/parser/lex.c:		{
./srcs/parser/lex.c:			result[j] = str[*i];
./srcs/parser/lex.c:			++j;
./srcs/parser/lex.c:			++*i;
./srcs/parser/lex.c:		}
./srcs/parser/lex.c:	}
./srcs/parser/lex.c:	result[j] = 0;
./srcs/parser/lex.c:	++*i;
./srcs/parser/lex.c:	return (result);
./srcs/parser/lex.c:}
./srcs/parser/lex.c:
./srcs/parser/lex.c:char	*ope_str(char *str, int start, int *i)
./srcs/parser/lex.c:{
./srcs/parser/lex.c:	char	*result;
./srcs/parser/lex.c:	char	*tmp;
./srcs/parser/lex.c:	int		v;
./srcs/parser/lex.c:
./srcs/parser/lex.c:	if (str[*i] == '$')
./srcs/parser/lex.c:	{
./srcs/parser/lex.c:			v = *i + 1;
./srcs/parser/lex.c:			while (ft_isalpha(str[v]) && str[v])
./srcs/parser/lex.c:				++v;
./srcs/parser/lex.c:			result = search_var(g_var, ft_strsub(str, *i + 1, (v - *i - 1)));
./srcs/parser/lex.c:			*i = v - 1;
./srcs/parser/lex.c:			if (str[*i])
./srcs/parser/lex.c:			{
./srcs/parser/lex.c:				while (str[*i] != ' ' && str[*i])
./srcs/parser/lex.c:					++*i;
./srcs/parser/lex.c:				tmp = ft_strsub(str, v, (*i - v));
./srcs/parser/lex.c:				result = ft_strjoin(result, tmp);
./srcs/parser/lex.c:				free(tmp);
./srcs/parser/lex.c:			}
./srcs/parser/lex.c:	}
./srcs/parser/lex.c:	else if (str[*i] == '~')
./srcs/parser/lex.c:	{
./srcs/parser/lex.c:		++*i;
./srcs/parser/lex.c:		while (!(iswhite(str[*i])) && !(isop(str[*i])) && str[*i])
./srcs/parser/lex.c:			++*i;
./srcs/parser/lex.c:		tmp = ft_strsub(str, start + 1, (*i - start));
./srcs/parser/lex.c:		result = ft_strjoin(find_value_envir(g_env, "HOME"), tmp);
./srcs/parser/lex.c:	}
./srcs/parser/lex.c:	else if (str[*i] == '`')
./srcs/parser/lex.c:	{
./srcs/parser/lex.c:		++*i;
./srcs/parser/lex.c:		v = *i;
./srcs/parser/lex.c:		while (str[*i] != '`' && str[*i])
./srcs/parser/lex.c:			++*i;
./srcs/parser/lex.c:		tmp = ft_strsub(str, v, (*i - v));
./srcs/parser/lex.c:		result = result_cmd(tmp);
./srcs/parser/lex.c:	}
./srcs/parser/lex.c:	else if (str[*i] == '(')
./srcs/parser/lex.c:	{
./srcs/parser/lex.c:		v = *i + 1;
./srcs/parser/lex.c:		while (str[*i] != ')' && str[*i])
./srcs/parser/lex.c:			++*i;
./srcs/parser/lex.c:		result = ft_strsub(str, v, (*i - v));
./srcs/parser/lex.c:	}
./srcs/parser/lex.c:	else
./srcs/parser/lex.c:		result = char_to_string(str[start]);
./srcs/parser/lex.c:	return (result);
./srcs/parser/lex.c:}
./srcs/parser/lex.c:
./srcs/parser/lex.c:t_parse		*tokenize(char *str)
./srcs/parser/lex.c:{
./srcs/parser/lex.c:	t_parse		*list;
./srcs/parser/lex.c:	int			len;
./srcs/parser/lex.c:	int			i;
./srcs/parser/lex.c:	int			start;
./srcs/parser/lex.c:	int			openflag;
./srcs/parser/lex.c:
./srcs/parser/lex.c:	openflag = 0;
./srcs/parser/lex.c:	i = 0;
./srcs/parser/lex.c:	list = NULL;
./srcs/parser/lex.c:	while (str[i])
./srcs/parser/lex.c:	{
./srcs/parser/lex.c:		len = 0;
./srcs/parser/lex.c:		while (iswhite(str[i]) && str[i])
./srcs/parser/lex.c:			++i;
./srcs/parser/lex.c:		start = i;
./srcs/parser/lex.c:		if (isop(str[i]) == 1 && isop(str[i + 1]) == 1 && str[i] == str[i + 1])
./srcs/parser/lex.c:		{
./srcs/parser/lex.c:			len += 2;
./srcs/parser/lex.c:			list = add_word(list, ft_strsub(str, start, len));
./srcs/parser/lex.c:			i += 2;
./srcs/parser/lex.c:		}
./srcs/parser/lex.c:		else if (isop(str[i]))
./srcs/parser/lex.c:		{
./srcs/parser/lex.c:			len++;
./srcs/parser/lex.c:			openflag = i;
./srcs/parser/lex.c:			if (str[i] == '(')
./srcs/parser/lex.c:				list = add_word(list, "(");
./srcs/parser/lex.c:			if (ope_str(str, start, &i))
./srcs/parser/lex.c:			{
./srcs/parser/lex.c:				i = openflag;
./srcs/parser/lex.c:				list = add_word(list, ope_str(str, start, &i));
./srcs/parser/lex.c:			}
./srcs/parser/lex.c:			if (str[i] == ')')
./srcs/parser/lex.c:				list = add_word(list, ")");
./srcs/parser/lex.c:			if (str[i])
./srcs/parser/lex.c:				++i;
./srcs/parser/lex.c:		}
./srcs/parser/lex.c:		else if (str[i] == '\'' || str[i] == '"')
./srcs/parser/lex.c:			list = add_word(list, quote(str, &i, str[i]));
./srcs/parser/lex.c:		else
./srcs/parser/lex.c:		{
./srcs/parser/lex.c:			len = 0;
./srcs/parser/lex.c:			while (iswhite(str[i]) == 0 && isop(str[i]) == 0 && str[i])
./srcs/parser/lex.c:			{
./srcs/parser/lex.c:				len++;
./srcs/parser/lex.c:				++i;
./srcs/parser/lex.c:			}
./srcs/parser/lex.c:			list = add_word(list, ft_strsub(str, start, len));
./srcs/parser/lex.c:		}
./srcs/parser/lex.c:		while (iswhite(str[i]) && str[i])
./srcs/parser/lex.c:			++i;
./srcs/parser/lex.c:	}
./srcs/parser/lex.c:	return (list);
./srcs/parser/lex.c:}
Binary file ./srcs/parser/lex.o matches
./srcs/parser/parser.c:/* ************************************************************************** */
./srcs/parser/parser.c:/*                                                                            */
./srcs/parser/parser.c:/*                                                        :::      ::::::::   */
./srcs/parser/parser.c:/*   parser.c                                           :+:      :+:    :+:   */
./srcs/parser/parser.c:/*                                                    +:+ +:+         +:+     */
./srcs/parser/parser.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/parser/parser.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/parser/parser.c:/*   Created: 2014/02/25 06:57:02 by lsolofri          #+#    #+#             */
./srcs/parser/parser.c:/*   Updated: 2014/03/23 21:30:58 by lsolofri         ###   ########.fr       */
./srcs/parser/parser.c:/*                                                                            */
./srcs/parser/parser.c:/* ************************************************************************** */
./srcs/parser/parser.c:
./srcs/parser/parser.c:#include "../../includes/msh.h"
./srcs/parser/parser.c:#include <stdio.h>
./srcs/parser/parser.c:
./srcs/parser/parser.c:t_parse		*add_word(t_parse *list, char *str)
./srcs/parser/parser.c:{
./srcs/parser/parser.c:	t_parse		*tmp;
./srcs/parser/parser.c:	t_parse		*tmp2;
./srcs/parser/parser.c:
./srcs/parser/parser.c:	tmp2 = list;
./srcs/parser/parser.c:	tmp = (t_parse *)malloc(sizeof(t_parse));
./srcs/parser/parser.c:	tmp->str = str;
./srcs/parser/parser.c:	tmp->next = NULL;
./srcs/parser/parser.c:	if (list == NULL)
./srcs/parser/parser.c:		return (tmp);
./srcs/parser/parser.c:	while (tmp2->next != NULL)
./srcs/parser/parser.c:		tmp2 = tmp2->next;
./srcs/parser/parser.c:	tmp2->next = tmp;
./srcs/parser/parser.c:	return (list);
./srcs/parser/parser.c:}
./srcs/parser/parser.c:
./srcs/parser/parser.c:int		list_len_cmd(t_parse *list)
./srcs/parser/parser.c:{
./srcs/parser/parser.c:	int		i;
./srcs/parser/parser.c:
./srcs/parser/parser.c:	i = 0;
./srcs/parser/parser.c:	while (list && (ft_strcmp(list->str, ";")))
./srcs/parser/parser.c:	{
./srcs/parser/parser.c:		list = list->next;
./srcs/parser/parser.c:		++i;
./srcs/parser/parser.c:	}
./srcs/parser/parser.c:	return (i);
./srcs/parser/parser.c:}
./srcs/parser/parser.c:
./srcs/parser/parser.c:t_command	*add_tab(t_command *result, char **tab)
./srcs/parser/parser.c:{
./srcs/parser/parser.c:	t_command	*tmp;
./srcs/parser/parser.c:	t_command	*tmp2;
./srcs/parser/parser.c:
./srcs/parser/parser.c:	tmp2 = result;
./srcs/parser/parser.c:	tmp = (t_command *)malloc(sizeof(t_command));
./srcs/parser/parser.c:	tmp->cmd = tab;
./srcs/parser/parser.c:	tmp->next = NULL;
./srcs/parser/parser.c:	if (result == NULL)
./srcs/parser/parser.c:		return (tmp);
./srcs/parser/parser.c:	while (tmp2->next != NULL)
./srcs/parser/parser.c:		tmp2 = tmp2->next;
./srcs/parser/parser.c:	tmp2->next = tmp;
./srcs/parser/parser.c:	return (result);
./srcs/parser/parser.c:}
./srcs/parser/parser.c:
./srcs/parser/parser.c:void	show_me_the_truth_bitch_get_outta_my_way(t_parse *list)
./srcs/parser/parser.c:{
./srcs/parser/parser.c:	while (list)
./srcs/parser/parser.c:	{
./srcs/parser/parser.c:		printf("%s\n", list->str);
./srcs/parser/parser.c:		list = list->next;
./srcs/parser/parser.c:	}
./srcs/parser/parser.c:}
./srcs/parser/parser.c:
./srcs/parser/parser.c:t_command	*quick_parse(char *str)
./srcs/parser/parser.c:{
./srcs/parser/parser.c:	t_parse 	*list;
./srcs/parser/parser.c:	int			i;
./srcs/parser/parser.c:	char		**tab;
./srcs/parser/parser.c:	t_command	*result;
./srcs/parser/parser.c:	glob_t		globlist;
./srcs/parser/parser.c:	int			j;
./srcs/parser/parser.c:
./srcs/parser/parser.c:	i = 0;
./srcs/parser/parser.c:	result = NULL;
./srcs/parser/parser.c:	history(0, str);
./srcs/parser/parser.c:	if (check_line(str))
./srcs/parser/parser.c:		return (result);
./srcs/parser/parser.c:	str = escape_char(str);
./srcs/parser/parser.c:	list = tokenize(str);
./srcs/parser/parser.c://	show_me_the_truth_bitch_get_outta_my_way(list);
./srcs/parser/parser.c:	result = NULL;
./srcs/parser/parser.c:	while (list)
./srcs/parser/parser.c:	{
./srcs/parser/parser.c:		i = list_len_cmd(list);
./srcs/parser/parser.c:		tab = (char **)malloc(sizeof(char *) * 1024);
./srcs/parser/parser.c:		tab[i] = NULL;
./srcs/parser/parser.c:		i = 0;
./srcs/parser/parser.c:		while (list != NULL && (ft_strcmp(list->str, ";")) && i < 1024)
./srcs/parser/parser.c:		{
./srcs/parser/parser.c:			j = 0;
./srcs/parser/parser.c:			glob(list->str, GLOB_NOCHECK, 0, &globlist);
./srcs/parser/parser.c:			while (globlist.gl_pathv[j])
./srcs/parser/parser.c:			{
./srcs/parser/parser.c:				tab[i] = globlist.gl_pathv[j];
./srcs/parser/parser.c:				++i;
./srcs/parser/parser.c:				++j;
./srcs/parser/parser.c:			}
./srcs/parser/parser.c:			list = list->next;
./srcs/parser/parser.c:		}
./srcs/parser/parser.c:		tab[i] = NULL;
./srcs/parser/parser.c:		result = add_tab(result, tab);
./srcs/parser/parser.c:		if (list)
./srcs/parser/parser.c:			list = list->next;
./srcs/parser/parser.c:	}
./srcs/parser/parser.c:	return (result);
./srcs/parser/parser.c:}
Binary file ./srcs/parser/check_line.o matches
./srcs/main/built.c:/* ************************************************************************** */
./srcs/main/built.c:/*                                                                            */
./srcs/main/built.c:/*                                                        :::      ::::::::   */
./srcs/main/built.c:/*   built.c                                            :+:      :+:    :+:   */
./srcs/main/built.c:/*                                                    +:+ +:+         +:+     */
./srcs/main/built.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/main/built.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/main/built.c:/*   Created: 2014/02/21 18:56:49 by lsolofri          #+#    #+#             */
./srcs/main/built.c:/*   Updated: 2014/03/23 15:01:54 by lsolofri         ###   ########.fr       */
./srcs/main/built.c:/*                                                                            */
./srcs/main/built.c:/* ************************************************************************** */
./srcs/main/built.c:
./srcs/main/built.c:#include "../../includes/msh.h"
./srcs/main/built.c:
./srcs/main/built.c:int		detect_built(char **tab)
./srcs/main/built.c:{
./srcs/main/built.c:	int		ret;
./srcs/main/built.c:
./srcs/main/built.c:	if (!(ret = ft_strcmp("exit", tab[0])) || !(ret = ft_strcmp("q", tab[0])))
./srcs/main/built.c:		ft_exit(tab);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("cd", tab[0])))
./srcs/main/built.c:		ft_cd(tab);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("env", tab[0])))
./srcs/main/built.c:		print_list(g_env);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("setenv", tab[0])))
./srcs/main/built.c:		g_env = ft_setenv(g_env, tab[1], tab[2]);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("unsetenv", tab[0])))
./srcs/main/built.c:		g_env = ft_unsetenv(g_env, tab[1]);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("echo", tab[0])))
./srcs/main/built.c:		ft_echo(tab);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("alias", tab[0])))
./srcs/main/built.c:		ft_alias(tab);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("set", tab[0])))
./srcs/main/built.c:		ft_set(tab);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("unset", tab[0])))
./srcs/main/built.c:		unset_var(tab[1]);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("export", tab[0])))
./srcs/main/built.c:		export_var(g_var, tab[1]);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("jobs", tab[0])))
./srcs/main/built.c:		show_jobs(g_jobs);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("fg", tab[0])))
./srcs/main/built.c:		fg_bg(g_jobs, tab, 1);
./srcs/main/built.c:	else if (!(ret = ft_strcmp("bg", tab[0])))
./srcs/main/built.c:		fg_bg(g_jobs, tab, 0);
./srcs/main/built.c:	return (ret);
./srcs/main/built.c:}
Binary file ./srcs/main/options.o matches
Binary file ./srcs/main/built.o matches
Binary file ./srcs/main/ft_mishell.o matches
./srcs/main/ft_mishell.c:/* ************************************************************************** */
./srcs/main/ft_mishell.c:/*                                                                            */
./srcs/main/ft_mishell.c:/*                                                        :::      ::::::::   */
./srcs/main/ft_mishell.c:/*   ft_mishell.c                                       :+:      :+:    :+:   */
./srcs/main/ft_mishell.c:/*                                                    +:+ +:+         +:+     */
./srcs/main/ft_mishell.c:/*   By: aardjoun <marvin@42.fr>                    +#+  +:+       +#+        */
./srcs/main/ft_mishell.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/main/ft_mishell.c:/*   Created: 2014/02/14 15:59:27 by aardjoun          #+#    #+#             */
./srcs/main/ft_mishell.c:/*   Updated: 2014/03/23 14:34:36 by lsolofri         ###   ########.fr       */
./srcs/main/ft_mishell.c:/*                                                                            */
./srcs/main/ft_mishell.c:/* ************************************************************************** */
./srcs/main/ft_mishell.c:
./srcs/main/ft_mishell.c:#include "../../includes/msh.h"
./srcs/main/ft_mishell.c:
./srcs/main/ft_mishell.c:void	exec_cmd(char **tab)
./srcs/main/ft_mishell.c:{
./srcs/main/ft_mishell.c:	char	**exec;
./srcs/main/ft_mishell.c:	int		i;
./srcs/main/ft_mishell.c:	char	*result;
./srcs/main/ft_mishell.c:	char	**env;
./srcs/main/ft_mishell.c:
./srcs/main/ft_mishell.c:	i = 0;
./srcs/main/ft_mishell.c:	env = make_env_tab(g_env);
./srcs/main/ft_mishell.c:	exec = ft_strsplit(find_value_envir(g_env, "PATH"), ':');
./srcs/main/ft_mishell.c:	while (exec[i])
./srcs/main/ft_mishell.c:	{
./srcs/main/ft_mishell.c:		exec[i] = ft_strjoin(exec[i], "/");
./srcs/main/ft_mishell.c:		result = ft_strjoin(exec[i++], tab[0]);
./srcs/main/ft_mishell.c:		execve(result, tab, env);
./srcs/main/ft_mishell.c:	}
./srcs/main/ft_mishell.c:	execve(tab[0], tab, env);
./srcs/main/ft_mishell.c:	unknow_cmd(tab[0]);
./srcs/main/ft_mishell.c:	_exit(1);
./srcs/main/ft_mishell.c:}
./srcs/main/ft_mishell.c:
./srcs/main/ft_mishell.c:int		pre_exec(char *str)
./srcs/main/ft_mishell.c:{
./srcs/main/ft_mishell.c:	t_command	*tmp = NULL;
./srcs/main/ft_mishell.c:	pid_t		pid = 0;
./srcs/main/ft_mishell.c:	int			ret = 0;
./srcs/main/ft_mishell.c:
./srcs/main/ft_mishell.c:	if (str)
./srcs/main/ft_mishell.c:		tmp = quick_parse(str);
./srcs/main/ft_mishell.c:	while (tmp)
./srcs/main/ft_mishell.c:	{
./srcs/main/ft_mishell.c:		if (tmp->cmd[0])
./srcs/main/ft_mishell.c:		{
./srcs/main/ft_mishell.c:			tmp->cmd = is_alias(g_alias, tmp->cmd);
./srcs/main/ft_mishell.c:			if (detect_built(tmp->cmd))
./srcs/main/ft_mishell.c:			{
./srcs/main/ft_mishell.c:				if (!(pid = fork()))
./srcs/main/ft_mishell.c:				{
./srcs/main/ft_mishell.c:					signal(SIGTSTP, SIG_DFL);
./srcs/main/ft_mishell.c:					signal(SIGQUIT, SIG_DFL);
./srcs/main/ft_mishell.c:					check_operators(tmp->cmd);
./srcs/main/ft_mishell.c:					check_redirection(tmp->cmd);
./srcs/main/ft_mishell.c:					exec_cmd(tmp->cmd);
./srcs/main/ft_mishell.c:				}
./srcs/main/ft_mishell.c:				else
./srcs/main/ft_mishell.c:				{
./srcs/main/ft_mishell.c:					signal(SIGINT, interrupt_process);
./srcs/main/ft_mishell.c:					g_jobs = add_job(g_jobs, tmp->cmd[0], pid);
./srcs/main/ft_mishell.c:					waitpid(pid, &ret, WUNTRACED);
./srcs/main/ft_mishell.c:					check_return(ret, pid);
./srcs/main/ft_mishell.c:				}
./srcs/main/ft_mishell.c:			}
./srcs/main/ft_mishell.c:		}
./srcs/main/ft_mishell.c:		tmp = tmp->next;
./srcs/main/ft_mishell.c:	}
./srcs/main/ft_mishell.c:	return (ret);
./srcs/main/ft_mishell.c:}
./srcs/main/ft_mishell.c:
./srcs/main/ft_mishell.c:int		pre_exec_nofork(char *str)
./srcs/main/ft_mishell.c:{
./srcs/main/ft_mishell.c:	t_command	*tmp = NULL;
./srcs/main/ft_mishell.c:	pid_t		pid = 0;
./srcs/main/ft_mishell.c:
./srcs/main/ft_mishell.c:	tmp = quick_parse(str);
./srcs/main/ft_mishell.c:	while (tmp)
./srcs/main/ft_mishell.c:	{
./srcs/main/ft_mishell.c:		if (tmp->cmd[0])
./srcs/main/ft_mishell.c:		{
./srcs/main/ft_mishell.c:			tmp->cmd = is_alias(g_alias, tmp->cmd);
./srcs/main/ft_mishell.c:			if (detect_built(tmp->cmd))
./srcs/main/ft_mishell.c:			{
./srcs/main/ft_mishell.c:				check_operators(tmp->cmd);
./srcs/main/ft_mishell.c:				check_redirection(tmp->cmd);
./srcs/main/ft_mishell.c:				exec_cmd(tmp->cmd);
./srcs/main/ft_mishell.c:			}
./srcs/main/ft_mishell.c:		}
./srcs/main/ft_mishell.c:		tmp = tmp->next;
./srcs/main/ft_mishell.c:	}
./srcs/main/ft_mishell.c:	return (pid);
./srcs/main/ft_mishell.c:}
./srcs/main/ft_mishell.c:int		pre_exec_nowait(char *str)
./srcs/main/ft_mishell.c:{
./srcs/main/ft_mishell.c:	t_command	*tmp = NULL;
./srcs/main/ft_mishell.c:	pid_t		pid = 0;
./srcs/main/ft_mishell.c:	int			ret = 0;
./srcs/main/ft_mishell.c:
./srcs/main/ft_mishell.c:	if (str)
./srcs/main/ft_mishell.c:		tmp = quick_parse(str);
./srcs/main/ft_mishell.c:	while (tmp)
./srcs/main/ft_mishell.c:	{
./srcs/main/ft_mishell.c:		if (tmp->cmd[0])
./srcs/main/ft_mishell.c:		{
./srcs/main/ft_mishell.c:			tmp->cmd = is_alias(g_alias, tmp->cmd);
./srcs/main/ft_mishell.c:			if (detect_built(tmp->cmd))
./srcs/main/ft_mishell.c:			{
./srcs/main/ft_mishell.c:				if (!(pid = fork()))
./srcs/main/ft_mishell.c:				{
./srcs/main/ft_mishell.c:					check_operators(tmp->cmd);
./srcs/main/ft_mishell.c:					check_redirection(tmp->cmd);
./srcs/main/ft_mishell.c:					exec_cmd(tmp->cmd);
./srcs/main/ft_mishell.c:				}
./srcs/main/ft_mishell.c:			}
./srcs/main/ft_mishell.c:		}
./srcs/main/ft_mishell.c:		tmp = tmp->next;
./srcs/main/ft_mishell.c:	}
./srcs/main/ft_mishell.c:	wait(0);
./srcs/main/ft_mishell.c:	return (ret);
./srcs/main/ft_mishell.c:}
Binary file ./srcs/main/main.o matches
./srcs/main/options.c:#include "../../includes/msh.h"
./srcs/main/options.c:
./srcs/main/options.c:void		main_options(char **av, int *choice)
./srcs/main/options.c:{
./srcs/main/options.c:	int		i;
./srcs/main/options.c:
./srcs/main/options.c:	i = 1;
./srcs/main/options.c:	while (av[i])
./srcs/main/options.c:	{
./srcs/main/options.c:		if (!ft_strcmp("-nocolor", av[i]))
./srcs/main/options.c:			*choice = 1;
./srcs/main/options.c:		else
./srcs/main/options.c:		{
./srcs/main/options.c:			ft_putstr("Unknown option: ");
./srcs/main/options.c:			ft_putendl(av[i]);
./srcs/main/options.c:		}
./srcs/main/options.c:		++i;
./srcs/main/options.c:	}
./srcs/main/options.c:}
./srcs/main/main.c:/* ************************************************************************** */
./srcs/main/main.c:/*                                                                            */
./srcs/main/main.c:/*                                                        :::      ::::::::   */
./srcs/main/main.c:/*   main.c                                             :+:      :+:    :+:   */
./srcs/main/main.c:/*                                                    +:+ +:+         +:+     */
./srcs/main/main.c:/*   By: aardjoun <marvin@42.fr>                    +#+  +:+       +#+        */
./srcs/main/main.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/main/main.c:/*   Created: 2014/02/14 15:53:46 by aardjoun          #+#    #+#             */
./srcs/main/main.c:/*   Updated: 2014/03/23 14:34:46 by lsolofri         ###   ########.fr       */
./srcs/main/main.c:/*                                                                            */
./srcs/main/main.c:/* ************************************************************************** */
./srcs/main/main.c:
./srcs/main/main.c:#include "../../includes/msh.h"
./srcs/main/main.c:
./srcs/main/main.c:int			main(int ac, char **av, char **environ)
./srcs/main/main.c:{
./srcs/main/main.c:	char		*str;
./srcs/main/main.c:	int			choice;
./srcs/main/main.c:
./srcs/main/main.c:	choice = 0;
./srcs/main/main.c:	welcome();
./srcs/main/main.c:	new_env(environ);
./srcs/main/main.c:	load_conf_file();
./srcs/main/main.c:	g_env = ft_setenv(g_env, "MANPATH", get_man_path());
./srcs/main/main.c:	if (ac != 1)
./srcs/main/main.c:		main_options(av, &choice);
./srcs/main/main.c:	signal(SIGTSTP, SIG_IGN);
./srcs/main/main.c:	signal(SIGQUIT, SIG_IGN);
./srcs/main/main.c:	signal(SIGUSR1, SIG_IGN);
./srcs/main/main.c:	signal(SIGUSR2, SIG_IGN);
./srcs/main/main.c:	while (1)
./srcs/main/main.c:	{
./srcs/main/main.c:		prompt();
./srcs/main/main.c:		signal(SIGINT, interrupt_cmd);
./srcs/main/main.c:		str = take_cmd(choice);
./srcs/main/main.c:		pre_exec(str);
./srcs/main/main.c:		free(str);
./srcs/main/main.c:		str = NULL;
./srcs/main/main.c:	}
./srcs/main/main.c:	return (0);
./srcs/main/main.c:}
./srcs/signal/function_list.c:/* ************************************************************************** */
./srcs/signal/function_list.c:/*                                                                            */
./srcs/signal/function_list.c:/*                                                        :::      ::::::::   */
./srcs/signal/function_list.c:/*   function_list.c                                    :+:      :+:    :+:   */
./srcs/signal/function_list.c:/*                                                    +:+ +:+         +:+     */
./srcs/signal/function_list.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/signal/function_list.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/signal/function_list.c:/*   Created: 2014/03/16 14:18:25 by lsolofri          #+#    #+#             */
./srcs/signal/function_list.c:/*   Updated: 2014/03/21 13:43:21 by aardjoun         ###   ########.fr       */
./srcs/signal/function_list.c:/*                                                                            */
./srcs/signal/function_list.c:/* ************************************************************************** */
./srcs/signal/function_list.c:
./srcs/signal/function_list.c:#include "../../includes/msh.h"
./srcs/signal/function_list.c:
./srcs/signal/function_list.c:t_jobs		*add_job(t_jobs *list, char *name, int pid)
./srcs/signal/function_list.c:{
./srcs/signal/function_list.c:	t_jobs	*tmp;
./srcs/signal/function_list.c:	t_jobs	*tmp2;
./srcs/signal/function_list.c:
./srcs/signal/function_list.c:	tmp2 = list;
./srcs/signal/function_list.c:	tmp = (t_jobs *)ft_memalloc(sizeof(t_jobs));
./srcs/signal/function_list.c:	tmp->name = ft_strdup(name);
./srcs/signal/function_list.c:	tmp->pid = pid;
./srcs/signal/function_list.c:	tmp->job = 1;
./srcs/signal/function_list.c:	tmp->status = 0;
./srcs/signal/function_list.c:	tmp->next = NULL;
./srcs/signal/function_list.c:	if (list == NULL)
./srcs/signal/function_list.c:		return (tmp);
./srcs/signal/function_list.c:	while (tmp2->next != NULL)
./srcs/signal/function_list.c:		tmp2 = tmp2->next;
./srcs/signal/function_list.c:	tmp2->next = tmp;
./srcs/signal/function_list.c:	tmp->job = tmp2->job + 1;
./srcs/signal/function_list.c:	return (list);
./srcs/signal/function_list.c:}
./srcs/signal/function_list.c:
./srcs/signal/function_list.c:void		show_jobs(t_jobs *jobs)
./srcs/signal/function_list.c:{
./srcs/signal/function_list.c:	int		i;
./srcs/signal/function_list.c:
./srcs/signal/function_list.c:	i = 0;
./srcs/signal/function_list.c:	while (jobs)
./srcs/signal/function_list.c:	{
./srcs/signal/function_list.c:		ft_putstr("[");
./srcs/signal/function_list.c:		ft_putnbr(jobs->job);
./srcs/signal/function_list.c:		ft_putstr("] ");
./srcs/signal/function_list.c:		ft_putstr("[");
./srcs/signal/function_list.c:		ft_putnbr(jobs->pid);
./srcs/signal/function_list.c:		ft_putstr("]\t");
./srcs/signal/function_list.c:		ft_putstr("-\t");
./srcs/signal/function_list.c:		ft_putendl(jobs->name);
./srcs/signal/function_list.c:		jobs = jobs->next;
./srcs/signal/function_list.c:		++i;
./srcs/signal/function_list.c:	}
./srcs/signal/function_list.c:}
./srcs/signal/function_list.c:
./srcs/signal/function_list.c:char	*find_prog(t_jobs *jobs, int pid)
./srcs/signal/function_list.c:{
./srcs/signal/function_list.c:	while (jobs && jobs->pid != pid)
./srcs/signal/function_list.c:		jobs = jobs->next;
./srcs/signal/function_list.c:	if (jobs)
./srcs/signal/function_list.c:		return (jobs->name);
./srcs/signal/function_list.c:	return (NULL);
./srcs/signal/function_list.c:}
./srcs/signal/function_list.c:
./srcs/signal/function_list.c:t_jobs		*remove_jobs(t_jobs *jobs, int pid)
./srcs/signal/function_list.c:{
./srcs/signal/function_list.c:	t_jobs	*tmp;
./srcs/signal/function_list.c:
./srcs/signal/function_list.c:	if (!jobs)
./srcs/signal/function_list.c:		return (NULL);
./srcs/signal/function_list.c:	if (jobs->pid == pid)
./srcs/signal/function_list.c:	{
./srcs/signal/function_list.c:		tmp = jobs->next;
./srcs/signal/function_list.c:		free(jobs);
./srcs/signal/function_list.c:		tmp = remove_jobs(tmp, pid);
./srcs/signal/function_list.c:	}
./srcs/signal/function_list.c:	else
./srcs/signal/function_list.c:	{
./srcs/signal/function_list.c:		jobs->next = remove_jobs(jobs->next, pid);
./srcs/signal/function_list.c:		return (jobs);
./srcs/signal/function_list.c:	}
./srcs/signal/function_list.c:	return (NULL);
./srcs/signal/function_list.c:}
Binary file ./srcs/signal/show_stop.o matches
./srcs/signal/show_stop.c:/* ************************************************************************** */
./srcs/signal/show_stop.c:/*                                                                            */
./srcs/signal/show_stop.c:/*                                                        :::      ::::::::   */
./srcs/signal/show_stop.c:/*   show_stop.c                                        :+:      :+:    :+:   */
./srcs/signal/show_stop.c:/*                                                    +:+ +:+         +:+     */
./srcs/signal/show_stop.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/signal/show_stop.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/signal/show_stop.c:/*   Created: 2014/03/16 15:50:30 by lsolofri          #+#    #+#             */
./srcs/signal/show_stop.c:/*   Updated: 2014/03/17 20:05:37 by lsolofri         ###   ########.fr       */
./srcs/signal/show_stop.c:/*                                                                            */
./srcs/signal/show_stop.c:/* ************************************************************************** */
./srcs/signal/show_stop.c:
./srcs/signal/show_stop.c:#include "../../includes/msh.h"
./srcs/signal/show_stop.c:
./srcs/signal/show_stop.c:void	show_stop(int sig)
./srcs/signal/show_stop.c:{
./srcs/signal/show_stop.c:	if (sig == 4)
./srcs/signal/show_stop.c:		ft_putstr("Illegal instruction");
./srcs/signal/show_stop.c:	else if (sig == 3)
./srcs/signal/show_stop.c:		ft_putstr("Quit");
./srcs/signal/show_stop.c:	else if (sig == 6)
./srcs/signal/show_stop.c:		ft_putstr("Abort.");
./srcs/signal/show_stop.c:	else if (sig == 8)
./srcs/signal/show_stop.c:		ft_putstr("Floating point exception");
./srcs/signal/show_stop.c:	else if (sig == 9 || sig == 15)
./srcs/signal/show_stop.c:		ft_putstr("Kill");
./srcs/signal/show_stop.c:	else if (sig == 11)
./srcs/signal/show_stop.c:		ft_putstr("Segmentation fault");
./srcs/signal/show_stop.c:	else if (sig == 13)
./srcs/signal/show_stop.c:		ft_putstr("Broken pipe");
./srcs/signal/show_stop.c:	else if (sig == 10 || sig == 7)
./srcs/signal/show_stop.c:		ft_putstr("Bus error");
./srcs/signal/show_stop.c:}
Binary file ./srcs/signal/signal.o matches
Binary file ./srcs/signal/function_list.o matches
./srcs/signal/signal.c:/* ************************************************************************** */
./srcs/signal/signal.c:/*                                                                            */
./srcs/signal/signal.c:/*                                                        :::      ::::::::   */
./srcs/signal/signal.c:/*   signal.c                                           :+:      :+:    :+:   */
./srcs/signal/signal.c:/*                                                    +:+ +:+         +:+     */
./srcs/signal/signal.c:/*   By: aardjoun <aardjoun@student.42.fr>          +#+  +:+       +#+        */
./srcs/signal/signal.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/signal/signal.c:/*   Created: 2014/02/28 16:47:41 by aardjoun          #+#    #+#             */
./srcs/signal/signal.c:/*   Updated: 2014/03/23 16:43:00 by lsolofri         ###   ########.fr       */
./srcs/signal/signal.c:/*   Updated: 2014/03/17 15:25:11 by aardjoun         ###   ########.fr       */
./srcs/signal/signal.c:/*                                                                            */
./srcs/signal/signal.c:/* ************************************************************************** */
./srcs/signal/signal.c:
./srcs/signal/signal.c:#include "../../includes/msh.h"
./srcs/signal/signal.c:
./srcs/signal/signal.c:void		interrupt_process(__attribute__((unused))int s)
./srcs/signal/signal.c:{
./srcs/signal/signal.c:	ft_putendl("");
./srcs/signal/signal.c:}
./srcs/signal/signal.c:
./srcs/signal/signal.c:void		interrupt_cmd(__attribute__((unused))int s)
./srcs/signal/signal.c:{
./srcs/signal/signal.c:	ft_putendl("");
./srcs/signal/signal.c://	prompt();
./srcs/signal/signal.c:}
./srcs/signal/signal.c:
./srcs/signal/signal.c:void		show_signal(int pid, int sig)
./srcs/signal/signal.c:{
./srcs/signal/signal.c:	ft_putstr("msh: ");
./srcs/signal/signal.c:	show_stop(sig);
./srcs/signal/signal.c:	ft_putstr("\t");
./srcs/signal/signal.c:	ft_putendl(find_prog(g_jobs, pid));
./srcs/signal/signal.c:}
./srcs/signal/signal.c:
./srcs/signal/signal.c:void		show_interrupt(int pid)
./srcs/signal/signal.c:{
./srcs/signal/signal.c:	ft_putstr("msh: suspended\t");
./srcs/signal/signal.c:	ft_putendl(find_prog(g_jobs, pid));
./srcs/signal/signal.c:}
./srcs/signal/signal.c:
./srcs/signal/signal.c:void	check_return(int ret, int pid)
./srcs/signal/signal.c:{
./srcs/signal/signal.c:	int		sig;
./srcs/signal/signal.c:
./srcs/signal/signal.c:	sig = WTERMSIG(ret);
./srcs/signal/signal.c:	g_var = del_var(g_var, "?");
./srcs/signal/signal.c:	g_var = add_var(g_var, "?", ft_itoa(ret));
./srcs/signal/signal.c:	if (WIFEXITED(ret))
./srcs/signal/signal.c:		g_jobs = remove_jobs(g_jobs, pid);
./srcs/signal/signal.c:	else if (WIFSIGNALED(ret))
./srcs/signal/signal.c:	{
./srcs/signal/signal.c:		if (sig == 4 || sig == 3 || sig == 6 || sig == 8 || sig == 9 || 
./srcs/signal/signal.c:				sig == 15 || sig == 11 || sig == 13 || sig == 10 || sig == 7)
./srcs/signal/signal.c:			show_signal(pid, sig);
./srcs/signal/signal.c:		g_jobs = remove_jobs(g_jobs, pid);
./srcs/signal/signal.c:	}
./srcs/signal/signal.c:	else if (WIFSTOPPED(ret))
./srcs/signal/signal.c:	{
./srcs/signal/signal.c:		if (sig == 127 || sig == 18)
./srcs/signal/signal.c:			show_interrupt(pid);
./srcs/signal/signal.c:	}
./srcs/signal/signal.c:}
Binary file ./srcs/errors/cd_error.o matches
./srcs/errors/error.c:/* ************************************************************************** */
./srcs/errors/error.c:/*                                                                            */
./srcs/errors/error.c:/*                                                        :::      ::::::::   */
./srcs/errors/error.c:/*   error.c                                            :+:      :+:    :+:   */
./srcs/errors/error.c:/*                                                    +:+ +:+         +:+     */
./srcs/errors/error.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/errors/error.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/errors/error.c:/*   Created: 2014/02/11 15:02:39 by lsolofri          #+#    #+#             */
./srcs/errors/error.c:/*   Updated: 2014/03/21 12:02:13 by aardjoun         ###   ########.fr       */
./srcs/errors/error.c:/*                                                                            */
./srcs/errors/error.c:/* ************************************************************************** */
./srcs/errors/error.c:
./srcs/errors/error.c:#include "../../includes/msh.h"
./srcs/errors/error.c:
./srcs/errors/error.c:void	show_error_exit(char *str)
./srcs/errors/error.c:{
./srcs/errors/error.c:	write(2, "Error: ", 8);
./srcs/errors/error.c:	write(2, str, ft_strlen(str));
./srcs/errors/error.c:	write(2, "\n", 2);
./srcs/errors/error.c:	exit(0);
./srcs/errors/error.c:}
./srcs/errors/error.c:
./srcs/errors/error.c:void	show_error(char *str)
./srcs/errors/error.c:{
./srcs/errors/error.c:	write(2, "Error: ", 8);
./srcs/errors/error.c:	write(2, str, ft_strlen(str));
./srcs/errors/error.c:	write(2, "\n", 1);
./srcs/errors/error.c:}
./srcs/errors/error.c:
./srcs/errors/error.c:void	err_no_file(char *str)
./srcs/errors/error.c:{
./srcs/errors/error.c:	write(2, "msh: No such file or directory ", 32);
./srcs/errors/error.c:	write(2, str, ft_strlen(str));
./srcs/errors/error.c:	write(2, "\n", 1);
./srcs/errors/error.c:}
./srcs/errors/error.c:
./srcs/errors/error.c:void	exit_error(char **tab)
./srcs/errors/error.c:{
./srcs/errors/error.c:	ft_putstr(tab[0]);
./srcs/errors/error.c:	ft_putstr(": Argument '");
./srcs/errors/error.c:	ft_putstr(tab[1]);
./srcs/errors/error.c:	ft_putendl("' must be an integer");
./srcs/errors/error.c:}
./srcs/errors/error.c:
./srcs/errors/error.c:void	unknow_cmd(char *str)
./srcs/errors/error.c:{
./srcs/errors/error.c:	ft_putstr("msh: Unknown command '");
./srcs/errors/error.c:	ft_putstr(str);
./srcs/errors/error.c:	ft_putendl("'");
./srcs/errors/error.c:}
./srcs/errors/error.c:
./srcs/errors/error.c:void	pid_error(char *tab)
./srcs/errors/error.c:{
./srcs/errors/error.c:	ft_putstr("msh: '");
./srcs/errors/error.c:	ft_putstr(tab);
./srcs/errors/error.c:	ft_putendl("' is not a valid pid");
./srcs/errors/error.c:}
./srcs/errors/error.c:
./srcs/errors/error.c:void	job_error(int k)
./srcs/errors/error.c:{
./srcs/errors/error.c:	if (k == 1)
./srcs/errors/error.c:		ft_putstr("fg");
./srcs/errors/error.c:	else
./srcs/errors/error.c:		ft_putstr("bg");
./srcs/errors/error.c:	ft_putendl(": no current job");
./srcs/errors/error.c:}
./srcs/errors/cd_error.c:/* ************************************************************************** */
./srcs/errors/cd_error.c:/*                                                                            */
./srcs/errors/cd_error.c:/*                                                        :::      ::::::::   */
./srcs/errors/cd_error.c:/*   cd_error.c                                         :+:      :+:    :+:   */
./srcs/errors/cd_error.c:/*                                                    +:+ +:+         +:+     */
./srcs/errors/cd_error.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/errors/cd_error.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/errors/cd_error.c:/*   Created: 2014/02/25 03:48:18 by lsolofri          #+#    #+#             */
./srcs/errors/cd_error.c:/*   Updated: 2014/02/25 03:53:25 by lsolofri         ###   ########.fr       */
./srcs/errors/cd_error.c:/*                                                                            */
./srcs/errors/cd_error.c:/* ************************************************************************** */
./srcs/errors/cd_error.c:
./srcs/errors/cd_error.c:#include "../../includes/msh.h"
./srcs/errors/cd_error.c:
./srcs/errors/cd_error.c:int		cd_error(char *str)
./srcs/errors/cd_error.c:{
./srcs/errors/cd_error.c:	ft_putstr("cd: ");
./srcs/errors/cd_error.c:	ft_putstr(str);
./srcs/errors/cd_error.c:	if (access(str, F_OK) != -1)
./srcs/errors/cd_error.c:		ft_putendl(": Permission denied.");
./srcs/errors/cd_error.c:	else
./srcs/errors/cd_error.c:		ft_putendl(": Not such file or directory.");
./srcs/errors/cd_error.c:	return (-1);
./srcs/errors/cd_error.c:}
Binary file ./srcs/errors/error.o matches
./srcs/functions/ft_strnew.c:/* ************************************************************************** */
./srcs/functions/ft_strnew.c:/*                                                                            */
./srcs/functions/ft_strnew.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_strnew.c:/*   ft_strnew.c                                        :+:      :+:    :+:   */
./srcs/functions/ft_strnew.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_strnew.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_strnew.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_strnew.c:/*   Created: 2014/03/22 11:45:02 by rkharif           #+#    #+#             */
./srcs/functions/ft_strnew.c:/*   Updated: 2014/03/22 11:45:14 by rkharif          ###   ########.fr       */
./srcs/functions/ft_strnew.c:/*                                                                            */
./srcs/functions/ft_strnew.c:/* ************************************************************************** */
./srcs/functions/ft_strnew.c:
./srcs/functions/ft_strnew.c:#include <stdlib.h>
./srcs/functions/ft_strnew.c:#include "../../includes/msh.h"
./srcs/functions/ft_strnew.c:
./srcs/functions/ft_strnew.c:char	*ft_strnew(size_t size)
./srcs/functions/ft_strnew.c:{
./srcs/functions/ft_strnew.c:	char	*new;
./srcs/functions/ft_strnew.c:
./srcs/functions/ft_strnew.c:	if ((new = (char *) ft_memalloc(sizeof(char) * size)) == NULL)
./srcs/functions/ft_strnew.c:		return (NULL);
./srcs/functions/ft_strnew.c:	return (new);
./srcs/functions/ft_strnew.c:}
./srcs/functions/ft_strjoin.c:/* ************************************************************************** */
./srcs/functions/ft_strjoin.c:/*                                                                            */
./srcs/functions/ft_strjoin.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_strjoin.c:/*   ft_strjoin.c                                       :+:      :+:    :+:   */
./srcs/functions/ft_strjoin.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_strjoin.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_strjoin.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_strjoin.c:/*   Created: 2014/03/22 12:04:37 by rkharif           #+#    #+#             */
./srcs/functions/ft_strjoin.c:/*   Updated: 2014/03/22 12:04:38 by rkharif          ###   ########.fr       */
./srcs/functions/ft_strjoin.c:/*                                                                            */
./srcs/functions/ft_strjoin.c:/* ************************************************************************** */
./srcs/functions/ft_strjoin.c:
./srcs/functions/ft_strjoin.c:#include "../../includes/msh.h"
./srcs/functions/ft_strjoin.c:
./srcs/functions/ft_strjoin.c:char	*ft_strjoin(char const *s1, char const *s2)
./srcs/functions/ft_strjoin.c:{
./srcs/functions/ft_strjoin.c:	char	*join;
./srcs/functions/ft_strjoin.c:	size_t	len_s1;
./srcs/functions/ft_strjoin.c:	size_t	len_s2;
./srcs/functions/ft_strjoin.c:
./srcs/functions/ft_strjoin.c:	len_s1 = ft_strlen((char *)s1);
./srcs/functions/ft_strjoin.c:	len_s2 = ft_strlen((char *)s2);
./srcs/functions/ft_strjoin.c:	join = ft_strnew(len_s1 + len_s2 + 1);
./srcs/functions/ft_strjoin.c:	if (join == NULL)
./srcs/functions/ft_strjoin.c:		return (NULL);
./srcs/functions/ft_strjoin.c:	join = (char *) ft_memcpy(join, s1, len_s1);
./srcs/functions/ft_strjoin.c:	ft_memcpy(join + len_s1, s2, len_s2);
./srcs/functions/ft_strjoin.c:	return (join);
./srcs/functions/ft_strjoin.c:}
Binary file ./srcs/functions/ft_strlen.o matches
Binary file ./srcs/functions/ft_atoi.o matches
./srcs/functions/ft_cmd_result.c:/* ************************************************************************** */
./srcs/functions/ft_cmd_result.c:/*                                                                            */
./srcs/functions/ft_cmd_result.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_cmd_result.c:/*   ft_cmd_result.c                                    :+:      :+:    :+:   */
./srcs/functions/ft_cmd_result.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_cmd_result.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_cmd_result.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_cmd_result.c:/*   Created: 2014/02/25 03:27:59 by lsolofri          #+#    #+#             */
./srcs/functions/ft_cmd_result.c:/*   Updated: 2014/03/22 13:53:22 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_cmd_result.c:/*                                                                            */
./srcs/functions/ft_cmd_result.c:/* ************************************************************************** */
./srcs/functions/ft_cmd_result.c:
./srcs/functions/ft_cmd_result.c:#include "../../includes/msh.h"
./srcs/functions/ft_cmd_result.c:
./srcs/functions/ft_cmd_result.c:char	*result_cmd(char *cmd)
./srcs/functions/ft_cmd_result.c:{
./srcs/functions/ft_cmd_result.c:	char    *result;
./srcs/functions/ft_cmd_result.c:	int     fd[2];
./srcs/functions/ft_cmd_result.c:	int     ret;
./srcs/functions/ft_cmd_result.c:	char	*buffer;
./srcs/functions/ft_cmd_result.c:	int		i;
./srcs/functions/ft_cmd_result.c:	int		pid;
./srcs/functions/ft_cmd_result.c:
./srcs/functions/ft_cmd_result.c:	i = 0;
./srcs/functions/ft_cmd_result.c:	buffer = NULL;
./srcs/functions/ft_cmd_result.c:	if (pipe(fd) == -1)
./srcs/functions/ft_cmd_result.c:		return (NULL);
./srcs/functions/ft_cmd_result.c:	result = (char *)ft_memalloc(sizeof(char) * 1024);
./srcs/functions/ft_cmd_result.c:	if (!result)
./srcs/functions/ft_cmd_result.c:		return (NULL);
./srcs/functions/ft_cmd_result.c:	if (!(pid = fork()))
./srcs/functions/ft_cmd_result.c:	{
./srcs/functions/ft_cmd_result.c:		if (close(fd[0]) == -1)
./srcs/functions/ft_cmd_result.c:			return (NULL);
./srcs/functions/ft_cmd_result.c:		if (dup2(fd[1], 1) == -1)
./srcs/functions/ft_cmd_result.c:			return (NULL);
./srcs/functions/ft_cmd_result.c:		dup2(fd[1], 2);
./srcs/functions/ft_cmd_result.c:		if (close(fd[1]) == -1)
./srcs/functions/ft_cmd_result.c:			return (NULL);
./srcs/functions/ft_cmd_result.c:		if (pre_exec_nofork(cmd))
./srcs/functions/ft_cmd_result.c:			return (NULL);
./srcs/functions/ft_cmd_result.c:	}
./srcs/functions/ft_cmd_result.c:	else
./srcs/functions/ft_cmd_result.c:	{
./srcs/functions/ft_cmd_result.c:		waitpid(pid, &ret, WUNTRACED);
./srcs/functions/ft_cmd_result.c:		if (close(fd[1]) == -1)
./srcs/functions/ft_cmd_result.c:			return (NULL);
./srcs/functions/ft_cmd_result.c:		while ((ret = read(fd[0], result, 1024)) != 0)
./srcs/functions/ft_cmd_result.c:		{
./srcs/functions/ft_cmd_result.c:			result = ft_strsub(result, 0, ret);
./srcs/functions/ft_cmd_result.c:			if (i++ == 0)
./srcs/functions/ft_cmd_result.c:				buffer = ft_strdup(result);
./srcs/functions/ft_cmd_result.c:			else
./srcs/functions/ft_cmd_result.c:				buffer = ft_strjoin(buffer, result);
./srcs/functions/ft_cmd_result.c:		}
./srcs/functions/ft_cmd_result.c:	}
./srcs/functions/ft_cmd_result.c:	buffer[ft_strlen(buffer) - 1] = '\0';
./srcs/functions/ft_cmd_result.c:	return (buffer);
./srcs/functions/ft_cmd_result.c:}
Binary file ./srcs/functions/ft_strsplit.o matches
Binary file ./srcs/functions/ft_isprint.o matches
./srcs/functions/ft_strlen.c:/* ************************************************************************** */
./srcs/functions/ft_strlen.c:/*                                                                            */
./srcs/functions/ft_strlen.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_strlen.c:/*   ft_strlen.c                                        :+:      :+:    :+:   */
./srcs/functions/ft_strlen.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_strlen.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_strlen.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_strlen.c:/*   Created: 2014/02/11 15:14:35 by lsolofri          #+#    #+#             */
./srcs/functions/ft_strlen.c:/*   Updated: 2014/02/26 23:40:16 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_strlen.c:/*                                                                            */
./srcs/functions/ft_strlen.c:/* ************************************************************************** */
./srcs/functions/ft_strlen.c:
./srcs/functions/ft_strlen.c:int		ft_strlen(char *s)
./srcs/functions/ft_strlen.c:{
./srcs/functions/ft_strlen.c:	int		i;
./srcs/functions/ft_strlen.c:
./srcs/functions/ft_strlen.c:	i = 0;
./srcs/functions/ft_strlen.c:	if (!s)
./srcs/functions/ft_strlen.c:		return (i);
./srcs/functions/ft_strlen.c:	while (s[i] != '\0')
./srcs/functions/ft_strlen.c:		++i;
./srcs/functions/ft_strlen.c:	return (i);
./srcs/functions/ft_strlen.c:}
./srcs/functions/ft_free_tab.c:/* ************************************************************************** */
./srcs/functions/ft_free_tab.c:/*                                                                            */
./srcs/functions/ft_free_tab.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_free_tab.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_free_tab.c:/*   By: aardjoun <marvin@42.fr>                    +#+  +:+       +#+        */
./srcs/functions/ft_free_tab.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_free_tab.c:/*   Created: 2014/02/11 17:01:09 by aardjoun          #+#    #+#             */
./srcs/functions/ft_free_tab.c:/*   Updated: 2014/02/12 16:02:18 by aardjoun         ###   ########.fr       */
./srcs/functions/ft_free_tab.c:/*                                                                            */
./srcs/functions/ft_free_tab.c:/* ************************************************************************** */
./srcs/functions/ft_free_tab.c:
./srcs/functions/ft_free_tab.c:#include "../../includes/msh.h"
./srcs/functions/ft_free_tab.c:
./srcs/functions/ft_free_tab.c:{
./srcs/functions/ft_free_tab.c:	int		i;
./srcs/functions/ft_free_tab.c:
./srcs/functions/ft_free_tab.c:	i = 0;
./srcs/functions/ft_free_tab.c:	while (tab[i])
./srcs/functions/ft_free_tab.c:	{
./srcs/functions/ft_free_tab.c:		free(tab[i]);
./srcs/functions/ft_free_tab.c:		tab[i] = NULL;
./srcs/functions/ft_free_tab.c:		i++;
./srcs/functions/ft_free_tab.c:	}
./srcs/functions/ft_free_tab.c:	free(tab);
./srcs/functions/ft_free_tab.c:}
Binary file ./srcs/functions/get_next_line.o matches
./srcs/functions/ft_putstr.c:/* ************************************************************************** */
./srcs/functions/ft_putstr.c:/*                                                                            */
./srcs/functions/ft_putstr.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_putstr.c:/*   ft_putstr.c                                        :+:      :+:    :+:   */
./srcs/functions/ft_putstr.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_putstr.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_putstr.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_putstr.c:/*   Created: 2013/11/19 11:03:26 by lsolofri          #+#    #+#             */
./srcs/functions/ft_putstr.c:/*   Updated: 2013/12/27 11:40:30 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_putstr.c:/*                                                                            */
./srcs/functions/ft_putstr.c:/* ************************************************************************** */
./srcs/functions/ft_putstr.c:
./srcs/functions/ft_putstr.c:#include <unistd.h>
./srcs/functions/ft_putstr.c:
./srcs/functions/ft_putstr.c:size_t	ft_strlen(const char *s);
./srcs/functions/ft_putstr.c:
./srcs/functions/ft_putstr.c:void	ft_putstr(char const *str)
./srcs/functions/ft_putstr.c:{
./srcs/functions/ft_putstr.c:	write(1, str, ft_strlen(str));
./srcs/functions/ft_putstr.c:}
Binary file ./srcs/functions/ft_insert_tab.o matches
Binary file ./srcs/functions/ft_strsub.o matches
Binary file ./srcs/functions/ft_isdigit.o matches
./srcs/functions/ft_strsub.c:/* ************************************************************************** */
./srcs/functions/ft_strsub.c:/*                                                                            */
./srcs/functions/ft_strsub.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_strsub.c:/*   ft_strsub.c                                        :+:      :+:    :+:   */
./srcs/functions/ft_strsub.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_strsub.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_strsub.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_strsub.c:/*   Created: 2014/03/22 12:05:17 by rkharif           #+#    #+#             */
./srcs/functions/ft_strsub.c:/*   Updated: 2014/03/22 12:05:23 by rkharif          ###   ########.fr       */
./srcs/functions/ft_strsub.c:/*                                                                            */
./srcs/functions/ft_strsub.c:/* ************************************************************************** */
./srcs/functions/ft_strsub.c:
./srcs/functions/ft_strsub.c:#include "../../includes/msh.h"
./srcs/functions/ft_strsub.c:
./srcs/functions/ft_strsub.c:char	*ft_strsub(char const *s, t_ui start, size_t len)
./srcs/functions/ft_strsub.c:{
./srcs/functions/ft_strsub.c:	char	*sub;
./srcs/functions/ft_strsub.c:	t_ui	i;
./srcs/functions/ft_strsub.c:
./srcs/functions/ft_strsub.c:	i = 0;
./srcs/functions/ft_strsub.c:	sub = ft_strnew(len + 1);
./srcs/functions/ft_strsub.c:	if (sub == NULL)
./srcs/functions/ft_strsub.c:		return (NULL);
./srcs/functions/ft_strsub.c:	s += start;
./srcs/functions/ft_strsub.c:	while (s[i] && len != 0)
./srcs/functions/ft_strsub.c:	{
./srcs/functions/ft_strsub.c:		sub[i] = s[i];
./srcs/functions/ft_strsub.c:		i++;
./srcs/functions/ft_strsub.c:		len--;
./srcs/functions/ft_strsub.c:	}
./srcs/functions/ft_strsub.c:	return (sub);
./srcs/functions/ft_strsub.c:}
./srcs/functions/ft_memcpy.c:/* ************************************************************************** */
./srcs/functions/ft_memcpy.c:/*                                                                            */
./srcs/functions/ft_memcpy.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_memcpy.c:/*   ft_memcpy.c                                        :+:      :+:    :+:   */
./srcs/functions/ft_memcpy.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_memcpy.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_memcpy.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_memcpy.c:/*   Created: 2014/03/22 12:04:20 by rkharif           #+#    #+#             */
./srcs/functions/ft_memcpy.c:/*   Updated: 2014/03/22 12:04:23 by rkharif          ###   ########.fr       */
./srcs/functions/ft_memcpy.c:/*                                                                            */
./srcs/functions/ft_memcpy.c:/* ************************************************************************** */
./srcs/functions/ft_memcpy.c:
./srcs/functions/ft_memcpy.c:#include <string.h>
./srcs/functions/ft_memcpy.c:
./srcs/functions/ft_memcpy.c:void	*ft_memcpy(void *s1, const void *s2, size_t n)
./srcs/functions/ft_memcpy.c:{
./srcs/functions/ft_memcpy.c:	char	*str1;
./srcs/functions/ft_memcpy.c:	char	*str2;
./srcs/functions/ft_memcpy.c:	int		i;
./srcs/functions/ft_memcpy.c:
./srcs/functions/ft_memcpy.c:	str1 = (char *) s1;
./srcs/functions/ft_memcpy.c:	str2 = (char *) s2;
./srcs/functions/ft_memcpy.c:	i = 0;
./srcs/functions/ft_memcpy.c:	while (n != 0)
./srcs/functions/ft_memcpy.c:	{
./srcs/functions/ft_memcpy.c:		str1[i] = str2[i];
./srcs/functions/ft_memcpy.c:		n--;
./srcs/functions/ft_memcpy.c:		i++;
./srcs/functions/ft_memcpy.c:	}
./srcs/functions/ft_memcpy.c:	return (str1);
./srcs/functions/ft_memcpy.c:}
Binary file ./srcs/functions/ft_cmd_result.o matches
Binary file ./srcs/functions/ft_memalloc.o matches
./srcs/functions/ft_isdigit.c:/* ************************************************************************** */
./srcs/functions/ft_isdigit.c:/*                                                                            */
./srcs/functions/ft_isdigit.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_isdigit.c:/*   ft_isdigit.c                                       :+:      :+:    :+:   */
./srcs/functions/ft_isdigit.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_isdigit.c:/*   By: aardjoun <aardjoun@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_isdigit.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_isdigit.c:/*   Created: 2013/11/23 15:52:03 by aardjoun          #+#    #+#             */
./srcs/functions/ft_isdigit.c:/*   Updated: 2014/02/18 14:36:10 by aardjoun         ###   ########.fr       */
./srcs/functions/ft_isdigit.c:/*                                                                            */
./srcs/functions/ft_isdigit.c:/* ************************************************************************** */
./srcs/functions/ft_isdigit.c:
./srcs/functions/ft_isdigit.c:#include "../../includes/msh.h"
./srcs/functions/ft_isdigit.c:
./srcs/functions/ft_isdigit.c:int		ft_isdigit(char c)
./srcs/functions/ft_isdigit.c:{
./srcs/functions/ft_isdigit.c:	return ((c >= '0' && c <= '9') ? 1 : 0);
./srcs/functions/ft_isdigit.c:}
Binary file ./srcs/functions/ft_tablen.o matches
Binary file ./srcs/functions/ft_putchar.o matches
./srcs/functions/get_next_line.c:/* ************************************************************************** */
./srcs/functions/get_next_line.c:/*                                                                            */
./srcs/functions/get_next_line.c:/*                                                        :::      ::::::::   */
./srcs/functions/get_next_line.c:/*   get_next_line.c                                    :+:      :+:    :+:   */
./srcs/functions/get_next_line.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/get_next_line.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/get_next_line.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/get_next_line.c:/*   Created: 2014/02/14 11:05:41 by lsolofri          #+#    #+#             */
./srcs/functions/get_next_line.c:/*   Updated: 2014/03/22 02:36:19 by rkharif          ###   ########.fr       */
./srcs/functions/get_next_line.c:/*                                                                            */
./srcs/functions/get_next_line.c:/* ************************************************************************** */
./srcs/functions/get_next_line.c:
./srcs/functions/get_next_line.c:#include "../../includes/msh.h"
./srcs/functions/get_next_line.c:
./srcs/functions/get_next_line.c:int		read_get_next_line(int fd, int *i, int *nbread, char *buff)
./srcs/functions/get_next_line.c:{
./srcs/functions/get_next_line.c:	if (*i == *nbread)
./srcs/functions/get_next_line.c:	{
./srcs/functions/get_next_line.c:		*i = 0;
./srcs/functions/get_next_line.c:		if (!(*nbread = read(fd, buff, GNL_LEN)))
./srcs/functions/get_next_line.c:			return (1);
./srcs/functions/get_next_line.c:	}
./srcs/functions/get_next_line.c:	return (0);
./srcs/functions/get_next_line.c:}
./srcs/functions/get_next_line.c:
./srcs/functions/get_next_line.c:int		eol_get_next_line(int fd, int *i, int *nbread, char *buff)
./srcs/functions/get_next_line.c:{
./srcs/functions/get_next_line.c:	while (buff[*i] && buff[*i] != '\n')
./srcs/functions/get_next_line.c:	{
./srcs/functions/get_next_line.c:		(*i)++;
./srcs/functions/get_next_line.c:		if (read_get_next_line(fd, i, nbread, buff))
./srcs/functions/get_next_line.c:			return (1);
./srcs/functions/get_next_line.c:	}
./srcs/functions/get_next_line.c:	return (0);
./srcs/functions/get_next_line.c:}
./srcs/functions/get_next_line.c:
./srcs/functions/get_next_line.c:char	*get_next_line(int fd)
./srcs/functions/get_next_line.c:{
./srcs/functions/get_next_line.c:	static char		buff[GNL_LEN];
./srcs/functions/get_next_line.c:	static int		i = 0;
./srcs/functions/get_next_line.c:	static int		nbread = 0;
./srcs/functions/get_next_line.c:	int				n;
./srcs/functions/get_next_line.c:	char			*str;
./srcs/functions/get_next_line.c:
./srcs/functions/get_next_line.c:	n = 0;
./srcs/functions/get_next_line.c:	str = NULL;
./srcs/functions/get_next_line.c:	if (read_get_next_line(fd, &i, &nbread, buff))
./srcs/functions/get_next_line.c:		return (0);
./srcs/functions/get_next_line.c:	str = (char *)ft_memalloc(sizeof(char) * GNL_LEN);
./srcs/functions/get_next_line.c:	while (buff[i] && buff[i] != '\n' && n < GNL_LEN)
./srcs/functions/get_next_line.c:	{
./srcs/functions/get_next_line.c:		str[n++] = buff[i++];
./srcs/functions/get_next_line.c:		if (read_get_next_line(fd, &i, &nbread, buff))
./srcs/functions/get_next_line.c:			return (str);
./srcs/functions/get_next_line.c:	}
./srcs/functions/get_next_line.c:	if (n == GNL_LEN)
./srcs/functions/get_next_line.c:		if (eol_get_next_line(fd, &i, &nbread, buff))
./srcs/functions/get_next_line.c:			return (str);
./srcs/functions/get_next_line.c:	i++;
./srcs/functions/get_next_line.c:	return (str);
./srcs/functions/get_next_line.c:}
./srcs/functions/ft_tablen.c:/* ************************************************************************** */
./srcs/functions/ft_tablen.c:/*                                                                            */
./srcs/functions/ft_tablen.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_tablen.c:/*   ft_tablen.c                                        :+:      :+:    :+:   */
./srcs/functions/ft_tablen.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_tablen.c:/*   By: aardjoun <marvin@42.fr>                    +#+  +:+       +#+        */
./srcs/functions/ft_tablen.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_tablen.c:/*   Created: 2014/02/12 16:49:50 by aardjoun          #+#    #+#             */
./srcs/functions/ft_tablen.c:/*   Updated: 2014/02/12 16:50:57 by aardjoun         ###   ########.fr       */
./srcs/functions/ft_tablen.c:/*                                                                            */
./srcs/functions/ft_tablen.c:/* ************************************************************************** */
./srcs/functions/ft_tablen.c:
./srcs/functions/ft_tablen.c:int		ft_tablen(char **tab)
./srcs/functions/ft_tablen.c:{
./srcs/functions/ft_tablen.c:	int		i;
./srcs/functions/ft_tablen.c:
./srcs/functions/ft_tablen.c:	i = 0;
./srcs/functions/ft_tablen.c:	while (tab[i])
./srcs/functions/ft_tablen.c:		i++;
./srcs/functions/ft_tablen.c:	return (i);
./srcs/functions/ft_tablen.c:}
Binary file ./srcs/functions/ft_gchelper.o matches
./srcs/functions/ft_bzero.c:/* ************************************************************************** */
./srcs/functions/ft_bzero.c:/*                                                                            */
./srcs/functions/ft_bzero.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_bzero.c:/*   ft_bzero.c                                         :+:      :+:    :+:   */
./srcs/functions/ft_bzero.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_bzero.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_bzero.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_bzero.c:/*   Created: 2014/03/22 11:47:46 by rkharif           #+#    #+#             */
./srcs/functions/ft_bzero.c:/*   Updated: 2014/03/22 11:47:49 by rkharif          ###   ########.fr       */
./srcs/functions/ft_bzero.c:/*                                                                            */
./srcs/functions/ft_bzero.c:/* ************************************************************************** */
./srcs/functions/ft_bzero.c:
./srcs/functions/ft_bzero.c:#include <string.h>
./srcs/functions/ft_bzero.c:
./srcs/functions/ft_bzero.c:void	ft_bzero(void *s, size_t n)
./srcs/functions/ft_bzero.c:{
./srcs/functions/ft_bzero.c:	char	*dest;
./srcs/functions/ft_bzero.c:	int		i;
./srcs/functions/ft_bzero.c:
./srcs/functions/ft_bzero.c:	dest = (char *) s;
./srcs/functions/ft_bzero.c:	i = 0;
./srcs/functions/ft_bzero.c:	while (n != 0)
./srcs/functions/ft_bzero.c:	{
./srcs/functions/ft_bzero.c:		dest[i] = 0;
./srcs/functions/ft_bzero.c:		i++;
./srcs/functions/ft_bzero.c:		n--;
./srcs/functions/ft_bzero.c:	}
./srcs/functions/ft_bzero.c:}
./srcs/functions/ft_itoa.c:/* ************************************************************************** */
./srcs/functions/ft_itoa.c:/*                                                                            */
./srcs/functions/ft_itoa.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_itoa.c:/*   ft_itoa.c                                          :+:      :+:    :+:   */
./srcs/functions/ft_itoa.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_itoa.c:/*   By: rgary <rgary@student.42.fr>                +#+  +:+       +#+        */
./srcs/functions/ft_itoa.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_itoa.c:/*   Created: 2013/12/08 09:58:29 by rgary             #+#    #+#             */
./srcs/functions/ft_itoa.c:/*   Updated: 2014/03/23 14:36:22 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_itoa.c:/*                                                                            */
./srcs/functions/ft_itoa.c:/* ************************************************************************** */
./srcs/functions/ft_itoa.c:#include "../../includes/msh.h"
./srcs/functions/ft_itoa.c:
./srcs/functions/ft_itoa.c:char	*ft_uitoa(unsigned long n)
./srcs/functions/ft_itoa.c:{
./srcs/functions/ft_itoa.c:	char	*p;
./srcs/functions/ft_itoa.c:
./srcs/functions/ft_itoa.c:	p = (char *)ft_memalloc(sizeof(char) * 22);
./srcs/functions/ft_itoa.c:	p = p + 21;
./srcs/functions/ft_itoa.c:	if (n == 0)
./srcs/functions/ft_itoa.c:		*p = n + 48;
./srcs/functions/ft_itoa.c:	while (n != 0)
./srcs/functions/ft_itoa.c:	{
./srcs/functions/ft_itoa.c:		*--p = (n % 10) + 48;
./srcs/functions/ft_itoa.c:		n /= 10;
./srcs/functions/ft_itoa.c:	}
./srcs/functions/ft_itoa.c:	return (p);
./srcs/functions/ft_itoa.c:}
./srcs/functions/ft_itoa.c:
./srcs/functions/ft_itoa.c:char	*ft_itoa(long n)
./srcs/functions/ft_itoa.c:{
./srcs/functions/ft_itoa.c:	char	*p;
./srcs/functions/ft_itoa.c:
./srcs/functions/ft_itoa.c:	p = (char *)ft_memalloc(sizeof(char) * 22);
./srcs/functions/ft_itoa.c:	p = p + 21;
./srcs/functions/ft_itoa.c:	if (n >= 0)
./srcs/functions/ft_itoa.c:	{
./srcs/functions/ft_itoa.c:		if (n == 0)
./srcs/functions/ft_itoa.c:			*p = n + 48;
./srcs/functions/ft_itoa.c:		while (n != 0)
./srcs/functions/ft_itoa.c:		{
./srcs/functions/ft_itoa.c:			*--p = '0' + (n % 10);
./srcs/functions/ft_itoa.c:			n /= 10;
./srcs/functions/ft_itoa.c:		}
./srcs/functions/ft_itoa.c:		return (p);
./srcs/functions/ft_itoa.c:	}
./srcs/functions/ft_itoa.c:	else
./srcs/functions/ft_itoa.c:	{
./srcs/functions/ft_itoa.c:		while (n != 0)
./srcs/functions/ft_itoa.c:		{
./srcs/functions/ft_itoa.c:			*--p = '0' - (n % 10);
./srcs/functions/ft_itoa.c:			n /= 10;
./srcs/functions/ft_itoa.c:		}
./srcs/functions/ft_itoa.c:		*--p = '-';
./srcs/functions/ft_itoa.c:	}
./srcs/functions/ft_itoa.c:	return (p);
./srcs/functions/ft_itoa.c:}
Binary file ./srcs/functions/ft_putstr.o matches
./srcs/functions/ft_putnbr.c:/* ************************************************************************** */
./srcs/functions/ft_putnbr.c:/*                                                                            */
./srcs/functions/ft_putnbr.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_putnbr.c:/*   ft_putnbr.c                                        :+:      :+:    :+:   */
./srcs/functions/ft_putnbr.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_putnbr.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_putnbr.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_putnbr.c:/*   Created: 2013/11/26 20:18:48 by rkharif           #+#    #+#             */
./srcs/functions/ft_putnbr.c:/*   Updated: 2014/03/13 13:09:39 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_putnbr.c:/*                                                                            */
./srcs/functions/ft_putnbr.c:/* ************************************************************************** */
./srcs/functions/ft_putnbr.c:
./srcs/functions/ft_putnbr.c:#include "../../includes/msh.h"
./srcs/functions/ft_putnbr.c:
./srcs/functions/ft_putnbr.c:void	ft_putnbr(int n)
./srcs/functions/ft_putnbr.c:{
./srcs/functions/ft_putnbr.c:	int			sign;
./srcs/functions/ft_putnbr.c:
./srcs/functions/ft_putnbr.c:	sign = -1;
./srcs/functions/ft_putnbr.c:	if (n < 0)
./srcs/functions/ft_putnbr.c:	{
./srcs/functions/ft_putnbr.c:		ft_putchar('-');
./srcs/functions/ft_putnbr.c:		n = n * sign;
./srcs/functions/ft_putnbr.c:	}
./srcs/functions/ft_putnbr.c:	if (n >= 10)
./srcs/functions/ft_putnbr.c:	{
./srcs/functions/ft_putnbr.c:		ft_putnbr(n / 10);
./srcs/functions/ft_putnbr.c:		ft_putnbr(n % 10);
./srcs/functions/ft_putnbr.c:	}
./srcs/functions/ft_putnbr.c:	else
./srcs/functions/ft_putnbr.c:		ft_putchar(48 + n);
./srcs/functions/ft_putnbr.c:}
./srcs/functions/ft_strcmp.c:/* ************************************************************************** */
./srcs/functions/ft_strcmp.c:/*                                                                            */
./srcs/functions/ft_strcmp.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_strcmp.c:/*   ft_strcmp.c                                        :+:      :+:    :+:   */
./srcs/functions/ft_strcmp.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_strcmp.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_strcmp.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_strcmp.c:/*   Created: 2013/11/19 11:04:51 by lsolofri          #+#    #+#             */
./srcs/functions/ft_strcmp.c:/*   Updated: 2014/02/25 13:01:37 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_strcmp.c:/*                                                                            */
./srcs/functions/ft_strcmp.c:/* ************************************************************************** */
./srcs/functions/ft_strcmp.c:
./srcs/functions/ft_strcmp.c:int		ft_strcmp(const char *s1, const char *s2)
./srcs/functions/ft_strcmp.c:{
./srcs/functions/ft_strcmp.c:	while (*s1 == *s2 && *s1 != '\0' && *s2 != '\0')
./srcs/functions/ft_strcmp.c:	{
./srcs/functions/ft_strcmp.c:		++s1;
./srcs/functions/ft_strcmp.c:		++s2;
./srcs/functions/ft_strcmp.c:	}
./srcs/functions/ft_strcmp.c:	return (*s1 - *s2);
./srcs/functions/ft_strcmp.c:}
Binary file ./srcs/functions/ft_get_path.o matches
./srcs/functions/ft_isprint.c:/* ************************************************************************** */
./srcs/functions/ft_isprint.c:/*                                                                            */
./srcs/functions/ft_isprint.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_isprint.c:/*   ft_isprint.c                                       :+:      :+:    :+:   */
./srcs/functions/ft_isprint.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_isprint.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_isprint.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_isprint.c:/*   Created: 2013/11/20 16:34:18 by lsolofri          #+#    #+#             */
./srcs/functions/ft_isprint.c:/*   Updated: 2013/12/27 11:36:15 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_isprint.c:/*                                                                            */
./srcs/functions/ft_isprint.c:/* ************************************************************************** */
./srcs/functions/ft_isprint.c:
./srcs/functions/ft_isprint.c:int		ft_isprint(int c)
./srcs/functions/ft_isprint.c:{
./srcs/functions/ft_isprint.c:	if (c >= 32 && c <= 126)
./srcs/functions/ft_isprint.c:		return (1);
./srcs/functions/ft_isprint.c:	return (0);
./srcs/functions/ft_isprint.c:}
Binary file ./srcs/functions/ft_strncmp.o matches
Binary file ./srcs/functions/ft_free.o matches
./srcs/functions/ft_isalpha.c:/* ************************************************************************** */
./srcs/functions/ft_isalpha.c:/*                                                                            */
./srcs/functions/ft_isalpha.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_isalpha.c:/*   ft_isalpha.c                                       :+:      :+:    :+:   */
./srcs/functions/ft_isalpha.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_isalpha.c:/*   By: mfaye <mfaye@student.42.fr>                +#+  +:+       +#+        */
./srcs/functions/ft_isalpha.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_isalpha.c:/*   Created: 2013/11/19 18:37:43 by mfaye             #+#    #+#             */
./srcs/functions/ft_isalpha.c:/*   Updated: 2013/11/19 18:41:48 by mfaye            ###   ########.fr       */
./srcs/functions/ft_isalpha.c:/*                                                                            */
./srcs/functions/ft_isalpha.c:/* ************************************************************************** */
./srcs/functions/ft_isalpha.c:
./srcs/functions/ft_isalpha.c:int	ft_isalpha(int c)
./srcs/functions/ft_isalpha.c:{
./srcs/functions/ft_isalpha.c:	int	is_alpha;
./srcs/functions/ft_isalpha.c:
./srcs/functions/ft_isalpha.c:	is_alpha = ((c >= 0101) && (c <= 0132));
./srcs/functions/ft_isalpha.c:	return (is_alpha || ((c >= 0141) && (c <= 0172)));
./srcs/functions/ft_isalpha.c:}
./srcs/functions/ft_strdup.c:/* ************************************************************************** */
./srcs/functions/ft_strdup.c:/*                                                                            */
./srcs/functions/ft_strdup.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_strdup.c:/*   ft_strdup.c                                        :+:      :+:    :+:   */
./srcs/functions/ft_strdup.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_strdup.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_strdup.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_strdup.c:/*   Created: 2014/03/22 12:04:47 by rkharif           #+#    #+#             */
./srcs/functions/ft_strdup.c:/*   Updated: 2014/03/22 12:04:49 by rkharif          ###   ########.fr       */
./srcs/functions/ft_strdup.c:/*                                                                            */
./srcs/functions/ft_strdup.c:/* ************************************************************************** */
./srcs/functions/ft_strdup.c:
./srcs/functions/ft_strdup.c:#include "../../includes/msh.h"
./srcs/functions/ft_strdup.c:
./srcs/functions/ft_strdup.c:char	*ft_strdup(const char *s1)
./srcs/functions/ft_strdup.c:{
./srcs/functions/ft_strdup.c:	char	*dup;
./srcs/functions/ft_strdup.c:	int		i;
./srcs/functions/ft_strdup.c:	int		size;
./srcs/functions/ft_strdup.c:
./srcs/functions/ft_strdup.c:	size = ft_strlen((char *)s1);
./srcs/functions/ft_strdup.c:	if ((dup = (char *) ft_memalloc(sizeof(char) * size + 1)) == NULL)
./srcs/functions/ft_strdup.c:		return (NULL);
./srcs/functions/ft_strdup.c:	i = 0;
./srcs/functions/ft_strdup.c:	while (i < size)
./srcs/functions/ft_strdup.c:	{
./srcs/functions/ft_strdup.c:		dup[i] = s1[i];
./srcs/functions/ft_strdup.c:		i++;
./srcs/functions/ft_strdup.c:	}
./srcs/functions/ft_strdup.c:	dup[i] = '\0';
./srcs/functions/ft_strdup.c:	return (dup);
./srcs/functions/ft_strdup.c:}
Binary file ./srcs/functions/ft_isalpha.o matches
./srcs/functions/ft_putchar.c:/* ************************************************************************** */
./srcs/functions/ft_putchar.c:/*                                                                            */
./srcs/functions/ft_putchar.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_putchar.c:/*   ft_putchar.c                                       :+:      :+:    :+:   */
./srcs/functions/ft_putchar.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_putchar.c:/*   By: msevery <msevery@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_putchar.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_putchar.c:/*   Created: 2013/12/15 21:35:44 by msevery           #+#    #+#             */
./srcs/functions/ft_putchar.c:/*   Updated: 2013/12/19 10:54:03 by aardjoun         ###   ########.fr       */
./srcs/functions/ft_putchar.c:/*                                                                            */
./srcs/functions/ft_putchar.c:/* ************************************************************************** */
./srcs/functions/ft_putchar.c:
./srcs/functions/ft_putchar.c:#include <unistd.h>
./srcs/functions/ft_putchar.c:
./srcs/functions/ft_putchar.c:int		ft_putchar(char c)
./srcs/functions/ft_putchar.c:{
./srcs/functions/ft_putchar.c:	return (write(1, &c, 1));
./srcs/functions/ft_putchar.c:}
./srcs/functions/ft_free.c:/* ************************************************************************** */
./srcs/functions/ft_free.c:/*                                                                            */
./srcs/functions/ft_free.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_free.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_free.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_free.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_free.c:/*   Created: 2014/03/22 11:45:32 by rkharif           #+#    #+#             */
./srcs/functions/ft_free.c:/*   Updated: 2014/03/22 11:45:56 by rkharif          ###   ########.fr       */
./srcs/functions/ft_free.c:/*                                                                            */
./srcs/functions/ft_free.c:/* ************************************************************************** */
./srcs/functions/ft_free.c:
./srcs/functions/ft_free.c:#include <stdlib.h>
./srcs/functions/ft_free.c:#include "../../includes/msh.h"
./srcs/functions/ft_free.c:
./srcs/functions/ft_free.c:{
./srcs/functions/ft_free.c:	if (p)
./srcs/functions/ft_free.c:		ft_gc(p, E_GCFREE);
./srcs/functions/ft_free.c:}
./srcs/functions/ft_atoi.c:/* ************************************************************************** */
./srcs/functions/ft_atoi.c:/*                                                                            */
./srcs/functions/ft_atoi.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_atoi.c:/*   ft_atoi.c                                          :+:      :+:    :+:   */
./srcs/functions/ft_atoi.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_atoi.c:/*   By: aardjoun <aardjoun@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_atoi.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_atoi.c:/*   Created: 2013/11/23 12:27:34 by aardjoun          #+#    #+#             */
./srcs/functions/ft_atoi.c:/*   Updated: 2014/02/18 13:57:01 by aardjoun         ###   ########.fr       */
./srcs/functions/ft_atoi.c:/*                                                                            */
./srcs/functions/ft_atoi.c:/* ************************************************************************** */
./srcs/functions/ft_atoi.c:
./srcs/functions/ft_atoi.c:#include "../../includes/msh.h"
./srcs/functions/ft_atoi.c:
./srcs/functions/ft_atoi.c:int		ft_atoi(const char *str)
./srcs/functions/ft_atoi.c:{
./srcs/functions/ft_atoi.c:	int		i;
./srcs/functions/ft_atoi.c:	int		res;
./srcs/functions/ft_atoi.c:	int		sign;
./srcs/functions/ft_atoi.c:
./srcs/functions/ft_atoi.c:	i = 0;
./srcs/functions/ft_atoi.c:	res = 0;
./srcs/functions/ft_atoi.c:	sign = 1;
./srcs/functions/ft_atoi.c:	while ((str[i] >= 9 && str[i] <= 13) || str[i] == ' ')
./srcs/functions/ft_atoi.c:		i++;
./srcs/functions/ft_atoi.c:	if (str[i] == '-' || str[i] == '+')
./srcs/functions/ft_atoi.c:	{
./srcs/functions/ft_atoi.c:		sign = ((str[i] == '-') ? -1 : 1);
./srcs/functions/ft_atoi.c:		i++;
./srcs/functions/ft_atoi.c:	}
./srcs/functions/ft_atoi.c:	while (str[i] >= '0' && str[i] <= '9')
./srcs/functions/ft_atoi.c:	{
./srcs/functions/ft_atoi.c:		res = ((res * 10) + str[i]) - '0';
./srcs/functions/ft_atoi.c:		i++;
./srcs/functions/ft_atoi.c:	}
./srcs/functions/ft_atoi.c:	return (sign * res);
./srcs/functions/ft_atoi.c:}
./srcs/functions/ft_atoi.c:
Binary file ./srcs/functions/ft_strjoin.o matches
Binary file ./srcs/functions/welcome.o matches
Binary file ./srcs/functions/ft_itoa.o matches
./srcs/functions/ft_new_tab.c:/* ************************************************************************** */
./srcs/functions/ft_new_tab.c:/*                                                                            */
./srcs/functions/ft_new_tab.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_new_tab.c:/*   ft_new_tab.c                                       :+:      :+:    :+:   */
./srcs/functions/ft_new_tab.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_new_tab.c:/*   By: aardjoun <aardjoun@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_new_tab.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_new_tab.c:/*   Created: 2013/12/27 15:01:34 by aardjoun          #+#    #+#             */
./srcs/functions/ft_new_tab.c:/*   Updated: 2014/03/13 08:58:42 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_new_tab.c:/*                                                                            */
./srcs/functions/ft_new_tab.c:/* ************************************************************************** */
./srcs/functions/ft_new_tab.c:
./srcs/functions/ft_new_tab.c:#include "../../includes/msh.h"
./srcs/functions/ft_new_tab.c:
./srcs/functions/ft_new_tab.c:char	**ft_new_tab(int i)
./srcs/functions/ft_new_tab.c:{
./srcs/functions/ft_new_tab.c:	char	**tab;
./srcs/functions/ft_new_tab.c:	int		n;
./srcs/functions/ft_new_tab.c:
./srcs/functions/ft_new_tab.c:	n = 0;
./srcs/functions/ft_new_tab.c:	tab = (char **)ft_memalloc((i + 1) * sizeof(char *));
./srcs/functions/ft_new_tab.c:	while (n <= i)
./srcs/functions/ft_new_tab.c:		tab[n++] = NULL;
./srcs/functions/ft_new_tab.c:	return (tab);
./srcs/functions/ft_new_tab.c:}
./srcs/functions/ft_memalloc.c:/* ************************************************************************** */
./srcs/functions/ft_memalloc.c:/*                                                                            */
./srcs/functions/ft_memalloc.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_memalloc.c:/*   ft_memalloc.c                                      :+:      :+:    :+:   */
./srcs/functions/ft_memalloc.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_memalloc.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_memalloc.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_memalloc.c:/*   Created: 2014/03/13 08:33:33 by lsolofri          #+#    #+#             */
./srcs/functions/ft_memalloc.c:/*   Updated: 2014/03/13 08:43:07 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_memalloc.c:/*                                                                            */
./srcs/functions/ft_memalloc.c:/* ************************************************************************** */
./srcs/functions/ft_memalloc.c:
./srcs/functions/ft_memalloc.c:#include <stdlib.h>
./srcs/functions/ft_memalloc.c:#include "../../includes/msh.h"
./srcs/functions/ft_memalloc.c:
./srcs/functions/ft_memalloc.c:void	*ft_memalloc(size_t size)
./srcs/functions/ft_memalloc.c:{
./srcs/functions/ft_memalloc.c:	void	*new;
./srcs/functions/ft_memalloc.c:
./srcs/functions/ft_memalloc.c:	new = NULL;
./srcs/functions/ft_memalloc.c:	if ((new = malloc(size)) == NULL)
./srcs/functions/ft_memalloc.c:		return (NULL);
./srcs/functions/ft_memalloc.c:	else
./srcs/functions/ft_memalloc.c:	{
./srcs/functions/ft_memalloc.c:		ft_bzero(new, size);
./srcs/functions/ft_memalloc.c:		ft_gc(new, E_GCADD);
./srcs/functions/ft_memalloc.c:	}
./srcs/functions/ft_memalloc.c:	return (new);
./srcs/functions/ft_memalloc.c:}
./srcs/functions/ft_insert_tab.c:/* ************************************************************************** */
./srcs/functions/ft_insert_tab.c:/*                                                                            */
./srcs/functions/ft_insert_tab.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_insert_tab.c:/*   ft_insert_tab.c                                    :+:      :+:    :+:   */
./srcs/functions/ft_insert_tab.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_insert_tab.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_insert_tab.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_insert_tab.c:/*   Created: 2014/03/05 14:18:59 by lsolofri          #+#    #+#             */
./srcs/functions/ft_insert_tab.c:/*   Updated: 2014/03/23 21:46:22 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_insert_tab.c:/*                                                                            */
./srcs/functions/ft_insert_tab.c:/* ************************************************************************** */
./srcs/functions/ft_insert_tab.c:
./srcs/functions/ft_insert_tab.c:#include "../../includes/msh.h"
./srcs/functions/ft_insert_tab.c:
./srcs/functions/ft_insert_tab.c:char	**ft_insert_tab(char **src, char **alias, int i)
./srcs/functions/ft_insert_tab.c:{
./srcs/functions/ft_insert_tab.c:	char	**res;
./srcs/functions/ft_insert_tab.c:	int		j;
./srcs/functions/ft_insert_tab.c:	int		v;
./srcs/functions/ft_insert_tab.c:	int		x;
./srcs/functions/ft_insert_tab.c:
./srcs/functions/ft_insert_tab.c:	x = v = j = 0;
./srcs/functions/ft_insert_tab.c:	res = (char **)ft_memalloc(sizeof(char *) * (ft_tablen(src) + ft_tablen(alias)));
./srcs/functions/ft_insert_tab.c:	while (j < (ft_tablen(src) + ft_tablen(alias)))
./srcs/functions/ft_insert_tab.c:	{
./srcs/functions/ft_insert_tab.c:		if (j == i)
./srcs/functions/ft_insert_tab.c:		{
./srcs/functions/ft_insert_tab.c:			++v;
./srcs/functions/ft_insert_tab.c:			while (alias[x])
./srcs/functions/ft_insert_tab.c:				res[j++] = alias[x++];
./srcs/functions/ft_insert_tab.c:		}
./srcs/functions/ft_insert_tab.c:		else
./srcs/functions/ft_insert_tab.c:			res[j++] = ft_strdup(src[v++]);
./srcs/functions/ft_insert_tab.c:	}
./srcs/functions/ft_insert_tab.c:	res[j - 1] = NULL;
./srcs/functions/ft_insert_tab.c:	return (res);
./srcs/functions/ft_insert_tab.c:}
./srcs/functions/ft_strsplit.c:/* ************************************************************************** */
./srcs/functions/ft_strsplit.c:/*                                                                            */
./srcs/functions/ft_strsplit.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_strsplit.c:/*   ft_strsplit.c                                      :+:      :+:    :+:   */
./srcs/functions/ft_strsplit.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_strsplit.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_strsplit.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_strsplit.c:/*   Created: 2014/03/22 11:44:37 by rkharif           #+#    #+#             */
./srcs/functions/ft_strsplit.c:/*   Updated: 2014/03/22 11:44:46 by rkharif          ###   ########.fr       */
./srcs/functions/ft_strsplit.c:/*                                                                            */
./srcs/functions/ft_strsplit.c:/* ************************************************************************** */
./srcs/functions/ft_strsplit.c:
./srcs/functions/ft_strsplit.c:
./srcs/functions/ft_strsplit.c:#include <stdlib.h>
./srcs/functions/ft_strsplit.c:#include "../../includes/msh.h"
./srcs/functions/ft_strsplit.c:
./srcs/functions/ft_strsplit.c:static t_ui		count_words(char const *s, char c)
./srcs/functions/ft_strsplit.c:{
./srcs/functions/ft_strsplit.c:	t_ui	i;
./srcs/functions/ft_strsplit.c:
./srcs/functions/ft_strsplit.c:	i = 0;
./srcs/functions/ft_strsplit.c:	while (*s == c)
./srcs/functions/ft_strsplit.c:		s++;
./srcs/functions/ft_strsplit.c:	while (*s)
./srcs/functions/ft_strsplit.c:	{
./srcs/functions/ft_strsplit.c:		while (*s && (*s != c))
./srcs/functions/ft_strsplit.c:			s++;
./srcs/functions/ft_strsplit.c:		i++;
./srcs/functions/ft_strsplit.c:		while (*s && (*s == c))
./srcs/functions/ft_strsplit.c:			s++;
./srcs/functions/ft_strsplit.c:	}
./srcs/functions/ft_strsplit.c:	return (i);
./srcs/functions/ft_strsplit.c:}
./srcs/functions/ft_strsplit.c:
./srcs/functions/ft_strsplit.c:static t_ui		*get_word_len(t_ui word_c, char const *s, \
./srcs/functions/ft_strsplit.c:								char c)
./srcs/functions/ft_strsplit.c:{
./srcs/functions/ft_strsplit.c:	t_ui	i;
./srcs/functions/ft_strsplit.c:	t_ui	j;
./srcs/functions/ft_strsplit.c:	t_ui	*word_len;
./srcs/functions/ft_strsplit.c:
./srcs/functions/ft_strsplit.c:	i = 0;
./srcs/functions/ft_strsplit.c:	j = 0;
./srcs/functions/ft_strsplit.c:	word_len = (t_ui *) ft_memalloc(sizeof(t_ui) * word_c);
./srcs/functions/ft_strsplit.c:	while (*s == c)
./srcs/functions/ft_strsplit.c:		s++;
./srcs/functions/ft_strsplit.c:	while (*s)
./srcs/functions/ft_strsplit.c:	{
./srcs/functions/ft_strsplit.c:		while (*s && (*s != c))
./srcs/functions/ft_strsplit.c:		{
./srcs/functions/ft_strsplit.c:			j++;
./srcs/functions/ft_strsplit.c:			s++;
./srcs/functions/ft_strsplit.c:		}
./srcs/functions/ft_strsplit.c:		word_len[i] = j;
./srcs/functions/ft_strsplit.c:		j = 0;
./srcs/functions/ft_strsplit.c:		i++;
./srcs/functions/ft_strsplit.c:		while (*s && (*s == c))
./srcs/functions/ft_strsplit.c:			s++;
./srcs/functions/ft_strsplit.c:	}
./srcs/functions/ft_strsplit.c:	return (word_len);
./srcs/functions/ft_strsplit.c:}
./srcs/functions/ft_strsplit.c:
./srcs/functions/ft_strsplit.c:static char		**build_array(t_ui w_c, t_ui *word_l)
./srcs/functions/ft_strsplit.c:{
./srcs/functions/ft_strsplit.c:	char	**split;
./srcs/functions/ft_strsplit.c:	t_ui	i;
./srcs/functions/ft_strsplit.c:
./srcs/functions/ft_strsplit.c:	i = 0;
./srcs/functions/ft_strsplit.c:	split = (char **) ft_memalloc(sizeof(char *) * w_c + 1);
./srcs/functions/ft_strsplit.c:	while (i < w_c)
./srcs/functions/ft_strsplit.c:	{
./srcs/functions/ft_strsplit.c:		split[i] = ft_strnew((size_t) word_l[i] + 1);
./srcs/functions/ft_strsplit.c:		i++;
./srcs/functions/ft_strsplit.c:	}
./srcs/functions/ft_strsplit.c:	split[i] = NULL;
./srcs/functions/ft_strsplit.c:	return (split);
./srcs/functions/ft_strsplit.c:}
./srcs/functions/ft_strsplit.c:
./srcs/functions/ft_strsplit.c:char			**ft_strsplit(char const *s, char c)
./srcs/functions/ft_strsplit.c:{
./srcs/functions/ft_strsplit.c:	t_ui	word_count;
./srcs/functions/ft_strsplit.c:	char	**split;
./srcs/functions/ft_strsplit.c:	t_ui	*word_len;
./srcs/functions/ft_strsplit.c:	t_ui	i;
./srcs/functions/ft_strsplit.c:	t_ui	j;
./srcs/functions/ft_strsplit.c:
./srcs/functions/ft_strsplit.c:	j = 0;
./srcs/functions/ft_strsplit.c:	i = 0;
./srcs/functions/ft_strsplit.c:	word_count = count_words(s, c);
./srcs/functions/ft_strsplit.c:	word_len = get_word_len(word_count, s, c);
./srcs/functions/ft_strsplit.c:	split = build_array(word_count, word_len);
./srcs/functions/ft_strsplit.c:	while (*s == c)
./srcs/functions/ft_strsplit.c:		s++;
./srcs/functions/ft_strsplit.c:	while (*s)
./srcs/functions/ft_strsplit.c:	{
./srcs/functions/ft_strsplit.c:		while (*s && (*s != c))
./srcs/functions/ft_strsplit.c:			split[i][j++] = *s++;
./srcs/functions/ft_strsplit.c:		j = 0;
./srcs/functions/ft_strsplit.c:		while (*s && (*s == c))
./srcs/functions/ft_strsplit.c:			s++;
./srcs/functions/ft_strsplit.c:		i++;
./srcs/functions/ft_strsplit.c:	}
./srcs/functions/ft_strsplit.c:	return (split);
./srcs/functions/ft_strsplit.c:}
Binary file ./srcs/functions/ft_strcmp.o matches
./srcs/functions/ft_insert_str.c:char		*check_variable(char *str) {
./srcs/functions/ft_insert_str.c:	int		i = 0, v = 0;
./srcs/functions/ft_insert_str.c:	char	*var;
./srcs/functions/ft_insert_str.c:
./srcs/functions/ft_insert_str.c:	while (str[i]) {
./srcs/functions/ft_insert_str.c:		if (str[i] == '$') {
./srcs/functions/ft_insert_str.c:			v = i;
./srcs/functions/ft_insert_str.c:			while (str[i] != ' ' && str[i])
./srcs/functions/ft_insert_str.c:				++i;
./srcs/functions/ft_insert_str.c:			var = ft_strsub(str, v, (i - v));
./srcs/functions/ft_insert_str.c:			str = ft_strjoin(ft_strsub(str, 0, v),
./srcs/functions/ft_insert_str.c:				ft_strjoin(var, ft_strsub(str, i, ft_strlen(str) - i)));
./srcs/functions/ft_insert_str.c:		}
./srcs/functions/ft_insert_str.c:		++i;
./srcs/functions/ft_insert_str.c:	}
./srcs/functions/ft_insert_str.c:	return (str);
./srcs/functions/ft_insert_str.c:}
./srcs/functions/ft_gchelper.c:/* ************************************************************************** */
./srcs/functions/ft_gchelper.c:/*                                                                            */
./srcs/functions/ft_gchelper.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_gchelper.c:/*   ft_gchelper.c                                      :+:      :+:    :+:   */
./srcs/functions/ft_gchelper.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_gchelper.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_gchelper.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_gchelper.c:/*   Created: 2014/03/22 11:46:42 by rkharif           #+#    #+#             */
./srcs/functions/ft_gchelper.c:/*   Updated: 2014/03/22 11:46:44 by rkharif          ###   ########.fr       */
./srcs/functions/ft_gchelper.c:/*                                                                            */
./srcs/functions/ft_gchelper.c:/* ************************************************************************** */
./srcs/functions/ft_gchelper.c:
./srcs/functions/ft_gchelper.c:#include "../../includes/msh.h"
./srcs/functions/ft_gchelper.c:
./srcs/functions/ft_gchelper.c:t_gcinfo	*ft_gcinitinfo(void)
./srcs/functions/ft_gchelper.c:{
./srcs/functions/ft_gchelper.c:	t_gcinfo	*out;
./srcs/functions/ft_gchelper.c:
./srcs/functions/ft_gchelper.c:	if ((out = (t_gcinfo *)malloc(sizeof(t_gcinfo))) == NULL)
./srcs/functions/ft_gchelper.c:		return (NULL);
./srcs/functions/ft_gchelper.c:	out->nb = 0;
./srcs/functions/ft_gchelper.c:	out->size = 0;
./srcs/functions/ft_gchelper.c:	out->first_avail = NULL;
./srcs/functions/ft_gchelper.c:	return (out);
./srcs/functions/ft_gchelper.c:}
./srcs/functions/ft_gchelper.c:
./srcs/functions/ft_gchelper.c:void		ft_gcrealloc(t_gc **ring, t_gcinfo **info, int init_size)
./srcs/functions/ft_gchelper.c:{
./srcs/functions/ft_gchelper.c:	int		i;
./srcs/functions/ft_gchelper.c:	t_gc	*new;
./srcs/functions/ft_gchelper.c:
./srcs/functions/ft_gchelper.c:	i = 0;
./srcs/functions/ft_gchelper.c:	while (i < init_size)
./srcs/functions/ft_gchelper.c:	{
./srcs/functions/ft_gchelper.c:		if ((new = (t_gc *)malloc(sizeof(t_gc))) != NULL)
./srcs/functions/ft_gchelper.c:		{
./srcs/functions/ft_gchelper.c:			new->p = NULL;
./srcs/functions/ft_gchelper.c:			new->next = NULL;
./srcs/functions/ft_gchelper.c:			if (ring != NULL)
./srcs/functions/ft_gchelper.c:				new->next = *ring;
./srcs/functions/ft_gchelper.c:			*ring = new;
./srcs/functions/ft_gchelper.c:			(*info)->first = new;
./srcs/functions/ft_gchelper.c:			(*info)->size++;
./srcs/functions/ft_gchelper.c:			(*info)->first_avail = new;
./srcs/functions/ft_gchelper.c:		}
./srcs/functions/ft_gchelper.c:		i++;
./srcs/functions/ft_gchelper.c:	}
./srcs/functions/ft_gchelper.c:}
./srcs/functions/ft_gchelper.c:
./srcs/functions/ft_gchelper.c:void		ft_gcinit(t_gc **ring, int init_size, t_gcinfo **info)
./srcs/functions/ft_gchelper.c:{
./srcs/functions/ft_gchelper.c:	if ((*info = ft_gcinitinfo()) != NULL)
./srcs/functions/ft_gchelper.c:		ft_gcrealloc(ring, info, init_size);
./srcs/functions/ft_gchelper.c:}
Binary file ./srcs/functions/ft_bzero.o matches
Binary file ./srcs/functions/ft_tabncmp.o matches
./srcs/functions/ft_get_path.c:/* ************************************************************************** */
./srcs/functions/ft_get_path.c:/*                                                                            */
./srcs/functions/ft_get_path.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_get_path.c:/*   ft_get_path.c                                      :+:      :+:    :+:   */
./srcs/functions/ft_get_path.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_get_path.c:/*   By: aardjoun <aardjoun@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_get_path.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_get_path.c:/*   Created: 2014/01/11 14:35:34 by aardjoun          #+#    #+#             */
./srcs/functions/ft_get_path.c:/*   Updated: 2014/02/14 16:05:18 by aardjoun         ###   ########.fr       */
./srcs/functions/ft_get_path.c:/*                                                                            */
./srcs/functions/ft_get_path.c:/* ************************************************************************** */
./srcs/functions/ft_get_path.c:
./srcs/functions/ft_get_path.c:#include "../../includes/msh.h"
./srcs/functions/ft_get_path.c:
./srcs/functions/ft_get_path.c:char		**ft_get_path(char **env, char *commande)
./srcs/functions/ft_get_path.c:{
./srcs/functions/ft_get_path.c:	int		i;
./srcs/functions/ft_get_path.c:	char	**path;
./srcs/functions/ft_get_path.c:
./srcs/functions/ft_get_path.c:	i = 0;
./srcs/functions/ft_get_path.c:	while (env[i] && (ft_strncmp("PATH=", env[i], 5)))
./srcs/functions/ft_get_path.c:		i++;
./srcs/functions/ft_get_path.c:	path = ft_strsplit(&env[i][5], ':');
./srcs/functions/ft_get_path.c:	i = 0;
./srcs/functions/ft_get_path.c:	while (path[i])
./srcs/functions/ft_get_path.c:	{
./srcs/functions/ft_get_path.c:		path[i] = ft_strjoin(path[i], "/");
./srcs/functions/ft_get_path.c:		path[i] = ft_strjoin(path[i], commande);
./srcs/functions/ft_get_path.c:		i++;
./srcs/functions/ft_get_path.c:	}
./srcs/functions/ft_get_path.c:	return (path);
./srcs/functions/ft_get_path.c:}
Binary file ./srcs/functions/ft_gc.o matches
./srcs/functions/welcome.c:/* ************************************************************************** */
./srcs/functions/welcome.c:/*                                                                            */
./srcs/functions/welcome.c:/*                                                        :::      ::::::::   */
./srcs/functions/welcome.c:/*   welcome.c                                          :+:      :+:    :+:   */
./srcs/functions/welcome.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/welcome.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/welcome.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/welcome.c:/*   Created: 2014/03/03 16:22:05 by lsolofri          #+#    #+#             */
./srcs/functions/welcome.c:/*   Updated: 2014/03/03 16:23:41 by lsolofri         ###   ########.fr       */
./srcs/functions/welcome.c:/*                                                                            */
./srcs/functions/welcome.c:/* ************************************************************************** */
./srcs/functions/welcome.c:
./srcs/functions/welcome.c:#include "../../includes/msh.h"
./srcs/functions/welcome.c:
./srcs/functions/welcome.c:void	welcome(void)
./srcs/functions/welcome.c:{
./srcs/functions/welcome.c:	ft_putstr("Welcome to ");
./srcs/functions/welcome.c:	ft_putstr(GRE);
./srcs/functions/welcome.c:	ft_putstr("msh");
./srcs/functions/welcome.c:	ft_putstr(DEF);
./srcs/functions/welcome.c:	ft_putstr(", the friendly interactive shell !\n");
./srcs/functions/welcome.c:}
./srcs/functions/ft_tabncmp.c:/* ************************************************************************** */
./srcs/functions/ft_tabncmp.c:/*                                                                            */
./srcs/functions/ft_tabncmp.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_tabncmp.c:/*   ft_tabncmp.c                                       :+:      :+:    :+:   */
./srcs/functions/ft_tabncmp.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_tabncmp.c:/*   By: aardjoun <marvin@42.fr>                    +#+  +:+       +#+        */
./srcs/functions/ft_tabncmp.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_tabncmp.c:/*   Created: 2014/02/12 18:29:47 by aardjoun          #+#    #+#             */
./srcs/functions/ft_tabncmp.c:/*   Updated: 2014/02/21 19:11:51 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_tabncmp.c:/*                                                                            */
./srcs/functions/ft_tabncmp.c:/* ************************************************************************** */
./srcs/functions/ft_tabncmp.c:
./srcs/functions/ft_tabncmp.c:#include "../../includes/msh.h"
./srcs/functions/ft_tabncmp.c:
./srcs/functions/ft_tabncmp.c:int		ft_tabncmp(char **env, char **av)
./srcs/functions/ft_tabncmp.c:{
./srcs/functions/ft_tabncmp.c:	int		i;
./srcs/functions/ft_tabncmp.c:	int		l;
./srcs/functions/ft_tabncmp.c:	char	*tmp;
./srcs/functions/ft_tabncmp.c:
./srcs/functions/ft_tabncmp.c:	i = -1;
./srcs/functions/ft_tabncmp.c:	tmp = ft_strjoin(av[1], "=");
./srcs/functions/ft_tabncmp.c:	l = ft_strlen(tmp);
./srcs/functions/ft_tabncmp.c:	while (env[++i] && av[1] && ft_strcmp("", av[1]) != 0)
./srcs/functions/ft_tabncmp.c:	{
./srcs/functions/ft_tabncmp.c:		if (ft_strncmp(env[i], tmp, l) == 0)
./srcs/functions/ft_tabncmp.c:			return (i);
./srcs/functions/ft_tabncmp.c:	}
./srcs/functions/ft_tabncmp.c:	return (-1);
./srcs/functions/ft_tabncmp.c:}
Binary file ./srcs/functions/ft_putnbr.o matches
./srcs/functions/ft_putendl.c:/* ************************************************************************** */
./srcs/functions/ft_putendl.c:/*                                                                            */
./srcs/functions/ft_putendl.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_putendl.c:/*   ft_putendl.c                                       :+:      :+:    :+:   */
./srcs/functions/ft_putendl.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_putendl.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_putendl.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_putendl.c:/*   Created: 2013/11/21 11:28:05 by lsolofri          #+#    #+#             */
./srcs/functions/ft_putendl.c:/*   Updated: 2013/12/27 11:39:12 by lsolofri         ###   ########.fr       */
./srcs/functions/ft_putendl.c:/*                                                                            */
./srcs/functions/ft_putendl.c:/* ************************************************************************** */
./srcs/functions/ft_putendl.c:
./srcs/functions/ft_putendl.c:#include <string.h>
./srcs/functions/ft_putendl.c:#include <unistd.h>
./srcs/functions/ft_putendl.c:
./srcs/functions/ft_putendl.c:size_t	ft_strlen(const char *s);
./srcs/functions/ft_putendl.c:
./srcs/functions/ft_putendl.c:void	ft_putendl(char const *s)
./srcs/functions/ft_putendl.c:{
./srcs/functions/ft_putendl.c:	write(1, s, ft_strlen(s));
./srcs/functions/ft_putendl.c:	write(1, "\n", 1);
./srcs/functions/ft_putendl.c:}
Binary file ./srcs/functions/ft_strdup.o matches
./srcs/functions/ft_gc.c:/* ************************************************************************** */
./srcs/functions/ft_gc.c:/*                                                                            */
./srcs/functions/ft_gc.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_gc.c:/*   ft_gc.c                                            :+:      :+:    :+:   */
./srcs/functions/ft_gc.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_gc.c:/*   By: rkharif <rkharif@student.42.fr>            +#+  +:+       +#+        */
./srcs/functions/ft_gc.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_gc.c:/*   Created: 2014/03/22 11:46:10 by rkharif           #+#    #+#             */
./srcs/functions/ft_gc.c:/*   Updated: 2014/03/22 11:46:14 by rkharif          ###   ########.fr       */
./srcs/functions/ft_gc.c:/*                                                                            */
./srcs/functions/ft_gc.c:/* ************************************************************************** */
./srcs/functions/ft_gc.c:
./srcs/functions/ft_gc.c:#include "../../includes/msh.h"
./srcs/functions/ft_gc.c:
./srcs/functions/ft_gc.c:static void	ft_gcadd(void *p, t_gc **ring, t_gcinfo **info)
./srcs/functions/ft_gc.c:{
./srcs/functions/ft_gc.c:	t_gc	*avail;
./srcs/functions/ft_gc.c://	t_gc	*start;
./srcs/functions/ft_gc.c:
./srcs/functions/ft_gc.c:	if (*ring == NULL)
./srcs/functions/ft_gc.c:		ft_gcinit(ring, GC_NBSTART, info);
./srcs/functions/ft_gc.c:	if ((*info)->nb + 1 == (*info)->size)
./srcs/functions/ft_gc.c:		ft_gcrealloc(ring, info, GC_NBSTART);
./srcs/functions/ft_gc.c:	avail = (*info)->first_avail;
./srcs/functions/ft_gc.c:	avail->p = p;
./srcs/functions/ft_gc.c://	start = avail;
./srcs/functions/ft_gc.c:	(*info)->nb++;
./srcs/functions/ft_gc.c:	while (avail)
./srcs/functions/ft_gc.c:	{
./srcs/functions/ft_gc.c:		if (avail->p == NULL)
./srcs/functions/ft_gc.c:		{
./srcs/functions/ft_gc.c:			(*info)->first_avail = avail;
./srcs/functions/ft_gc.c:			break ;
./srcs/functions/ft_gc.c:		}
./srcs/functions/ft_gc.c:		if (avail->next == NULL)
./srcs/functions/ft_gc.c:			avail = (*info)->first;
./srcs/functions/ft_gc.c:		else
./srcs/functions/ft_gc.c:			avail = avail->next;
./srcs/functions/ft_gc.c:	}
./srcs/functions/ft_gc.c:}
./srcs/functions/ft_gc.c:
./srcs/functions/ft_gc.c:static void	ft_gcfree(void *p, t_gcinfo **info)
./srcs/functions/ft_gc.c:{
./srcs/functions/ft_gc.c:	t_gc	*first;
./srcs/functions/ft_gc.c:
./srcs/functions/ft_gc.c:	if (*info && ((first = (*info)->first) != NULL))
./srcs/functions/ft_gc.c:	{
./srcs/functions/ft_gc.c:		while (first)
./srcs/functions/ft_gc.c:		{
./srcs/functions/ft_gc.c:			if (p != NULL && first->p == p)
./srcs/functions/ft_gc.c:			{
./srcs/functions/ft_gc.c:				free(first->p);
./srcs/functions/ft_gc.c:				first->p = NULL;
./srcs/functions/ft_gc.c:				(*info)->first_avail = first;
./srcs/functions/ft_gc.c:				(*info)->nb--;
./srcs/functions/ft_gc.c:				break ;
./srcs/functions/ft_gc.c:			}
./srcs/functions/ft_gc.c:			else if (p == NULL)
./srcs/functions/ft_gc.c:			{
./srcs/functions/ft_gc.c:				if (first->p)
./srcs/functions/ft_gc.c:					free(first->p);
./srcs/functions/ft_gc.c:				first->p = NULL;
./srcs/functions/ft_gc.c:				(*info)->first_avail = first;
./srcs/functions/ft_gc.c:				(*info)->nb--;
./srcs/functions/ft_gc.c:			}
./srcs/functions/ft_gc.c:			first = first->next;
./srcs/functions/ft_gc.c:		}
./srcs/functions/ft_gc.c:	}
./srcs/functions/ft_gc.c:}
./srcs/functions/ft_gc.c:
./srcs/functions/ft_gc.c:static void	ft_gcfreegc(t_gcinfo **info)
./srcs/functions/ft_gc.c:{
./srcs/functions/ft_gc.c:	ft_gcfree(NULL, info);
./srcs/functions/ft_gc.c:	free(*info);
./srcs/functions/ft_gc.c:}
./srcs/functions/ft_gc.c:
./srcs/functions/ft_gc.c:void		ft_gc(void *p, t_gcop op)
./srcs/functions/ft_gc.c:{
./srcs/functions/ft_gc.c:	static t_gc		*ring = NULL;
./srcs/functions/ft_gc.c:	static t_gcinfo	*info = NULL;
./srcs/functions/ft_gc.c:
./srcs/functions/ft_gc.c:	if (op == E_GCADD)
./srcs/functions/ft_gc.c:		ft_gcadd(p, &ring, &info);
./srcs/functions/ft_gc.c:	else if (op == E_GCFREE)
./srcs/functions/ft_gc.c:		ft_gcfree(p, &info);
./srcs/functions/ft_gc.c:	else if (op == E_GCFREEALL)
./srcs/functions/ft_gc.c:		ft_gcfree(NULL, &info);
./srcs/functions/ft_gc.c:	else
./srcs/functions/ft_gc.c:		ft_gcfreegc(&info);
./srcs/functions/ft_gc.c:}
Binary file ./srcs/functions/ft_putendl.o matches
Binary file ./srcs/functions/ft_strnew.o matches
./srcs/functions/ft_strncmp.c:/* ************************************************************************** */
./srcs/functions/ft_strncmp.c:/*                                                                            */
./srcs/functions/ft_strncmp.c:/*                                                        :::      ::::::::   */
./srcs/functions/ft_strncmp.c:/*   ft_strncmp.c                                       :+:      :+:    :+:   */
./srcs/functions/ft_strncmp.c:/*                                                    +:+ +:+         +:+     */
./srcs/functions/ft_strncmp.c:/*   By: aardjoun <aardjoun@student.42.fr>          +#+  +:+       +#+        */
./srcs/functions/ft_strncmp.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/functions/ft_strncmp.c:/*   Created: 2013/11/22 20:40:50 by aardjoun          #+#    #+#             */
./srcs/functions/ft_strncmp.c:/*   Updated: 2014/02/11 16:34:45 by aardjoun         ###   ########.fr       */
./srcs/functions/ft_strncmp.c:/*                                                                            */
./srcs/functions/ft_strncmp.c:/* ************************************************************************** */
./srcs/functions/ft_strncmp.c:
./srcs/functions/ft_strncmp.c:#include "../../includes/msh.h"
./srcs/functions/ft_strncmp.c:
./srcs/functions/ft_strncmp.c:int		ft_strncmp(const char *s1, const char *s2, size_t n)
./srcs/functions/ft_strncmp.c:{
./srcs/functions/ft_strncmp.c:	size_t	i;
./srcs/functions/ft_strncmp.c:
./srcs/functions/ft_strncmp.c:	i = 0;
./srcs/functions/ft_strncmp.c:	if (s1 == NULL)
./srcs/functions/ft_strncmp.c:		return ((int) s2[i]);
./srcs/functions/ft_strncmp.c:	if (s2 == NULL)
./srcs/functions/ft_strncmp.c:		return ((int) s1[i]);
./srcs/functions/ft_strncmp.c:	if (s1 != NULL && s2 != NULL)
./srcs/functions/ft_strncmp.c:	{
./srcs/functions/ft_strncmp.c:		while (i < n)
./srcs/functions/ft_strncmp.c:		{
./srcs/functions/ft_strncmp.c:			if (s1[i] != s2[i] && s1[i])
./srcs/functions/ft_strncmp.c:				return (((int)s1[i] - (int)s2[i]));
./srcs/functions/ft_strncmp.c:			i++;
./srcs/functions/ft_strncmp.c:		}
./srcs/functions/ft_strncmp.c:	}
./srcs/functions/ft_strncmp.c:	return (0);
./srcs/functions/ft_strncmp.c:}
./srcs/functions/ft_strncmp.c:
Binary file ./srcs/functions/ft_free_tab.o matches
Binary file ./srcs/functions/ft_memcpy.o matches
Binary file ./srcs/functions/ft_new_tab.o matches
./srcs/builtin/no_conf.c:/* ************************************************************************** */
./srcs/builtin/no_conf.c:/*                                                                            */
./srcs/builtin/no_conf.c:/*                                                        :::      ::::::::   */
./srcs/builtin/no_conf.c:/*   no_conf.c                                          :+:      :+:    :+:   */
./srcs/builtin/no_conf.c:/*                                                    +:+ +:+         +:+     */
./srcs/builtin/no_conf.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/builtin/no_conf.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/builtin/no_conf.c:/*   Created: 2014/03/02 19:54:06 by lsolofri          #+#    #+#             */
./srcs/builtin/no_conf.c:/*   Updated: 2014/03/13 08:51:34 by lsolofri         ###   ########.fr       */
./srcs/builtin/no_conf.c:/*                                                                            */
./srcs/builtin/no_conf.c:/* ************************************************************************** */
./srcs/builtin/no_conf.c:
./srcs/builtin/no_conf.c:#include "../../includes/msh.h"
./srcs/builtin/no_conf.c:
./srcs/builtin/no_conf.c:void	no_conf(void)
./srcs/builtin/no_conf.c:{
./srcs/builtin/no_conf.c:	struct termios	term;
./srcs/builtin/no_conf.c:	char			*buffer;
./srcs/builtin/no_conf.c:	int				fd;
./srcs/builtin/no_conf.c:
./srcs/builtin/no_conf.c:	init_flag(&term);
./srcs/builtin/no_conf.c:	buffer = (char *)ft_memalloc(sizeof(char) * 3);
./srcs/builtin/no_conf.c:	ft_putstr(tgetstr("cl", NULL));
./srcs/builtin/no_conf.c:	ft_putendl("Welcome in MSH!\nYou have no configuration file for the moment, please, make a choice! :");
./srcs/builtin/no_conf.c:	ft_putendl("[0] Create an empty configuration file");
./srcs/builtin/no_conf.c:	ft_putendl("[1] Create a default configuration file");
./srcs/builtin/no_conf.c:	ft_putendl("Other for do nothing");
./srcs/builtin/no_conf.c:	read(0, buffer, 3);
./srcs/builtin/no_conf.c:	if (buffer[0] == '0')
./srcs/builtin/no_conf.c:		open(ft_strjoin(find_value_envir(g_env, "HOME"), "/.mshrc"), O_CREAT, 0777);
./srcs/builtin/no_conf.c:	else if (buffer[0] == '1')
./srcs/builtin/no_conf.c:	{
./srcs/builtin/no_conf.c:		fd = open(ft_strjoin(find_value_envir(g_env, "HOME"), "/.mshrc"), O_WRONLY | O_CREAT, 0777);
./srcs/builtin/no_conf.c:		write(fd, "alias l \"ls\"\nalias ll \"ls -la\"\n", 32);
./srcs/builtin/no_conf.c:	}
./srcs/builtin/no_conf.c:	ft_putstr(tgetstr("cl", NULL));
./srcs/builtin/no_conf.c:	re_flag(&term);
./srcs/builtin/no_conf.c:}
./srcs/builtin/cd.c:
./srcs/builtin/cd.c:/* ************************************************************************** */
./srcs/builtin/cd.c:/*                                                                            */
./srcs/builtin/cd.c:/*                                                        :::      ::::::::   */
./srcs/builtin/cd.c:/*   cd.c                                               :+:      :+:    :+:   */
./srcs/builtin/cd.c:/*                                                    +:+ +:+         +:+     */
./srcs/builtin/cd.c:/*   By: aardjoun <marvin@42.fr>                    +#+  +:+       +#+        */
./srcs/builtin/cd.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/builtin/cd.c:/*   Created: 2014/02/24 16:19:25 by aardjoun          #+#    #+#             */
./srcs/builtin/cd.c:/*   Updated: 2014/02/24 20:34:56 by aardjoun         ###   ########.fr       */
./srcs/builtin/cd.c:/*                                                                            */
./srcs/builtin/cd.c:/* ************************************************************************** */
./srcs/builtin/cd.c:
./srcs/builtin/cd.c:#include "../../includes/msh.h"
./srcs/builtin/cd.c:
./srcs/builtin/cd.c:void		change_pwd(int home)
./srcs/builtin/cd.c:{
./srcs/builtin/cd.c:	char	*tmp;
./srcs/builtin/cd.c:
./srcs/builtin/cd.c:	if (home == 0)
./srcs/builtin/cd.c:		tmp = getcwd(NULL, 1064);
./srcs/builtin/cd.c:	else
./srcs/builtin/cd.c:		tmp = find_value_envir(g_env, "HOME");
./srcs/builtin/cd.c:	ft_setenv(g_env, "OLDPWD", find_value_envir(g_env, "PWD"));
./srcs/builtin/cd.c:	if (!tmp)
./srcs/builtin/cd.c:		tmp = ft_strdup("/");
./srcs/builtin/cd.c:	ft_setenv(g_env, "PWD", tmp);
./srcs/builtin/cd.c:}
./srcs/builtin/cd.c:
./srcs/builtin/cd.c:int			ft_cd(char **tab)
./srcs/builtin/cd.c:{
./srcs/builtin/cd.c:	if (!tab[1])
./srcs/builtin/cd.c:	{
./srcs/builtin/cd.c:		ft_putendl(find_value_envir(g_env, "HOME"));
./srcs/builtin/cd.c:		tab[1] = find_value_envir(g_env, "HOME");
./srcs/builtin/cd.c:		if (chdir(tab[1]) == -1)
./srcs/builtin/cd.c:			return (cd_error(tab[1]));
./srcs/builtin/cd.c:		change_pwd(1);
./srcs/builtin/cd.c:	}
./srcs/builtin/cd.c:	else if (ft_strcmp("-", tab[1]) == 0)
./srcs/builtin/cd.c:	{
./srcs/builtin/cd.c:		chdir(find_value_envir(g_env, "OLDPWD"));
./srcs/builtin/cd.c:		ft_putendl(find_value_envir(g_env, "OLDPWD"));
./srcs/builtin/cd.c:		change_pwd(0);
./srcs/builtin/cd.c:	}
./srcs/builtin/cd.c:	else if (chdir(tab[1]) == -1)
./srcs/builtin/cd.c:			return (cd_error(tab[1]));
./srcs/builtin/cd.c:	else
./srcs/builtin/cd.c:		change_pwd(0);
./srcs/builtin/cd.c:	return (0);
./srcs/builtin/cd.c:}
Binary file ./srcs/builtin/jobs.o matches
Binary file ./srcs/builtin/no_conf.o matches
./srcs/builtin/exit.c:/* ************************************************************************** */
./srcs/builtin/exit.c:/*                                                                            */
./srcs/builtin/exit.c:/*                                                        :::      ::::::::   */
./srcs/builtin/exit.c:/*   exit.c                                             :+:      :+:    :+:   */
./srcs/builtin/exit.c:/*                                                    +:+ +:+         +:+     */
./srcs/builtin/exit.c:/*   By: aardjoun <marvin@42.fr>                    +#+  +:+       +#+        */
./srcs/builtin/exit.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/builtin/exit.c:/*   Created: 2014/02/18 12:24:55 by aardjoun          #+#    #+#             */
./srcs/builtin/exit.c:/*   Updated: 2014/03/23 15:20:46 by lsolofri         ###   ########.fr       */
./srcs/builtin/exit.c:/*                                                                            */
./srcs/builtin/exit.c:/* ************************************************************************** */
./srcs/builtin/exit.c:
./srcs/builtin/exit.c:#include "../../includes/msh.h"
./srcs/builtin/exit.c:
./srcs/builtin/exit.c:int		search_for_jobs(t_jobs *list)
./srcs/builtin/exit.c:{
./srcs/builtin/exit.c:	int		i;
./srcs/builtin/exit.c:
./srcs/builtin/exit.c:	i = 0;
./srcs/builtin/exit.c:	while (list)
./srcs/builtin/exit.c:	{
./srcs/builtin/exit.c:		list = list->next;
./srcs/builtin/exit.c:		++i;
./srcs/builtin/exit.c:	}
./srcs/builtin/exit.c:	return (i);
./srcs/builtin/exit.c:}
./srcs/builtin/exit.c:
./srcs/builtin/exit.c:void	kill_jobs(t_jobs *list)
./srcs/builtin/exit.c:{
./srcs/builtin/exit.c:	while (list)
./srcs/builtin/exit.c:	{
./srcs/builtin/exit.c:		kill(SIGTERM, list->pid);
./srcs/builtin/exit.c:		list = list->next;
./srcs/builtin/exit.c:	}
./srcs/builtin/exit.c:}
./srcs/builtin/exit.c:
./srcs/builtin/exit.c:int				ft_exit(char **tab)
./srcs/builtin/exit.c:{
./srcs/builtin/exit.c:	int			i;
./srcs/builtin/exit.c:	int			rt;
./srcs/builtin/exit.c:	int			result;
./srcs/builtin/exit.c:	char		*ret = "y";
./srcs/builtin/exit.c:
./srcs/builtin/exit.c:	i = -1;
./srcs/builtin/exit.c:	rt = 0;
./srcs/builtin/exit.c:	result = 0;
./srcs/builtin/exit.c:	while (tab[1] && tab[1][++i] != '\0')
./srcs/builtin/exit.c:	{
./srcs/builtin/exit.c:		if (ft_isdigit(tab[1][i]))
./srcs/builtin/exit.c:			rt = ft_atoi(tab[1]);
./srcs/builtin/exit.c:		else
./srcs/builtin/exit.c:		{
./srcs/builtin/exit.c:			exit_error(tab);
./srcs/builtin/exit.c:			result = 1;
./srcs/builtin/exit.c:			break ;
./srcs/builtin/exit.c:		}
./srcs/builtin/exit.c:	}
./srcs/builtin/exit.c:	if (!result)
./srcs/builtin/exit.c:	{
./srcs/builtin/exit.c:		if (search_for_jobs(g_jobs))
./srcs/builtin/exit.c:		{
./srcs/builtin/exit.c:			ft_putstr("You have unfinished jobs. Exit anyway? (y/n)");
./srcs/builtin/exit.c:			ret = take_cmd(1);
./srcs/builtin/exit.c:		}
./srcs/builtin/exit.c:		if (!ft_strcmp("y", ret))
./srcs/builtin/exit.c:		{
./srcs/builtin/exit.c:			kill_jobs(g_jobs);
./srcs/builtin/exit.c:			ft_gc(NULL, E_GCFREEGC);
./srcs/builtin/exit.c:			ft_putendl("Goodbye!");
./srcs/builtin/exit.c:			_exit(rt);
./srcs/builtin/exit.c:		}
./srcs/builtin/exit.c:	}
./srcs/builtin/exit.c:	return (0);
./srcs/builtin/exit.c:}
./srcs/builtin/alias.c:/* ************************************************************************** */
./srcs/builtin/alias.c:/*                                                                            */
./srcs/builtin/alias.c:/*                                                        :::      ::::::::   */
./srcs/builtin/alias.c:/*   alias.c                                            :+:      :+:    :+:   */
./srcs/builtin/alias.c:/*                                                    +:+ +:+         +:+     */
./srcs/builtin/alias.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/builtin/alias.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/builtin/alias.c:/*   Created: 2014/02/25 04:12:42 by lsolofri          #+#    #+#             */
./srcs/builtin/alias.c:/*   Updated: 2014/03/22 12:20:46 by rkharif          ###   ########.fr       */
./srcs/builtin/alias.c:/*                                                                            */
./srcs/builtin/alias.c:/* ************************************************************************** */
./srcs/builtin/alias.c:
./srcs/builtin/alias.c:#include "../../includes/msh.h"
./srcs/builtin/alias.c:
./srcs/builtin/alias.c:t_alias	*del_alias(t_alias *list, char *name)
./srcs/builtin/alias.c:{
./srcs/builtin/alias.c:	t_alias	*tmp;
./srcs/builtin/alias.c:
./srcs/builtin/alias.c:	if (!list)
./srcs/builtin/alias.c:		return (NULL);
./srcs/builtin/alias.c:	if (!ft_strcmp(list->alias, name))
./srcs/builtin/alias.c:	{
./srcs/builtin/alias.c:		tmp = list->next;
./srcs/builtin/alias.c:		free(list);
./srcs/builtin/alias.c:		tmp = del_alias(tmp, name);
./srcs/builtin/alias.c:		return (tmp);
./srcs/builtin/alias.c:	}
./srcs/builtin/alias.c:	else
./srcs/builtin/alias.c:	{
./srcs/builtin/alias.c:		list->next = del_alias(list->next, name);
./srcs/builtin/alias.c:		return (list);
./srcs/builtin/alias.c:	}
./srcs/builtin/alias.c:}
./srcs/builtin/alias.c:
./srcs/builtin/alias.c:t_alias	*add_alias(t_alias *list, char *alias, char *value)
./srcs/builtin/alias.c:{
./srcs/builtin/alias.c:	t_alias	*tmp;
./srcs/builtin/alias.c:	t_alias	*tmp2;
./srcs/builtin/alias.c:
./srcs/builtin/alias.c:	tmp2 = list;
./srcs/builtin/alias.c:	tmp = (t_alias *)malloc(sizeof(t_alias));
./srcs/builtin/alias.c:	tmp->alias = alias;
./srcs/builtin/alias.c:	tmp->value = value;
./srcs/builtin/alias.c:	tmp->next = NULL;
./srcs/builtin/alias.c:	if (list == NULL)
./srcs/builtin/alias.c:		return (tmp);
./srcs/builtin/alias.c:	while (tmp2->next != NULL)
./srcs/builtin/alias.c:		tmp2 = tmp2->next;
./srcs/builtin/alias.c:	tmp2->next = tmp;
./srcs/builtin/alias.c:	return (list);
./srcs/builtin/alias.c:}
./srcs/builtin/alias.c:
./srcs/builtin/alias.c:char	**is_alias(t_alias *list, char **tab)
./srcs/builtin/alias.c:{
./srcs/builtin/alias.c:	int			i;
./srcs/builtin/alias.c:	t_alias		*tmp;
./srcs/builtin/alias.c:	t_command	*result;
./srcs/builtin/alias.c:
./srcs/builtin/alias.c:	tmp = list;
./srcs/builtin/alias.c:	i = 0;
./srcs/builtin/alias.c:	while (tab[i] != NULL)
./srcs/builtin/alias.c:	{
./srcs/builtin/alias.c:		while (list)
./srcs/builtin/alias.c:		{
./srcs/builtin/alias.c:			if (ft_strcmp(tab[i], list->alias) == 0)
./srcs/builtin/alias.c:			{
./srcs/builtin/alias.c:				result = quick_parse(list->value);
./srcs/builtin/alias.c:				tab = ft_insert_tab(tab, result->cmd, i);
./srcs/builtin/alias.c:			}
./srcs/builtin/alias.c:			list = list->next;
./srcs/builtin/alias.c:		}
./srcs/builtin/alias.c:		list = tmp;
./srcs/builtin/alias.c:		++i;
./srcs/builtin/alias.c:	}
./srcs/builtin/alias.c:	return (tab);
./srcs/builtin/alias.c:}
./srcs/builtin/alias.c:
./srcs/builtin/alias.c:void	show_alias(t_alias *list)
./srcs/builtin/alias.c:{
./srcs/builtin/alias.c:	while (list)
./srcs/builtin/alias.c:	{
./srcs/builtin/alias.c:		ft_putstr(list->alias);
./srcs/builtin/alias.c:		ft_putstr("='");
./srcs/builtin/alias.c:		ft_putstr(list->value);
./srcs/builtin/alias.c:		ft_putendl("'");
./srcs/builtin/alias.c:		list = list->next;
./srcs/builtin/alias.c:	}
./srcs/builtin/alias.c:}
./srcs/builtin/alias.c:
./srcs/builtin/alias.c:void	ft_alias(char **tab)
./srcs/builtin/alias.c:{
./srcs/builtin/alias.c:	if (tab[1] && tab[2])
./srcs/builtin/alias.c:	{
./srcs/builtin/alias.c:		g_alias = del_alias(g_alias, tab[1]);
./srcs/builtin/alias.c:		g_alias = add_alias(g_alias, tab[1], tab[2]);
./srcs/builtin/alias.c:	}
./srcs/builtin/alias.c:	else
./srcs/builtin/alias.c:		show_alias(g_alias);
./srcs/builtin/alias.c:}
Binary file ./srcs/builtin/cd.o matches
Binary file ./srcs/builtin/exit.o matches
./srcs/builtin/jobs.c:/* ************************************************************************** */
./srcs/builtin/jobs.c:/*                                                                            */
./srcs/builtin/jobs.c:/*                                                        :::      ::::::::   */
./srcs/builtin/jobs.c:/*   jobs.c                                             :+:      :+:    :+:   */
./srcs/builtin/jobs.c:/*                                                    +:+ +:+         +:+     */
./srcs/builtin/jobs.c:/*   By: aardjoun <aardjoun@student.42.fr>          +#+  +:+       +#+        */
./srcs/builtin/jobs.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/builtin/jobs.c:/*   Created: 2014/02/28 15:18:15 by aardjoun          #+#    #+#             */
./srcs/builtin/jobs.c:/*   Updated: 2014/03/23 17:53:13 by lsolofri         ###   ########.fr       */
./srcs/builtin/jobs.c:/*                                                                            */
./srcs/builtin/jobs.c:/* ************************************************************************** */
./srcs/builtin/jobs.c:
./srcs/builtin/jobs.c:#include "../../includes/msh.h"
./srcs/builtin/jobs.c:
./srcs/builtin/jobs.c:int		search_jobs(t_jobs *list, int pid)
./srcs/builtin/jobs.c:{
./srcs/builtin/jobs.c:	t_jobs		*tmp;
./srcs/builtin/jobs.c:
./srcs/builtin/jobs.c:	tmp = g_jobs;
./srcs/builtin/jobs.c:	if (list)
./srcs/builtin/jobs.c:	{
./srcs/builtin/jobs.c:			while (tmp && tmp->pid != pid)
./srcs/builtin/jobs.c:				tmp = tmp->next;
./srcs/builtin/jobs.c:		if (tmp)
./srcs/builtin/jobs.c:			return (tmp->pid);
./srcs/builtin/jobs.c:		else
./srcs/builtin/jobs.c:			return (0);
./srcs/builtin/jobs.c:	}
./srcs/builtin/jobs.c:	return (0);
./srcs/builtin/jobs.c:}
./srcs/builtin/jobs.c:
./srcs/builtin/jobs.c:void		fg_bg(t_jobs *jobs, char **tab, int k)
./srcs/builtin/jobs.c:{
./srcs/builtin/jobs.c:	int		ret;
./srcs/builtin/jobs.c:	int		i;
./srcs/builtin/jobs.c:	int		pid;
./srcs/builtin/jobs.c:
./srcs/builtin/jobs.c:	ret = 0;
./srcs/builtin/jobs.c:	i = 0;
./srcs/builtin/jobs.c:	if (jobs == NULL)
./srcs/builtin/jobs.c:	{
./srcs/builtin/jobs.c:		job_error(k);
./srcs/builtin/jobs.c:		return ;
./srcs/builtin/jobs.c:	}
./srcs/builtin/jobs.c:	if (tab[1])
./srcs/builtin/jobs.c:	{
./srcs/builtin/jobs.c:		while (tab[1][i])
./srcs/builtin/jobs.c:		{
./srcs/builtin/jobs.c:			if (!ft_isdigit(tab[1][i]))
./srcs/builtin/jobs.c:				ret = 1;
./srcs/builtin/jobs.c:			++i;
./srcs/builtin/jobs.c:		}
./srcs/builtin/jobs.c:		if (ret == 1)
./srcs/builtin/jobs.c:		{
./srcs/builtin/jobs.c:			pid_error(tab[1]);
./srcs/builtin/jobs.c:			return ;
./srcs/builtin/jobs.c:		}
./srcs/builtin/jobs.c:		else
./srcs/builtin/jobs.c:			pid = search_jobs(g_jobs, ft_atoi(tab[1]));
./srcs/builtin/jobs.c:	}
./srcs/builtin/jobs.c:	else
./srcs/builtin/jobs.c:	{
./srcs/builtin/jobs.c:		while (jobs->next != NULL)
./srcs/builtin/jobs.c:			jobs = jobs->next;
./srcs/builtin/jobs.c:		pid = jobs->pid;
./srcs/builtin/jobs.c:	}
./srcs/builtin/jobs.c:	if (pid == 0)
./srcs/builtin/jobs.c:	{
./srcs/builtin/jobs.c:		pid_error(tab[1]);
./srcs/builtin/jobs.c:		return ;
./srcs/builtin/jobs.c:	}
./srcs/builtin/jobs.c:	ft_putstr("[");
./srcs/builtin/jobs.c:	ft_putnbr(jobs->job);
./srcs/builtin/jobs.c:	ft_putstr("]");
./srcs/builtin/jobs.c:	ft_putstr(" + ");
./srcs/builtin/jobs.c:	ft_putstr("continued\t\t");
./srcs/builtin/jobs.c:	ft_putendl(jobs->name);
./srcs/builtin/jobs.c:	kill(pid, SIGCONT);
./srcs/builtin/jobs.c:	if (k == 1)
./srcs/builtin/jobs.c:		waitpid(pid, &ret, WUNTRACED);
./srcs/builtin/jobs.c:	check_return(ret, pid);
./srcs/builtin/jobs.c:}
./srcs/builtin/variable.c:/* ************************************************************************** */
./srcs/builtin/variable.c:/*                                                                            */
./srcs/builtin/variable.c:/*                                                        :::      ::::::::   */
./srcs/builtin/variable.c:/*   variable.c                                         :+:      :+:    :+:   */
./srcs/builtin/variable.c:/*                                                    +:+ +:+         +:+     */
./srcs/builtin/variable.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/builtin/variable.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/builtin/variable.c:/*   Created: 2014/02/28 12:47:27 by lsolofri          #+#    #+#             */
./srcs/builtin/variable.c:/*   Updated: 2014/03/23 14:54:22 by lsolofri         ###   ########.fr       */
./srcs/builtin/variable.c:/*                                                                            */
./srcs/builtin/variable.c:/* ************************************************************************** */
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:#include "../../includes/msh.h"
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:t_var	*del_var(t_var *list, char *name)
./srcs/builtin/variable.c:{
./srcs/builtin/variable.c:	t_var	*tmp;
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:	if (!list)
./srcs/builtin/variable.c:		return (NULL);
./srcs/builtin/variable.c:	if (!ft_strcmp(list->name, name))
./srcs/builtin/variable.c:	{
./srcs/builtin/variable.c:		tmp = list->next;
./srcs/builtin/variable.c:		list = NULL;
./srcs/builtin/variable.c:		tmp = del_var(tmp, name);
./srcs/builtin/variable.c:	}
./srcs/builtin/variable.c:	else
./srcs/builtin/variable.c:		list->next = del_var(list->next, name);
./srcs/builtin/variable.c:	return (list);
./srcs/builtin/variable.c:}
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:t_var	*add_var(t_var *list, char *name, char *value)
./srcs/builtin/variable.c:{
./srcs/builtin/variable.c:	t_var	*tmp;
./srcs/builtin/variable.c:	t_var	*tmp2;
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:	tmp2 = list;
./srcs/builtin/variable.c:	tmp = (t_var *)ft_memalloc(sizeof(t_alias));
./srcs/builtin/variable.c:	tmp->name = name;
./srcs/builtin/variable.c:	tmp->value = value;
./srcs/builtin/variable.c:	tmp->next = NULL;
./srcs/builtin/variable.c:	if (list == NULL)
./srcs/builtin/variable.c:		return (tmp);
./srcs/builtin/variable.c:	while (tmp2->next != NULL)
./srcs/builtin/variable.c:		tmp2 = tmp2->next;
./srcs/builtin/variable.c:	tmp2->next = tmp;
./srcs/builtin/variable.c:	return (list);
./srcs/builtin/variable.c:}
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:void	ft_set(char **tab)
./srcs/builtin/variable.c:{
./srcs/builtin/variable.c:	if (tab[1])
./srcs/builtin/variable.c:	{
./srcs/builtin/variable.c:		if (tab[2])
./srcs/builtin/variable.c:			set_var(tab[1], tab[2]);
./srcs/builtin/variable.c:		else
./srcs/builtin/variable.c:			ft_putendl("Missing one argument!");
./srcs/builtin/variable.c:	}
./srcs/builtin/variable.c:	else
./srcs/builtin/variable.c:	{
./srcs/builtin/variable.c:		print_list(g_env);
./srcs/builtin/variable.c:		if (g_var)
./srcs/builtin/variable.c:			show_var(g_var);
./srcs/builtin/variable.c:	}
./srcs/builtin/variable.c:}
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:void	set_var(char *name, char *value)
./srcs/builtin/variable.c:{
./srcs/builtin/variable.c:	char	*tmp;
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:	if (find_value_envir(g_env, name))
./srcs/builtin/variable.c:	{
./srcs/builtin/variable.c:		ft_putstr("set: Tried to change the read-only variable: ");
./srcs/builtin/variable.c:		ft_putstr(name);
./srcs/builtin/variable.c:		ft_putendl(". (Use setenv for change environnement variable)");
./srcs/builtin/variable.c:	}
./srcs/builtin/variable.c:	else
./srcs/builtin/variable.c:	{
./srcs/builtin/variable.c:		tmp = name;
./srcs/builtin/variable.c:		while (*name)
./srcs/builtin/variable.c:		{
./srcs/builtin/variable.c:			if (!ft_isalpha(*name))
./srcs/builtin/variable.c:			{
./srcs/builtin/variable.c:				show_error("Bad variable name");
./srcs/builtin/variable.c:				return ;
./srcs/builtin/variable.c:			}
./srcs/builtin/variable.c:			name++;
./srcs/builtin/variable.c:		}
./srcs/builtin/variable.c:		name = tmp;
./srcs/builtin/variable.c:		g_var = del_var(g_var, name);
./srcs/builtin/variable.c:		g_var = add_var(g_var, name, value);
./srcs/builtin/variable.c:	}
./srcs/builtin/variable.c:}
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:void	unset_var(char *name)
./srcs/builtin/variable.c:{
./srcs/builtin/variable.c:	g_var = del_var(g_var, name);
./srcs/builtin/variable.c:}
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:void	show_var(t_var *list)
./srcs/builtin/variable.c:{
./srcs/builtin/variable.c:	while (list)
./srcs/builtin/variable.c:	{
./srcs/builtin/variable.c:		ft_putstr(list->name);
./srcs/builtin/variable.c:		ft_putstr("=");
./srcs/builtin/variable.c:		ft_putendl(list->value);
./srcs/builtin/variable.c:		list = list->next;
./srcs/builtin/variable.c:	}
./srcs/builtin/variable.c:}
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:char	*search_var(t_var *list, char *name)
./srcs/builtin/variable.c:{
./srcs/builtin/variable.c:	char	*result;
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:	result = find_value_envir(g_env, name);
./srcs/builtin/variable.c:	if (!result)
./srcs/builtin/variable.c:	{
./srcs/builtin/variable.c:		while (list && ft_strcmp(list->name, name))
./srcs/builtin/variable.c:			list = list->next;
./srcs/builtin/variable.c:		if (list)
./srcs/builtin/variable.c:			result = ft_strdup(list->value);
./srcs/builtin/variable.c:	}
./srcs/builtin/variable.c:	return (result);
./srcs/builtin/variable.c:}
./srcs/builtin/variable.c:
./srcs/builtin/variable.c:void	export_var(t_var *list, char *name)
./srcs/builtin/variable.c:{
./srcs/builtin/variable.c:	while (list && ft_strcmp(list->name, name))
./srcs/builtin/variable.c:		list = list->next;
./srcs/builtin/variable.c:	if (list)
./srcs/builtin/variable.c:		g_env = ft_setenv(g_env, name, list->value);
./srcs/builtin/variable.c:	else
./srcs/builtin/variable.c:	{
./srcs/builtin/variable.c:		ft_putstr("Cannot find variable ");
./srcs/builtin/variable.c:		ft_putendl(name);
./srcs/builtin/variable.c:	}
./srcs/builtin/variable.c:}
Binary file ./srcs/builtin/echo.o matches
Binary file ./srcs/builtin/variable.o matches
Binary file ./srcs/builtin/conf.o matches
Binary file ./srcs/builtin/alias.o matches
./srcs/builtin/echo.c:/* ************************************************************************** */
./srcs/builtin/echo.c:/*                                                                            */
./srcs/builtin/echo.c:/*                                                        :::      ::::::::   */
./srcs/builtin/echo.c:/*   echo.c                                             :+:      :+:    :+:   */
./srcs/builtin/echo.c:/*                                                    +:+ +:+         +:+     */
./srcs/builtin/echo.c:/*   By: aardjoun <marvin@42.fr>                    +#+  +:+       +#+        */
./srcs/builtin/echo.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/builtin/echo.c:/*   Created: 2014/02/17 12:02:30 by aardjoun          #+#    #+#             */
./srcs/builtin/echo.c:/*   Updated: 2014/03/05 10:31:33 by lsolofri         ###   ########.fr       */
./srcs/builtin/echo.c:/*                                                                            */
./srcs/builtin/echo.c:/* ************************************************************************** */
./srcs/builtin/echo.c:
./srcs/builtin/echo.c:#include "../../includes/msh.h"
./srcs/builtin/echo.c:
./srcs/builtin/echo.c:static int		check_option(char **tab)
./srcs/builtin/echo.c:{
./srcs/builtin/echo.c:	int			opt;
./srcs/builtin/echo.c:	int			i;
./srcs/builtin/echo.c:	int			j;
./srcs/builtin/echo.c:
./srcs/builtin/echo.c:	i = 0;
./srcs/builtin/echo.c:	opt = 0;
./srcs/builtin/echo.c:	while (tab[++i] && (ft_strncmp(tab[i], "-", 1) == 0))
./srcs/builtin/echo.c:	{
./srcs/builtin/echo.c:		j = 0;
./srcs/builtin/echo.c:		while (tab[i][j])
./srcs/builtin/echo.c:		{
./srcs/builtin/echo.c:			if (opt == 3)
./srcs/builtin/echo.c:				break ;
./srcs/builtin/echo.c:			if (tab[i][j] == 's' && tab[i][j + 1] == '\0')
./srcs/builtin/echo.c:				opt = ((opt == 2) ? 3 : 1);
./srcs/builtin/echo.c:			if (tab[i][j] == 'n' && tab[i][j + 1] == '\0')
./srcs/builtin/echo.c:				opt = ((opt == 1) ? 3 : 2);
./srcs/builtin/echo.c:			if (tab[i][j] == 'n' && tab[i][j + 1] == 's')
./srcs/builtin/echo.c:				opt = 3;
./srcs/builtin/echo.c:			if (tab[i][j] == 's' && tab[i][j + 1] == 'n')
./srcs/builtin/echo.c:				opt = 3;
./srcs/builtin/echo.c:			j++;
./srcs/builtin/echo.c:		}
./srcs/builtin/echo.c:	}
./srcs/builtin/echo.c:	return (opt);
./srcs/builtin/echo.c:}
./srcs/builtin/echo.c:
./srcs/builtin/echo.c:static void		ft_print_tab(char **tab, int i, int nb, int k)
./srcs/builtin/echo.c:{
./srcs/builtin/echo.c:	while (i < nb && tab[i] && ft_strcmp(tab[i], "|"))
./srcs/builtin/echo.c:	{
./srcs/builtin/echo.c:			ft_putstr(tab[i]);
./srcs/builtin/echo.c:		if ((k == 0 || k == 2) && i < (nb - 1))
./srcs/builtin/echo.c:			ft_putchar(' ');
./srcs/builtin/echo.c:		i++;
./srcs/builtin/echo.c:	}
./srcs/builtin/echo.c:}
./srcs/builtin/echo.c:
./srcs/builtin/echo.c:void			ft_echo(char **tab)
./srcs/builtin/echo.c:{
./srcs/builtin/echo.c:	int			nb;
./srcs/builtin/echo.c:	int			i;
./srcs/builtin/echo.c:	int			opt;
./srcs/builtin/echo.c:
./srcs/builtin/echo.c:	opt = check_option(tab);
./srcs/builtin/echo.c:	nb = ft_tablen(tab);
./srcs/builtin/echo.c:	i = 1;
./srcs/builtin/echo.c:	while (ft_strncmp(tab[i], "-", 1) == 0)
./srcs/builtin/echo.c:		i++;
./srcs/builtin/echo.c:	ft_print_tab(tab, i, nb, opt);
./srcs/builtin/echo.c:	i = 1;
./srcs/builtin/echo.c:	if (opt == 2 || opt == 3)
./srcs/builtin/echo.c:		return ;
./srcs/builtin/echo.c:	ft_putchar('\n');
./srcs/builtin/echo.c:}
./srcs/builtin/conf.c:/* ************************************************************************** */
./srcs/builtin/conf.c:/*                                                                            */
./srcs/builtin/conf.c:/*                                                        :::      ::::::::   */
./srcs/builtin/conf.c:/*   conf.c                                             :+:      :+:    :+:   */
./srcs/builtin/conf.c:/*                                                    +:+ +:+         +:+     */
./srcs/builtin/conf.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/builtin/conf.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/builtin/conf.c:/*   Created: 2014/02/25 02:38:17 by lsolofri          #+#    #+#             */
./srcs/builtin/conf.c:/*   Updated: 2014/03/13 12:29:22 by lsolofri         ###   ########.fr       */
./srcs/builtin/conf.c:/*                                                                            */
./srcs/builtin/conf.c:/* ************************************************************************** */
./srcs/builtin/conf.c:
./srcs/builtin/conf.c:#include "../../includes/msh.h"
./srcs/builtin/conf.c:
./srcs/builtin/conf.c:void	load_conf_file(void)
./srcs/builtin/conf.c:{
./srcs/builtin/conf.c:	int		fd;
./srcs/builtin/conf.c:	char	*tmp;
./srcs/builtin/conf.c:
./srcs/builtin/conf.c:	tmp = ft_strjoin(find_value_envir(g_env, "HOME"), "/.mshrc");
./srcs/builtin/conf.c:	fd = open(tmp, O_RDONLY);
./srcs/builtin/conf.c:	if (fd == -1)
./srcs/builtin/conf.c:	{
./srcs/builtin/conf.c:		no_conf();
./srcs/builtin/conf.c:		return ;
./srcs/builtin/conf.c:	}
./srcs/builtin/conf.c:	while ((tmp = get_next_line(fd)))
./srcs/builtin/conf.c:		pre_exec(tmp);
./srcs/builtin/conf.c:}
./srcs/read/termcap.c:/* ************************************************************************** */
./srcs/read/termcap.c:/*                                                                            */
./srcs/read/termcap.c:/*                                                        :::      ::::::::   */
./srcs/read/termcap.c:/*   termcap.c                                          :+:      :+:    :+:   */
./srcs/read/termcap.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/termcap.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/termcap.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/termcap.c:/*   Created: 2014/02/11 15:00:24 by lsolofri          #+#    #+#             */
./srcs/read/termcap.c:/*   Updated: 2014/03/23 14:27:50 by lsolofri         ###   ########.fr       */
./srcs/read/termcap.c:/*                                                                            */
./srcs/read/termcap.c:/* ************************************************************************** */
./srcs/read/termcap.c:
./srcs/read/termcap.c:#include "../../includes/msh.h"
./srcs/read/termcap.c:
./srcs/read/termcap.c:void	init_flag(struct termios *term)
./srcs/read/termcap.c:{
./srcs/read/termcap.c:	char	*name_term;
./srcs/read/termcap.c:
./srcs/read/termcap.c:	name_term = find_value_envir(g_env, "TERM");
./srcs/read/termcap.c:	if (!name_term)
./srcs/read/termcap.c:		show_error_exit("No Environnement TERM variables");
./srcs/read/termcap.c:	if (!tgetent(NULL, name_term))
./srcs/read/termcap.c:		show_error_exit("System call: tgetent fail");
./srcs/read/termcap.c:	tcgetattr(0, term);
./srcs/read/termcap.c:	term->c_lflag &= ~(ICANON);
./srcs/read/termcap.c:	term->c_lflag &= ~(ECHO);
./srcs/read/termcap.c:	term->c_cc[VMIN] = 1;
./srcs/read/termcap.c:	term->c_cc[VTIME] = 0;
./srcs/read/termcap.c:	tcsetattr(0, 0, term);
./srcs/read/termcap.c:}
./srcs/read/termcap.c:
./srcs/read/termcap.c:void	re_flag(struct termios *term)
./srcs/read/termcap.c:{
./srcs/read/termcap.c:	char	*name_term;
./srcs/read/termcap.c:
./srcs/read/termcap.c:	name_term = find_value_envir(g_env, "TERM");
./srcs/read/termcap.c:	if (!name_term)
./srcs/read/termcap.c:		show_error_exit("No Environnement TERM variables");
./srcs/read/termcap.c:	if (!tgetent(NULL, name_term))
./srcs/read/termcap.c:		show_error_exit("System call: tgetent fail");
./srcs/read/termcap.c:	tcgetattr(0, term);
./srcs/read/termcap.c:	term->c_lflag |= ICANON;
./srcs/read/termcap.c:	term->c_lflag |= ECHO;
./srcs/read/termcap.c:	tcsetattr(0, 0, term);
./srcs/read/termcap.c:}
./srcs/read/termcap.c:
./srcs/read/termcap.c:char	*init_buffer(char *buffer)
./srcs/read/termcap.c:{
./srcs/read/termcap.c:	int		i;
./srcs/read/termcap.c:
./srcs/read/termcap.c:	i = 0;
./srcs/read/termcap.c:	while (buffer[i])
./srcs/read/termcap.c:		buffer[i++] = 0;
./srcs/read/termcap.c:	return (buffer);
./srcs/read/termcap.c:}
./srcs/read/termcap.c:
./srcs/read/termcap.c:char	*char_to_string(char c)
./srcs/read/termcap.c:{
./srcs/read/termcap.c:	char	*result;
./srcs/read/termcap.c:
./srcs/read/termcap.c:	result = (char *)ft_memalloc(sizeof(char) * 1);
./srcs/read/termcap.c:	result[0] = c;
./srcs/read/termcap.c:	result[1] = '\0';
./srcs/read/termcap.c:	return (result);
./srcs/read/termcap.c:}
./srcs/read/autocomplete.c:/* ************************************************************************** */
./srcs/read/autocomplete.c:/*                                                                            */
./srcs/read/autocomplete.c:/*                                                        :::      ::::::::   */
./srcs/read/autocomplete.c:/*   autocomplete.c                                     :+:      :+:    :+:   */
./srcs/read/autocomplete.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/autocomplete.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/autocomplete.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/autocomplete.c:/*   Created: 2014/02/14 14:15:21 by lsolofri          #+#    #+#             */
./srcs/read/autocomplete.c:/*   Updated: 2014/03/22 13:44:37 by lsolofri         ###   ########.fr       */
./srcs/read/autocomplete.c:/*                                                                            */
./srcs/read/autocomplete.c:/* ************************************************************************** */
./srcs/read/autocomplete.c:
./srcs/read/autocomplete.c:#include "../../includes/msh.h"
./srcs/read/autocomplete.c:
./srcs/read/autocomplete.c:
./srcs/read/autocomplete.c:void	show_complete(char *str, char *cmd)
./srcs/read/autocomplete.c:{
./srcs/read/autocomplete.c:	ft_putstr(GRAY);
./srcs/read/autocomplete.c:	ft_putstr(tgetstr("sc", NULL));
./srcs/read/autocomplete.c:	if (ft_strcmp(str, ""))
./srcs/read/autocomplete.c:		ft_putstr(ft_strsub(str, ft_strlen(cmd), ft_strlen(str)));
./srcs/read/autocomplete.c:	ft_putstr(tgetstr("rc", NULL));
./srcs/read/autocomplete.c:	ft_putstr(DEF);
./srcs/read/autocomplete.c:}
./srcs/read/autocomplete.c:
./srcs/read/autocomplete.c:void	show_options(char c)
./srcs/read/autocomplete.c:{
./srcs/read/autocomplete.c:	ft_putstr(GRAY);
./srcs/read/autocomplete.c:	ft_putstr(tgetstr("sc", NULL));
./srcs/read/autocomplete.c:	ft_putchar(c);
./srcs/read/autocomplete.c:	ft_putstr(tgetstr("rc", NULL));
./srcs/read/autocomplete.c:	ft_putstr(DEF);
./srcs/read/autocomplete.c:}
./srcs/read/autocomplete.c:
./srcs/read/autocomplete.c:void	show_options_in_line(char *cmd)
./srcs/read/autocomplete.c:{
./srcs/read/autocomplete.c:	char        **path;
./srcs/read/autocomplete.c:	char        *man_path;
./srcs/read/autocomplete.c:	char        man[] = "man1/";
./srcs/read/autocomplete.c:
./srcs/read/autocomplete.c:	path = ft_strsplit(find_value_envir(g_env, "MANPATH"), ':');
./srcs/read/autocomplete.c:	while (*path)
./srcs/read/autocomplete.c:	{
./srcs/read/autocomplete.c:		man[3] = '1';
./srcs/read/autocomplete.c:		while (man[3] != '9')
./srcs/read/autocomplete.c:		{
./srcs/read/autocomplete.c:			man_path = ft_strjoin(*path, ft_strjoin("/", ft_strjoin(man,
./srcs/read/autocomplete.c:							ft_strjoin(cmd, ft_strjoin(".",
./srcs/read/autocomplete.c:									char_to_string(man[3]))))));
./srcs/read/autocomplete.c:			if (access(man_path, F_OK) != -1)
./srcs/read/autocomplete.c:			{
./srcs/read/autocomplete.c:				if (get_options(open(man_path, O_RDONLY)))
./srcs/read/autocomplete.c:				{
./srcs/read/autocomplete.c:					ft_putstr(tgetstr("sc", NULL));
./srcs/read/autocomplete.c:					ft_putstr(GRAY);
./srcs/read/autocomplete.c:					ft_putstr(" -");
./srcs/read/autocomplete.c:					ft_putstr(get_options(open(man_path, O_RDONLY)));
./srcs/read/autocomplete.c:					ft_putstr(DEF);
./srcs/read/autocomplete.c:					ft_putstr(tgetstr("rc", NULL));	
./srcs/read/autocomplete.c:				}
./srcs/read/autocomplete.c:			}
./srcs/read/autocomplete.c:			man[3]++;
./srcs/read/autocomplete.c:		}
./srcs/read/autocomplete.c:		path++;
./srcs/read/autocomplete.c:	}
./srcs/read/autocomplete.c:}
./srcs/read/buttons.c:/* ************************************************************************** */
./srcs/read/buttons.c:/*                                                                            */
./srcs/read/buttons.c:/*                                                        :::      ::::::::   */
./srcs/read/buttons.c:/*   buttons.c                                          :+:      :+:    :+:   */
./srcs/read/buttons.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/buttons.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/buttons.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/buttons.c:/*   Created: 2014/02/11 17:24:20 by lsolofri          #+#    #+#             */
./srcs/read/buttons.c:/*   Updated: 2014/03/05 13:46:12 by lsolofri         ###   ########.fr       */
./srcs/read/buttons.c:/*                                                                            */
./srcs/read/buttons.c:/* ************************************************************************** */
./srcs/read/buttons.c:
./srcs/read/buttons.c:#include "../../includes/msh.h"
./srcs/read/buttons.c:
./srcs/read/buttons.c:int		a_right(int i, int len)
./srcs/read/buttons.c:{
./srcs/read/buttons.c:	if (i < len)
./srcs/read/buttons.c:	{
./srcs/read/buttons.c:		ft_putstr(tgetstr("nd", NULL));
./srcs/read/buttons.c:		++i;
./srcs/read/buttons.c:	}
./srcs/read/buttons.c:	return (i);
./srcs/read/buttons.c:}
./srcs/read/buttons.c:
./srcs/read/buttons.c:int		a_left(int i, int len)
./srcs/read/buttons.c:{
./srcs/read/buttons.c:	(void)len;
./srcs/read/buttons.c:	if (i > 0)
./srcs/read/buttons.c:	{
./srcs/read/buttons.c:		ft_putstr(tgetstr("le", NULL));
./srcs/read/buttons.c:		--i;
./srcs/read/buttons.c:	}
./srcs/read/buttons.c:	return (i);
./srcs/read/buttons.c:}
./srcs/read/buttons.c:
./srcs/read/buttons.c:void	clear_line(int i, int v)
./srcs/read/buttons.c:{
./srcs/read/buttons.c:	(void)v;
./srcs/read/buttons.c:	while (i > 1)
./srcs/read/buttons.c:	{
./srcs/read/buttons.c:		ft_putstr(tgetstr("le", NULL));
./srcs/read/buttons.c:		--i;
./srcs/read/buttons.c:	}
./srcs/read/buttons.c:	ft_putstr(tgetstr("ce", NULL));
./srcs/read/buttons.c:}
./srcs/read/buttons.c:
./srcs/read/buttons.c:void	replace_cursor(int i, int v)
./srcs/read/buttons.c:{
./srcs/read/buttons.c:	while (v > i)
./srcs/read/buttons.c:	{
./srcs/read/buttons.c:		ft_putstr(tgetstr("le", NULL));
./srcs/read/buttons.c:		--v;
./srcs/read/buttons.c:	}
./srcs/read/buttons.c:}
./srcs/read/buttons.c:
./srcs/read/buttons.c:int		arrow(int i, char key, int len, char **result)
./srcs/read/buttons.c:{
./srcs/read/buttons.c:	if (key == 65)
./srcs/read/buttons.c:	{
./srcs/read/buttons.c:		if (result)
./srcs/read/buttons.c:			clear_line(i + 1, ft_strlen(*result));
./srcs/read/buttons.c:		*result = history(1, NULL);
./srcs/read/buttons.c:		if (*result)
./srcs/read/buttons.c:		{
./srcs/read/buttons.c:			i = ft_strlen(*result);
./srcs/read/buttons.c:			ft_putstr(*result);
./srcs/read/buttons.c:			ft_putstr(tgetstr("le", NULL));
./srcs/read/buttons.c:		}
./srcs/read/buttons.c:	}
./srcs/read/buttons.c:	else if (key == 66)
./srcs/read/buttons.c:	{
./srcs/read/buttons.c:		if (result)
./srcs/read/buttons.c:			clear_line(i + 1, ft_strlen(*result));
./srcs/read/buttons.c:		*result = history(2, NULL);	
./srcs/read/buttons.c:		if (*result)
./srcs/read/buttons.c:		{
./srcs/read/buttons.c:			i = ft_strlen(*result);
./srcs/read/buttons.c:			ft_putstr(*result);	
./srcs/read/buttons.c:			ft_putstr(tgetstr("le", NULL));
./srcs/read/buttons.c:		}
./srcs/read/buttons.c:	}
./srcs/read/buttons.c:	else if (key == 67)
./srcs/read/buttons.c:		i = a_right(i, len);
./srcs/read/buttons.c:	else if (key == 68)
./srcs/read/buttons.c:		i = a_left(i, len);
./srcs/read/buttons.c:	return (i);
./srcs/read/buttons.c:}
./srcs/read/syntax_color.c:/* ************************************************************************** */
./srcs/read/syntax_color.c:/*                                                                            */
./srcs/read/syntax_color.c:/*                                                        :::      ::::::::   */
./srcs/read/syntax_color.c:/*   syntax_color.c                                     :+:      :+:    :+:   */
./srcs/read/syntax_color.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/syntax_color.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/syntax_color.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/syntax_color.c:/*   Created: 2014/02/14 10:04:42 by lsolofri          #+#    #+#             */
./srcs/read/syntax_color.c:/*   Updated: 2014/03/23 19:21:31 by lsolofri         ###   ########.fr       */
./srcs/read/syntax_color.c:/*                                                                            */
./srcs/read/syntax_color.c:/* ************************************************************************** */
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:#include "../../includes/msh.h"
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:t_list	*add_type(t_list *list, char *str, char *type)
./srcs/read/syntax_color.c:{
./srcs/read/syntax_color.c:	t_list	*tmp;
./srcs/read/syntax_color.c:	t_list	*temp;
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:	temp = list;
./srcs/read/syntax_color.c:	tmp = ft_memalloc(sizeof(t_list));
./srcs/read/syntax_color.c:	tmp->name = ft_strdup(str);
./srcs/read/syntax_color.c:	if (type)
./srcs/read/syntax_color.c:		tmp->type = ft_strdup(type);
./srcs/read/syntax_color.c:	else
./srcs/read/syntax_color.c:		tmp->type = NULL;
./srcs/read/syntax_color.c:	tmp->next = NULL;
./srcs/read/syntax_color.c:	if (list == NULL)
./srcs/read/syntax_color.c:		return (tmp);
./srcs/read/syntax_color.c:	else
./srcs/read/syntax_color.c:	{
./srcs/read/syntax_color.c:		while (temp->next != NULL)
./srcs/read/syntax_color.c:			temp = temp->next;
./srcs/read/syntax_color.c:		temp->next = tmp;
./srcs/read/syntax_color.c:	}
./srcs/read/syntax_color.c:	return (list);
./srcs/read/syntax_color.c:}
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:int		check_builtins_and_alias(char *str)
./srcs/read/syntax_color.c:{
./srcs/read/syntax_color.c:	char	*builtins[] = {"exit", "setenv", "unsetenv", "cd", "env", "set",
./srcs/read/syntax_color.c:								"unset", "export", "alias", "jobs", "q", NULL};
./srcs/read/syntax_color.c:	int		result;
./srcs/read/syntax_color.c:	int		i;
./srcs/read/syntax_color.c:	t_alias	*list;
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:	result = 0;
./srcs/read/syntax_color.c:	list = g_alias;
./srcs/read/syntax_color.c:	i = 0;
./srcs/read/syntax_color.c:	while (builtins[i])
./srcs/read/syntax_color.c:	{
./srcs/read/syntax_color.c:		if (!ft_strcmp(str, builtins[i]))
./srcs/read/syntax_color.c:			result = 1;
./srcs/read/syntax_color.c:		i++;
./srcs/read/syntax_color.c:	}
./srcs/read/syntax_color.c:	while (list)
./srcs/read/syntax_color.c:	{
./srcs/read/syntax_color.c:		if (!ft_strcmp(str, list->alias))
./srcs/read/syntax_color.c:			result = 1;
./srcs/read/syntax_color.c:		list = list->next;
./srcs/read/syntax_color.c:	}
./srcs/read/syntax_color.c:	return (result);
./srcs/read/syntax_color.c:}
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:int		check_prog(char *str)
./srcs/read/syntax_color.c:{
./srcs/read/syntax_color.c:	int		i;
./srcs/read/syntax_color.c:	DIR		*rep;
./srcs/read/syntax_color.c:	struct dirent	*show;
./srcs/read/syntax_color.c:	char	**tab;
./srcs/read/syntax_color.c:	int		result;
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:	result = 0;
./srcs/read/syntax_color.c:	tab = ft_strsplit(find_value_envir(g_env, "PATH"), ':');
./srcs/read/syntax_color.c:	i = 0;
./srcs/read/syntax_color.c:	if (check_builtins_and_alias(str))
./srcs/read/syntax_color.c:		return (1);
./srcs/read/syntax_color.c:	if (!access(str, X_OK))
./srcs/read/syntax_color.c:		return (1);
./srcs/read/syntax_color.c:	while (tab[i])
./srcs/read/syntax_color.c:	{
./srcs/read/syntax_color.c:		rep = opendir(tab[i]);
./srcs/read/syntax_color.c:		++i;
./srcs/read/syntax_color.c:		if (rep)
./srcs/read/syntax_color.c:		{
./srcs/read/syntax_color.c:			while ((show = readdir(rep)))
./srcs/read/syntax_color.c:			{
./srcs/read/syntax_color.c:				if (show)
./srcs/read/syntax_color.c:				{
./srcs/read/syntax_color.c:					if (ft_strcmp(str, show->d_name) == 0)
./srcs/read/syntax_color.c:						result = 1;
./srcs/read/syntax_color.c:				}
./srcs/read/syntax_color.c:			}
./srcs/read/syntax_color.c:			closedir(rep);
./srcs/read/syntax_color.c:		}
./srcs/read/syntax_color.c:	}
./srcs/read/syntax_color.c:	return (result);
./srcs/read/syntax_color.c:}
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:t_list	*recup_prog(char *str, char **tab, t_list *list)
./srcs/read/syntax_color.c:{
./srcs/read/syntax_color.c:	int		i;
./srcs/read/syntax_color.c:	DIR		*rep;
./srcs/read/syntax_color.c:	struct dirent	*show;
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:	i = 0;
./srcs/read/syntax_color.c:	if (ft_strncmp(str, "exit", ft_strlen(str)) == 0)
./srcs/read/syntax_color.c:				list = add_type(list, "exit", "Builtin");
./srcs/read/syntax_color.c:	else if (ft_strncmp(str, "setenv", ft_strlen(str)) == 0)
./srcs/read/syntax_color.c:				list = add_type(list, "setenv", "Builtin");
./srcs/read/syntax_color.c:	else if (ft_strncmp(str, "unsetenv", ft_strlen(str)) == 0)
./srcs/read/syntax_color.c:				list = add_type(list, "unsetenv", "Builtin");
./srcs/read/syntax_color.c:	else if (ft_strncmp(str, "cd", ft_strlen(str)) == 0)
./srcs/read/syntax_color.c:				list = add_type(list, "cd", "Builtin");
./srcs/read/syntax_color.c:	else if (ft_strncmp(str, "env", ft_strlen(str)) == 0)
./srcs/read/syntax_color.c:				list = add_type(list, "env", "Builtin");
./srcs/read/syntax_color.c:	else if (ft_strncmp(str, "set", ft_strlen(str)) == 0)
./srcs/read/syntax_color.c:				list = add_type(list, "set", "Builtin");
./srcs/read/syntax_color.c:	else if (ft_strncmp(str, "unset", ft_strlen(str)) == 0)
./srcs/read/syntax_color.c:				list = add_type(list, "unset", "Builtin");
./srcs/read/syntax_color.c:	else if (ft_strncmp(str, "export", ft_strlen(str)) == 0)
./srcs/read/syntax_color.c:				list = add_type(list, "export", "Builtin");
./srcs/read/syntax_color.c:	while (tab[i])
./srcs/read/syntax_color.c:	{
./srcs/read/syntax_color.c:		rep = opendir(tab[i++]);
./srcs/read/syntax_color.c:		if (rep)
./srcs/read/syntax_color.c:		{
./srcs/read/syntax_color.c:			while ((show = readdir(rep)))
./srcs/read/syntax_color.c:			{
./srcs/read/syntax_color.c:				if (ft_strncmp(str, show->d_name, ft_strlen(str)) == 0)
./srcs/read/syntax_color.c:					list = add_type(list, show->d_name, "Executable");
./srcs/read/syntax_color.c:			}
./srcs/read/syntax_color.c:			closedir(rep);
./srcs/read/syntax_color.c:		}
./srcs/read/syntax_color.c:	}
./srcs/read/syntax_color.c:	return (list);
./srcs/read/syntax_color.c:}
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:void	show_cmd(char *str)
./srcs/read/syntax_color.c:{
./srcs/read/syntax_color.c:	int		i;
./srcs/read/syntax_color.c:	char	*cmd;
./srcs/read/syntax_color.c:	t_list	*list;
./srcs/read/syntax_color.c:	char	*name;
./srcs/read/syntax_color.c:	char	*rest = NULL;
./srcs/read/syntax_color.c:
./srcs/read/syntax_color.c:	i = 0;
./srcs/read/syntax_color.c:	list = NULL;
./srcs/read/syntax_color.c://	while (str[i] == ' ' && str[i])
./srcs/read/syntax_color.c://		++i;
./srcs/read/syntax_color.c:	while (str[i] != ' ' && str[i])
./srcs/read/syntax_color.c:		++i;
./srcs/read/syntax_color.c:	if (i != 0)
./srcs/read/syntax_color.c:	{
./srcs/read/syntax_color.c:		cmd = ft_strsub(str, 0, i);
./srcs/read/syntax_color.c:		list = recup_prog(cmd, ft_strsplit(find_value_envir(g_env, "PATH"), ':'), list);
./srcs/read/syntax_color.c:		if (list)
./srcs/read/syntax_color.c:			name = list->name;
./srcs/read/syntax_color.c:		while (list)
./srcs/read/syntax_color.c:		{
./srcs/read/syntax_color.c:			if (ft_strcmp(cmd, list->name) == 0)
./srcs/read/syntax_color.c:			{
./srcs/read/syntax_color.c:				ft_putstr(BLUE);
./srcs/read/syntax_color.c:				break ;
./srcs/read/syntax_color.c:			}
./srcs/read/syntax_color.c:			list = list->next;
./srcs/read/syntax_color.c:		}
./srcs/read/syntax_color.c:		if (!list)
./srcs/read/syntax_color.c:			ft_putstr(RED);
./srcs/read/syntax_color.c:		ft_putstr(cmd);
./srcs/read/syntax_color.c:		ft_putstr(DEF);
./srcs/read/syntax_color.c:		if ((ft_strlen(str) - i) != 0)
./srcs/read/syntax_color.c:			rest = ft_strsub(str, i, ft_strlen(str) - 1);
./srcs/read/syntax_color.c:		if (list && !rest)
./srcs/read/syntax_color.c:			show_options_in_line(cmd);
./srcs/read/syntax_color.c:		if (!list && name && !rest)
./srcs/read/syntax_color.c:			show_complete(name, cmd);
./srcs/read/syntax_color.c:		if (rest)
./srcs/read/syntax_color.c:			ft_putstr(rest);
./srcs/read/syntax_color.c:	}
./srcs/read/syntax_color.c:}
Binary file ./srcs/read/parser_color.o matches
./srcs/read/autocomplete_too_long.c:/* ************************************************************************** */
./srcs/read/autocomplete_too_long.c:/*                                                                            */
./srcs/read/autocomplete_too_long.c:/*                                                        :::      ::::::::   */
./srcs/read/autocomplete_too_long.c:/*   autocomplete_too_long.c                            :+:      :+:    :+:   */
./srcs/read/autocomplete_too_long.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/autocomplete_too_long.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/autocomplete_too_long.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/autocomplete_too_long.c:/*   Created: 2014/03/03 14:23:11 by lsolofri          #+#    #+#             */
./srcs/read/autocomplete_too_long.c:/*   Updated: 2014/03/03 15:03:27 by lsolofri         ###   ########.fr       */
./srcs/read/autocomplete_too_long.c:/*                                                                            */
./srcs/read/autocomplete_too_long.c:/* ************************************************************************** */
./srcs/read/autocomplete_too_long.c:
./srcs/read/autocomplete_too_long.c:#include "../../includes/msh.h"
./srcs/read/autocomplete_too_long.c:
./srcs/read/autocomplete_too_long.c:int		auto_comp_choice(int i)
./srcs/read/autocomplete_too_long.c:{
./srcs/read/autocomplete_too_long.c:	char	buffer[1];
./srcs/read/autocomplete_too_long.c:
./srcs/read/autocomplete_too_long.c:	ft_putstr("\nmsh: Do you wish to see all possibilities (");
./srcs/read/autocomplete_too_long.c:	ft_putnbr(i);
./srcs/read/autocomplete_too_long.c:	ft_putstr(" lines)? (y/n)");
./srcs/read/autocomplete_too_long.c:	read(0, buffer, 1);
./srcs/read/autocomplete_too_long.c:	if (buffer[0] == 'y')
./srcs/read/autocomplete_too_long.c:		return (2);
./srcs/read/autocomplete_too_long.c:	else
./srcs/read/autocomplete_too_long.c:	{
./srcs/read/autocomplete_too_long.c:		ft_putstr("\n");
./srcs/read/autocomplete_too_long.c:		prompt();
./srcs/read/autocomplete_too_long.c:		ft_putstr(" ");
./srcs/read/autocomplete_too_long.c:		return (0);
./srcs/read/autocomplete_too_long.c:	}
./srcs/read/autocomplete_too_long.c:}
./srcs/read/history.c:/* ************************************************************************** */
./srcs/read/history.c:/*                                                                            */
./srcs/read/history.c:/*                                                        :::      ::::::::   */
./srcs/read/history.c:/*   history.c                                          :+:      :+:    :+:   */
./srcs/read/history.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/history.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/history.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/history.c:/*   Created: 2014/02/12 15:18:32 by lsolofri          #+#    #+#             */
./srcs/read/history.c:/*   Updated: 2014/02/26 22:11:50 by lsolofri         ###   ########.fr       */
./srcs/read/history.c:/*                                                                            */
./srcs/read/history.c:/* ************************************************************************** */
./srcs/read/history.c:
./srcs/read/history.c:#include "../../includes/msh.h"
./srcs/read/history.c:
./srcs/read/history.c:char	*history(int choice, char *str)
./srcs/read/history.c:{
./srcs/read/history.c:	static char		*s_history[500];
./srcs/read/history.c:	static int		i = 0;
./srcs/read/history.c:	int				v;
./srcs/read/history.c:
./srcs/read/history.c:	if (choice == 0)
./srcs/read/history.c:	{
./srcs/read/history.c:		while (s_history[i])
./srcs/read/history.c:			++i;
./srcs/read/history.c:		s_history[i] = ft_strdup(str);
./srcs/read/history.c:		s_history[i + 1] = NULL;
./srcs/read/history.c:	}
./srcs/read/history.c:	else if (choice == 1)
./srcs/read/history.c:	{
./srcs/read/history.c:		if (i > 0)
./srcs/read/history.c:			return (s_history[i--]);
./srcs/read/history.c:	}
./srcs/read/history.c:	else if (choice == 2)
./srcs/read/history.c:	{
./srcs/read/history.c:		if (s_history[i + 1])
./srcs/read/history.c:			return (s_history[i++]);
./srcs/read/history.c:	}
./srcs/read/history.c:	else if (choice == 3)
./srcs/read/history.c:	{
./srcs/read/history.c:		v = 0;
./srcs/read/history.c:		while (s_history[v + 5])
./srcs/read/history.c:			++v;
./srcs/read/history.c:		while (s_history[v])
./srcs/read/history.c:		{
./srcs/read/history.c:			ft_putnbr(v);
./srcs/read/history.c:			ft_putchar('\t');
./srcs/read/history.c:			ft_putendl(s_history[v++]);
./srcs/read/history.c:		}
./srcs/read/history.c:	}
./srcs/read/history.c:	return (s_history[i]);
./srcs/read/history.c:}
./srcs/read/read.c:/* ************************************************************************** */
./srcs/read/read.c:/*                                                                            */
./srcs/read/read.c:/*                                                        :::      ::::::::   */
./srcs/read/read.c:/*   read.c                                             :+:      :+:    :+:   */
./srcs/read/read.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/read.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/read.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/read.c:/*   Created: 2014/02/11 14:52:57 by lsolofri          #+#    #+#             */
./srcs/read/read.c:/*   Updated: 2014/03/23 20:42:37 by lsolofri         ###   ########.fr       */
./srcs/read/read.c:/*                                                                            */
./srcs/read/read.c:/* ************************************************************************** */
./srcs/read/read.c:
./srcs/read/read.c:#include "../../includes/msh.h"
./srcs/read/read.c:
./srcs/read/read.c:char	*change_cmd(int i, char *result, char letter)
./srcs/read/read.c:{
./srcs/read/read.c:	char	*tmp;
./srcs/read/read.c:	char	*end;
./srcs/read/read.c:	char	*c;
./srcs/read/read.c:	char	*new;
./srcs/read/read.c:
./srcs/read/read.c:	c = char_to_string(letter);
./srcs/read/read.c:	if (!result)
./srcs/read/read.c:		return (c);
./srcs/read/read.c:	if (i == ft_strlen(result))
./srcs/read/read.c:	{
./srcs/read/read.c:		new = ft_strjoin(result, c);
./srcs/read/read.c:		return (new);
./srcs/read/read.c:	}
./srcs/read/read.c:	else if (i == 0)
./srcs/read/read.c:	{
./srcs/read/read.c:		new = ft_strjoin(c, result);
./srcs/read/read.c:		return (new);
./srcs/read/read.c:	}
./srcs/read/read.c:	else
./srcs/read/read.c:	{
./srcs/read/read.c:		tmp = ft_strsub(result, 0, i);
./srcs/read/read.c:		end = ft_strsub(result, i, ft_strlen(result));
./srcs/read/read.c:		new = ft_strdup(tmp);
./srcs/read/read.c:		tmp = ft_strjoin(new, c);
./srcs/read/read.c:		result = ft_strjoin(tmp, end);
./srcs/read/read.c:	}
./srcs/read/read.c:	return (result);
./srcs/read/read.c:}
./srcs/read/read.c:
./srcs/read/read.c:int		distrib_buttons(int i, char **result, char *buffer, int *v)
./srcs/read/read.c:{
./srcs/read/read.c:	char	*tmp;
./srcs/read/read.c:
./srcs/read/read.c:	if (buffer[0] == 10)
./srcs/read/read.c:		return (-2);
./srcs/read/read.c:	else if (buffer[0] == 27 && buffer[1] == 91)
./srcs/read/read.c:	{
./srcs/read/read.c:		if (*result)
./srcs/read/read.c:			i = arrow(i, buffer[2], ft_strlen(*result), result);
./srcs/read/read.c:		else
./srcs/read/read.c:			i = arrow(i, buffer[2], 0, result);
./srcs/read/read.c:		if (buffer[2] != 65 && buffer[2] != 66)
./srcs/read/read.c:			*v = 1;
./srcs/read/read.c:	}
./srcs/read/read.c:	else if (buffer[0] == 127)
./srcs/read/read.c:		*result = del_c(*result, &i);
./srcs/read/read.c:	else if (buffer[0] == 9 && *result)
./srcs/read/read.c:	{
./srcs/read/read.c:		tmp = ft_strdup(*result);
./srcs/read/read.c:		*result = show_autocomplete(*result, 1);
./srcs/read/read.c:		if (ft_strcmp(*result, tmp))
./srcs/read/read.c:			i = ft_strlen(*result);
./srcs/read/read.c:		else
./srcs/read/read.c:		{
./srcs/read/read.c:			*result = tmp;
./srcs/read/read.c:			ft_putstr(tgetstr("le", NULL));
./srcs/read/read.c:			i = ft_strlen(tmp);
./srcs/read/read.c:		}
./srcs/read/read.c:	}
./srcs/read/read.c:	else if (buffer[0] == 12)
./srcs/read/read.c:	{
./srcs/read/read.c:		ft_putstr(tgetstr("cl", NULL));
./srcs/read/read.c:		prompt();
./srcs/read/read.c:	}
./srcs/read/read.c:	else if (buffer[0] == 1)
./srcs/read/read.c:	{
./srcs/read/read.c:		if (i != 0)
./srcs/read/read.c:		{
./srcs/read/read.c:			i = 0;
./srcs/read/read.c:			replace_cursor(i, ft_strlen(*result));
./srcs/read/read.c:		}
./srcs/read/read.c:	}
./srcs/read/read.c:	else if (buffer[0] == 5)
./srcs/read/read.c:	{
./srcs/read/read.c:		while (i + 1 < ft_strlen(*result))
./srcs/read/read.c:		{
./srcs/read/read.c:			ft_putstr(" ");
./srcs/read/read.c:			++i;
./srcs/read/read.c:		}
./srcs/read/read.c:		i = ft_strlen(*result);
./srcs/read/read.c:	}
./srcs/read/read.c:	else if (buffer[0] == 21)
./srcs/read/read.c:	{
./srcs/read/read.c:		clear_line(i + 1, ft_strlen(*result));
./srcs/read/read.c:		*result = NULL;
./srcs/read/read.c:		i = 0;
./srcs/read/read.c:	}
./srcs/read/read.c:	else if (buffer[0] == 11 && *result && i < ft_strlen(*result))
./srcs/read/read.c:		*result = ft_strsub(*result, 0, i++);
./srcs/read/read.c:	else if (buffer[0] == 4)
./srcs/read/read.c:			_exit(0);
./srcs/read/read.c:	return (i);
./srcs/read/read.c:}
./srcs/read/read.c:
./srcs/read/read.c:char	*take_cmd(int choice)
./srcs/read/read.c:{
./srcs/read/read.c:	char			*result;
./srcs/read/read.c:	char			*buffer;
./srcs/read/read.c:	struct termios	term;
./srcs/read/read.c:	int				i;
./srcs/read/read.c:	int				v;
./srcs/read/read.c:
./srcs/read/read.c:	i = 0;
./srcs/read/read.c:	(void)choice;
./srcs/read/read.c:	init_flag(&term);
./srcs/read/read.c:	buffer = (char *)ft_memalloc(sizeof(char) * 3);
./srcs/read/read.c:	result = NULL;
./srcs/read/read.c:	while (1)
./srcs/read/read.c:	{
./srcs/read/read.c:		v = 0;
./srcs/read/read.c:		buffer = init_buffer(buffer);
./srcs/read/read.c:		read(0, buffer, 3);
./srcs/read/read.c:		if (ft_isprint(buffer[0]))
./srcs/read/read.c:			result = change_cmd(i++, result, buffer[0]);
./srcs/read/read.c:		else
./srcs/read/read.c:			i = distrib_buttons(i, &result, buffer, &v);
./srcs/read/read.c:		if (i == -2)
./srcs/read/read.c:			break;
./srcs/read/read.c:		if (v == 0 && result)
./srcs/read/read.c:		{
./srcs/read/read.c:			clear_line(i, ft_strlen(result));
./srcs/read/read.c:			if (choice == 0)
./srcs/read/read.c:				write_cmd(result, 0, 0);
./srcs/read/read.c:			else
./srcs/read/read.c:				ft_putstr(result);
./srcs/read/read.c:			replace_cursor(i, ft_strlen(result));
./srcs/read/read.c:		}
./srcs/read/read.c:	}
./srcs/read/read.c:	ft_putstr("\n");
./srcs/read/read.c:	free(buffer);
./srcs/read/read.c:	show_autocomplete(NULL, 0);
./srcs/read/read.c:	re_flag(&term);
./srcs/read/read.c:	return (result);
./srcs/read/read.c:}
./srcs/read/parsing_man.c:/* ************************************************************************** */
./srcs/read/parsing_man.c:/*                                                                            */
./srcs/read/parsing_man.c:/*                                                        :::      ::::::::   */
./srcs/read/parsing_man.c:/*   parsing_man.c                                      :+:      :+:    :+:   */
./srcs/read/parsing_man.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/parsing_man.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/parsing_man.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/parsing_man.c:/*   Created: 2014/02/14 10:43:09 by lsolofri          #+#    #+#             */
./srcs/read/parsing_man.c:/*   Updated: 2014/03/22 13:45:20 by lsolofri         ###   ########.fr       */
./srcs/read/parsing_man.c:/*                                                                            */
./srcs/read/parsing_man.c:/* ************************************************************************** */
./srcs/read/parsing_man.c:
./srcs/read/parsing_man.c:#include "../../includes/msh.h"
./srcs/read/parsing_man.c:
./srcs/read/parsing_man.c:char	*get_cmd_description(char *cmd)
./srcs/read/parsing_man.c:{
./srcs/read/parsing_man.c:	char        **path;
./srcs/read/parsing_man.c:	char        *man_path;
./srcs/read/parsing_man.c:	char        man[] = "man1/";
./srcs/read/parsing_man.c:	char		*str;
./srcs/read/parsing_man.c:	int			fd;
./srcs/read/parsing_man.c:	int			i;
./srcs/read/parsing_man.c:
./srcs/read/parsing_man.c:	i = 0;
./srcs/read/parsing_man.c:	path = ft_strsplit(find_value_envir(g_env, "MANPATH"), ':');
./srcs/read/parsing_man.c:	if (path)
./srcs/read/parsing_man.c:	{
./srcs/read/parsing_man.c:		while (path[i])
./srcs/read/parsing_man.c:		{
./srcs/read/parsing_man.c:			man[3] = '1';
./srcs/read/parsing_man.c:			while (man[3] != '9')
./srcs/read/parsing_man.c:			{
./srcs/read/parsing_man.c:				man_path = ft_strjoin(path[i], ft_strjoin("/", ft_strjoin(man,
./srcs/read/parsing_man.c:								ft_strjoin(cmd, ft_strjoin(".",
./srcs/read/parsing_man.c:										char_to_string(man[3]))))));
./srcs/read/parsing_man.c:				if (man_path)
./srcs/read/parsing_man.c:				{
./srcs/read/parsing_man.c:					if (access(man_path, F_OK) != -1)
./srcs/read/parsing_man.c:					{
./srcs/read/parsing_man.c:						fd = open(man_path, O_RDONLY);
./srcs/read/parsing_man.c:						while ((str = get_next_line(fd)))
./srcs/read/parsing_man.c:						{
./srcs/read/parsing_man.c:							if (ft_strncmp(str, ".Nd", 3) == 0)
./srcs/read/parsing_man.c:							{
./srcs/read/parsing_man.c:								free(path);
./srcs/read/parsing_man.c:								close(fd);
./srcs/read/parsing_man.c:								return (ft_strsub(str, 4, ft_strlen(str)));
./srcs/read/parsing_man.c:							}
./srcs/read/parsing_man.c:						}
./srcs/read/parsing_man.c:						close(fd);
./srcs/read/parsing_man.c:					}
./srcs/read/parsing_man.c:				}
./srcs/read/parsing_man.c:				man[3]++;
./srcs/read/parsing_man.c:			}
./srcs/read/parsing_man.c:			i++;
./srcs/read/parsing_man.c:		}
./srcs/read/parsing_man.c:	}
./srcs/read/parsing_man.c:	return (NULL);
./srcs/read/parsing_man.c:}
./srcs/read/parsing_man.c:
./srcs/read/parsing_man.c:char	*get_options(int fd)
./srcs/read/parsing_man.c:{
./srcs/read/parsing_man.c:	char	*str;
./srcs/read/parsing_man.c:
./srcs/read/parsing_man.c:	while ((str = get_next_line(fd)))
./srcs/read/parsing_man.c:	{
./srcs/read/parsing_man.c:		if (ft_strncmp(str, ".Op Fl", 6) == 0)
./srcs/read/parsing_man.c:			return (ft_strsub(str, 7, ft_strlen(str)));
./srcs/read/parsing_man.c:	}
./srcs/read/parsing_man.c:	close(fd);
./srcs/read/parsing_man.c:	return (NULL);
./srcs/read/parsing_man.c:}
./srcs/read/parsing_man.c:
./srcs/read/parsing_man.c:char	*read_description(int fd, char *c)
./srcs/read/parsing_man.c:{
./srcs/read/parsing_man.c:	char	*str;
./srcs/read/parsing_man.c:	while ((str = get_next_line(fd)))
./srcs/read/parsing_man.c:	{
./srcs/read/parsing_man.c:		if (ft_strcmp(str, ft_strjoin(".It Fl ", c)) == 0)
./srcs/read/parsing_man.c:		{
./srcs/read/parsing_man.c:			str = get_next_line(fd);
./srcs/read/parsing_man.c:			close(fd);
./srcs/read/parsing_man.c:			return (str);
./srcs/read/parsing_man.c:		}
./srcs/read/parsing_man.c:	}
./srcs/read/parsing_man.c:	return (NULL);
./srcs/read/parsing_man.c:}
./srcs/read/parsing_man.c:
./srcs/read/parsing_man.c:t_option	*get_description(char *options, char *path)
./srcs/read/parsing_man.c:{
./srcs/read/parsing_man.c:	t_option	*list;
./srcs/read/parsing_man.c:
./srcs/read/parsing_man.c:	list = NULL;
./srcs/read/parsing_man.c:	if (options)
./srcs/read/parsing_man.c:	{
./srcs/read/parsing_man.c:		while (*options)
./srcs/read/parsing_man.c:		{
./srcs/read/parsing_man.c:			list = add_option(list, *options, read_description(open(path, O_RDONLY),
./srcs/read/parsing_man.c:						char_to_string(*options)));
./srcs/read/parsing_man.c:			options++;
./srcs/read/parsing_man.c:		}
./srcs/read/parsing_man.c:		return (list);
./srcs/read/parsing_man.c:	}
./srcs/read/parsing_man.c:	return (NULL);
./srcs/read/parsing_man.c:}
./srcs/read/parsing_man.c:
./srcs/read/parsing_man.c:t_option	*return_options(char *cmd)
./srcs/read/parsing_man.c:{
./srcs/read/parsing_man.c:	char		**path;
./srcs/read/parsing_man.c:	char		*man_path;
./srcs/read/parsing_man.c:	char		man[] = "man1/";
./srcs/read/parsing_man.c:
./srcs/read/parsing_man.c:	path = ft_strsplit(find_value_envir(g_env, "MANPATH"), ':');
./srcs/read/parsing_man.c:	while (*path)	
./srcs/read/parsing_man.c:	{
./srcs/read/parsing_man.c:		man[3] = '1';
./srcs/read/parsing_man.c:		while (man[3] != '9')
./srcs/read/parsing_man.c:		{
./srcs/read/parsing_man.c:			man_path = ft_strjoin(*path, ft_strjoin("/", ft_strjoin(man,
./srcs/read/parsing_man.c:							ft_strjoin(cmd, ft_strjoin(".",
./srcs/read/parsing_man.c:									char_to_string(man[3]))))));
./srcs/read/parsing_man.c:			if (access(man_path, F_OK) != -1)
./srcs/read/parsing_man.c:				return (get_description(get_options(open(man_path, O_RDONLY)),
./srcs/read/parsing_man.c:							man_path));
./srcs/read/parsing_man.c:			man[3]++;
./srcs/read/parsing_man.c:		}
./srcs/read/parsing_man.c:		path++;
./srcs/read/parsing_man.c:	}
./srcs/read/parsing_man.c:	return (NULL);
./srcs/read/parsing_man.c:}
Binary file ./srcs/read/autocomplete.o matches
./srcs/read/show_autocomplete.c:/* ************************************************************************** */
./srcs/read/show_autocomplete.c:/*                                                                            */
./srcs/read/show_autocomplete.c:/*                                                        :::      ::::::::   */
./srcs/read/show_autocomplete.c:/*   show_autocomplete.c                                :+:      :+:    :+:   */
./srcs/read/show_autocomplete.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/show_autocomplete.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/show_autocomplete.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/show_autocomplete.c:/*   Created: 2014/02/15 14:47:45 by lsolofri          #+#    #+#             */
./srcs/read/show_autocomplete.c:/*   Updated: 2014/03/23 14:26:59 by lsolofri         ###   ########.fr       */
./srcs/read/show_autocomplete.c:/*                                                                            */
./srcs/read/show_autocomplete.c:/* ************************************************************************** */
./srcs/read/show_autocomplete.c:
./srcs/read/show_autocomplete.c:#include "../../includes/msh.h"
./srcs/read/show_autocomplete.c:
./srcs/read/show_autocomplete.c:void	aff_cmd(char *str, char *cmd)
./srcs/read/show_autocomplete.c:{
./srcs/read/show_autocomplete.c:	int		i;
./srcs/read/show_autocomplete.c:
./srcs/read/show_autocomplete.c:	i = 0;
./srcs/read/show_autocomplete.c:	ft_putstr(BLUE);
./srcs/read/show_autocomplete.c:	while (str[i] == cmd[i] && str[i] && cmd[i])
./srcs/read/show_autocomplete.c:		ft_putchar(str[i++]);
./srcs/read/show_autocomplete.c:	ft_putstr(DEF);
./srcs/read/show_autocomplete.c:	while (str[i])
./srcs/read/show_autocomplete.c:		ft_putchar(str[i++]);
./srcs/read/show_autocomplete.c:}
./srcs/read/show_autocomplete.c:
./srcs/read/show_autocomplete.c:char	*show_tab(char *cmd)
./srcs/read/show_autocomplete.c:{
./srcs/read/show_autocomplete.c:	t_list	*list;
./srcs/read/show_autocomplete.c:	int		i;
./srcs/read/show_autocomplete.c:	char	*description = NULL;
./srcs/read/show_autocomplete.c:
./srcs/read/show_autocomplete.c:	i = 0;
./srcs/read/show_autocomplete.c:	list = NULL;
./srcs/read/show_autocomplete.c:	list = recup_prog(cmd, ft_strsplit(find_value_envir(g_env, "PATH"), ':'), list);
./srcs/read/show_autocomplete.c:	if (list)
./srcs/read/show_autocomplete.c:	{
./srcs/read/show_autocomplete.c:		while (list)
./srcs/read/show_autocomplete.c:		{
./srcs/read/show_autocomplete.c:			++i;
./srcs/read/show_autocomplete.c:			list = list->next;
./srcs/read/show_autocomplete.c:		}
./srcs/read/show_autocomplete.c:		if (i > 15)
./srcs/read/show_autocomplete.c:			i = auto_comp_choice(i);
./srcs/read/show_autocomplete.c:		list = NULL;
./srcs/read/show_autocomplete.c:		list = recup_prog(cmd, ft_strsplit(find_value_envir(g_env, "PATH"), ':'), list);
./srcs/read/show_autocomplete.c:		if (i != 1 && i != 0)
./srcs/read/show_autocomplete.c:		{
./srcs/read/show_autocomplete.c:			ft_putstr("\n");
./srcs/read/show_autocomplete.c:			while (list)
./srcs/read/show_autocomplete.c:			{
./srcs/read/show_autocomplete.c:				aff_cmd(list->name, cmd);
./srcs/read/show_autocomplete.c:				ft_putstr(GRAY);
./srcs/read/show_autocomplete.c:				ft_putstr("\t\t\t\t\t(");
./srcs/read/show_autocomplete.c:				description = get_cmd_description(list->name);
./srcs/read/show_autocomplete.c:				if (description)
./srcs/read/show_autocomplete.c:					ft_putstr(description);
./srcs/read/show_autocomplete.c:				else
./srcs/read/show_autocomplete.c:					ft_putstr("No Description");
./srcs/read/show_autocomplete.c:				ft_putstr(")\n");
./srcs/read/show_autocomplete.c:				ft_putstr(DEF);
./srcs/read/show_autocomplete.c:				list = list->next;
./srcs/read/show_autocomplete.c:			}
./srcs/read/show_autocomplete.c:			return ("ok");
./srcs/read/show_autocomplete.c:		}
./srcs/read/show_autocomplete.c:		else if (i != 0)
./srcs/read/show_autocomplete.c:		{
./srcs/read/show_autocomplete.c:			i = 0;
./srcs/read/show_autocomplete.c:			while (list->name[i] == cmd[i] && list->name[i] && cmd[i])
./srcs/read/show_autocomplete.c:				++i;
./srcs/read/show_autocomplete.c:			return (ft_strjoin(cmd, ft_strsub(list->name, i, ft_strlen(list->name))));
./srcs/read/show_autocomplete.c:		}
./srcs/read/show_autocomplete.c:	}
./srcs/read/show_autocomplete.c:	free(list);
./srcs/read/show_autocomplete.c:	free(description);
./srcs/read/show_autocomplete.c:	return (NULL);
./srcs/read/show_autocomplete.c:}
./srcs/read/show_autocomplete.c:
./srcs/read/show_autocomplete.c:char	*show_autocomplete(char *str, int v)
./srcs/read/show_autocomplete.c:{
./srcs/read/show_autocomplete.c:	int				i;
./srcs/read/show_autocomplete.c:	char			*tmp;
./srcs/read/show_autocomplete.c:	static int		status;
./srcs/read/show_autocomplete.c:
./srcs/read/show_autocomplete.c:	i = 0;
./srcs/read/show_autocomplete.c:	if (v == 0)
./srcs/read/show_autocomplete.c:	{
./srcs/read/show_autocomplete.c:		status = 0;
./srcs/read/show_autocomplete.c:		return (0);
./srcs/read/show_autocomplete.c:	}
./srcs/read/show_autocomplete.c:	while (str[i] != ' ' && str[i])
./srcs/read/show_autocomplete.c:		++i;
./srcs/read/show_autocomplete.c:	if (!str[i] && status == 0)
./srcs/read/show_autocomplete.c:	{
./srcs/read/show_autocomplete.c:		tmp = show_tab(ft_strsub(str, 0, i));
./srcs/read/show_autocomplete.c:		if (tmp && ft_strcmp(tmp, "ok"))
./srcs/read/show_autocomplete.c:		{
./srcs/read/show_autocomplete.c:			i = ft_strlen(tmp) - 1;
./srcs/read/show_autocomplete.c:			while (i > ft_strlen(str))
./srcs/read/show_autocomplete.c:			{
./srcs/read/show_autocomplete.c:				ft_putstr(tgetstr("nd", NULL));
./srcs/read/show_autocomplete.c:				--i;
./srcs/read/show_autocomplete.c:			}
./srcs/read/show_autocomplete.c:			str = tmp;
./srcs/read/show_autocomplete.c:		}
./srcs/read/show_autocomplete.c:		else if (tmp && ft_strcmp("ok", tmp) == 0)
./srcs/read/show_autocomplete.c:		{
./srcs/read/show_autocomplete.c:			prompt();
./srcs/read/show_autocomplete.c:			ft_putstr(" ");
./srcs/read/show_autocomplete.c:			if (i != 1)
./srcs/read/show_autocomplete.c:				ft_putstr(tgetstr("nd", NULL));
./srcs/read/show_autocomplete.c:			if (i == 3)
./srcs/read/show_autocomplete.c:			{
./srcs/read/show_autocomplete.c:				ft_putstr(tgetstr("nd", NULL));
./srcs/read/show_autocomplete.c:			}
./srcs/read/show_autocomplete.c:			else if (i > 3)
./srcs/read/show_autocomplete.c:			{
./srcs/read/show_autocomplete.c:				ft_putstr(tgetstr("nd", NULL));
./srcs/read/show_autocomplete.c:				ft_putstr(tgetstr("nd", NULL));
./srcs/read/show_autocomplete.c:			}
./srcs/read/show_autocomplete.c:		}
./srcs/read/show_autocomplete.c:		status = 1;
./srcs/read/show_autocomplete.c:	}
./srcs/read/show_autocomplete.c:	else if (status == 1)
./srcs/read/show_autocomplete.c:		str = spe_autocomp(str, ft_strlen(str));
./srcs/read/show_autocomplete.c:	else if (str[i + 1] == '-' && !str[i + 2])
./srcs/read/show_autocomplete.c:	{
./srcs/read/show_autocomplete.c:		show_diff_option(ft_strsub(str, 0, i));
./srcs/read/show_autocomplete.c:		prompt();
./srcs/read/show_autocomplete.c:		ft_putstr("    ");
./srcs/read/show_autocomplete.c:		if (i == 1)
./srcs/read/show_autocomplete.c:				ft_putstr(tgetstr("le", NULL));
./srcs/read/show_autocomplete.c:			else if (i == 3)
./srcs/read/show_autocomplete.c:				ft_putstr(tgetstr("nd", NULL));
./srcs/read/show_autocomplete.c:			else if (i > 3)
./srcs/read/show_autocomplete.c:			{
./srcs/read/show_autocomplete.c:				ft_putstr(tgetstr("nd", NULL));
./srcs/read/show_autocomplete.c:				ft_putstr(tgetstr("nd", NULL));
./srcs/read/show_autocomplete.c:			}
./srcs/read/show_autocomplete.c:		status = 2;
./srcs/read/show_autocomplete.c:	}
./srcs/read/show_autocomplete.c:	else
./srcs/read/show_autocomplete.c:		argument_completion(str);
./srcs/read/show_autocomplete.c:	return (str);
./srcs/read/show_autocomplete.c:}
Binary file ./srcs/read/syntax_color_rest.o matches
./srcs/read/t_options.c:/* ************************************************************************** */
./srcs/read/t_options.c:/*                                                                            */
./srcs/read/t_options.c:/*                                                        :::      ::::::::   */
./srcs/read/t_options.c:/*   t_options.c                                        :+:      :+:    :+:   */
./srcs/read/t_options.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/t_options.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/t_options.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/t_options.c:/*   Created: 2014/02/14 12:59:04 by lsolofri          #+#    #+#             */
./srcs/read/t_options.c:/*   Updated: 2014/02/14 17:00:13 by lsolofri         ###   ########.fr       */
./srcs/read/t_options.c:/*                                                                            */
./srcs/read/t_options.c:/* ************************************************************************** */
./srcs/read/t_options.c:
./srcs/read/t_options.c:#include "../../includes/msh.h"
./srcs/read/t_options.c:
./srcs/read/t_options.c:t_option	*add_option(t_option *list, char option, char *description)
./srcs/read/t_options.c:{
./srcs/read/t_options.c:	t_option	*tmp;
./srcs/read/t_options.c:	t_option	*temp;
./srcs/read/t_options.c:
./srcs/read/t_options.c:	temp = list;
./srcs/read/t_options.c:	tmp = malloc(sizeof(t_option));
./srcs/read/t_options.c:	tmp->option = option;
./srcs/read/t_options.c:	if (description)
./srcs/read/t_options.c:		tmp->description = ft_strdup(description);
./srcs/read/t_options.c:	else
./srcs/read/t_options.c:		tmp->description = NULL;
./srcs/read/t_options.c:	tmp->next = NULL;
./srcs/read/t_options.c:	if (list == NULL)
./srcs/read/t_options.c:		return (tmp);
./srcs/read/t_options.c:	else
./srcs/read/t_options.c:	{
./srcs/read/t_options.c:		while (temp->next != NULL)
./srcs/read/t_options.c:			temp = temp->next;
./srcs/read/t_options.c:		temp->next = tmp;
./srcs/read/t_options.c:	}
./srcs/read/t_options.c:	return (list);
./srcs/read/t_options.c:}
Binary file ./srcs/read/buttons.o matches
Binary file ./srcs/read/termcap.o matches
Binary file ./srcs/read/autocomplete_too_long.o matches
./srcs/read/spe_autocomp.c:/* ************************************************************************** */
./srcs/read/spe_autocomp.c:/*                                                                            */
./srcs/read/spe_autocomp.c:/*                                                        :::      ::::::::   */
./srcs/read/spe_autocomp.c:/*   spe_autocomp.c                                     :+:      :+:    :+:   */
./srcs/read/spe_autocomp.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/spe_autocomp.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/spe_autocomp.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/spe_autocomp.c:/*   Created: 2014/03/03 15:11:46 by lsolofri          #+#    #+#             */
./srcs/read/spe_autocomp.c:/*   Updated: 2014/03/23 14:28:54 by lsolofri         ###   ########.fr       */
./srcs/read/spe_autocomp.c:/*                                                                            */
./srcs/read/spe_autocomp.c:/* ************************************************************************** */
./srcs/read/spe_autocomp.c:
./srcs/read/spe_autocomp.c:#include "../../includes/msh.h"
./srcs/read/spe_autocomp.c:
./srcs/read/spe_autocomp.c:char	*spe_autocomp(char *cmd, int len)
./srcs/read/spe_autocomp.c:{
./srcs/read/spe_autocomp.c:	static t_list	*list; 
./srcs/read/spe_autocomp.c:	static t_list	*beg; 
./srcs/read/spe_autocomp.c:	static int		v;
./srcs/read/spe_autocomp.c:	static char		*str;
./srcs/read/spe_autocomp.c:	int				i;
./srcs/read/spe_autocomp.c:	char			*result;
./srcs/read/spe_autocomp.c:
./srcs/read/spe_autocomp.c:	i = 0;
./srcs/read/spe_autocomp.c:	if (v == 0)
./srcs/read/spe_autocomp.c:	{
./srcs/read/spe_autocomp.c:		str = ft_strdup(cmd);
./srcs/read/spe_autocomp.c:		list = recup_prog(cmd, ft_strsplit(find_value_envir(g_env, "PATH"), ':'), list);
./srcs/read/spe_autocomp.c:		beg = list;
./srcs/read/spe_autocomp.c:	}
./srcs/read/spe_autocomp.c:	if (!list)
./srcs/read/spe_autocomp.c:		list = beg;
./srcs/read/spe_autocomp.c:	if (list)
./srcs/read/spe_autocomp.c:	{
./srcs/read/spe_autocomp.c:		while (list->name[i] == cmd[i] && list->name[i] && cmd[i])
./srcs/read/spe_autocomp.c:			++i;
./srcs/read/spe_autocomp.c:		result = ft_strjoin(str, ft_strsub(list->name, i, ft_strlen(list->name)));
./srcs/read/spe_autocomp.c:		list = list->next;
./srcs/read/spe_autocomp.c:		v++;
./srcs/read/spe_autocomp.c:		if (len > ft_strlen(result) - 1)
./srcs/read/spe_autocomp.c:		{
./srcs/read/spe_autocomp.c:			len -= ft_strlen(result);
./srcs/read/spe_autocomp.c:			while (len >= 0)
./srcs/read/spe_autocomp.c:			{
./srcs/read/spe_autocomp.c:				ft_putstr(tgetstr("le", NULL));
./srcs/read/spe_autocomp.c:				len--;
./srcs/read/spe_autocomp.c:			}
./srcs/read/spe_autocomp.c:		}
./srcs/read/spe_autocomp.c:		else
./srcs/read/spe_autocomp.c:		{
./srcs/read/spe_autocomp.c:			len = ft_strlen(result) - len;
./srcs/read/spe_autocomp.c:			while (len > 1)
./srcs/read/spe_autocomp.c:			{
./srcs/read/spe_autocomp.c:				ft_putstr(" ");
./srcs/read/spe_autocomp.c:				len--;
./srcs/read/spe_autocomp.c:			}
./srcs/read/spe_autocomp.c:		}
./srcs/read/spe_autocomp.c:		return (result);
./srcs/read/spe_autocomp.c:	}
./srcs/read/spe_autocomp.c:	return (cmd);
./srcs/read/spe_autocomp.c:}
./srcs/read/show_option.c:/* ************************************************************************** */
./srcs/read/show_option.c:/*                                                                            */
./srcs/read/show_option.c:/*                                                        :::      ::::::::   */
./srcs/read/show_option.c:/*   show_option.c                                      :+:      :+:    :+:   */
./srcs/read/show_option.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/show_option.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/show_option.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/show_option.c:/*   Created: 2014/02/15 20:20:16 by lsolofri          #+#    #+#             */
./srcs/read/show_option.c:/*   Updated: 2014/02/18 18:36:24 by lsolofri         ###   ########.fr       */
./srcs/read/show_option.c:/*                                                                            */
./srcs/read/show_option.c:/* ************************************************************************** */
./srcs/read/show_option.c:
./srcs/read/show_option.c:#include "../../includes/msh.h"
./srcs/read/show_option.c:
./srcs/read/show_option.c:void	show_diff_option(char *str)
./srcs/read/show_option.c:{
./srcs/read/show_option.c:	t_option	*list;
./srcs/read/show_option.c:
./srcs/read/show_option.c:	ft_putstr("\n");
./srcs/read/show_option.c:	list = return_options(str);
./srcs/read/show_option.c:	if (list)
./srcs/read/show_option.c:	{
./srcs/read/show_option.c:		while (list)
./srcs/read/show_option.c:		{
./srcs/read/show_option.c:			ft_putchar('-');
./srcs/read/show_option.c:			ft_putchar(list->option);
./srcs/read/show_option.c:			ft_putstr(GRAY);
./srcs/read/show_option.c:			ft_putstr("\t\t(");
./srcs/read/show_option.c:			if (list->description)
./srcs/read/show_option.c:				ft_putstr(list->description);
./srcs/read/show_option.c:			else
./srcs/read/show_option.c:				ft_putstr("No Description");
./srcs/read/show_option.c:			ft_putstr(")");
./srcs/read/show_option.c:				ft_putendl(DEF);
./srcs/read/show_option.c:			list = list->next;
./srcs/read/show_option.c:		}
./srcs/read/show_option.c:	}
./srcs/read/show_option.c:	else
./srcs/read/show_option.c:		ft_putstr("No Options!\n");
./srcs/read/show_option.c:}
./srcs/read/syntax_color_rest.c:/* ************************************************************************** */
./srcs/read/syntax_color_rest.c:/*                                                                            */
./srcs/read/syntax_color_rest.c:/*                                                        :::      ::::::::   */
./srcs/read/syntax_color_rest.c:/*   syntax_color_rest.c                                :+:      :+:    :+:   */
./srcs/read/syntax_color_rest.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/syntax_color_rest.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/syntax_color_rest.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/syntax_color_rest.c:/*   Created: 2014/02/21 13:51:41 by lsolofri          #+#    #+#             */
./srcs/read/syntax_color_rest.c:/*   Updated: 2014/02/21 15:04:45 by lsolofri         ###   ########.fr       */
./srcs/read/syntax_color_rest.c:/*                                                                            */
./srcs/read/syntax_color_rest.c:/* ************************************************************************** */
./srcs/read/syntax_color_rest.c:
./srcs/read/syntax_color_rest.c:#include "../../includes/msh.h"
./srcs/read/syntax_color_rest.c:
./srcs/read/syntax_color_rest.c:void	syntax_color_rest(char *str)
./srcs/read/syntax_color_rest.c:{
./srcs/read/syntax_color_rest.c:	int		i;
./srcs/read/syntax_color_rest.c:	int		quote;
./srcs/read/syntax_color_rest.c:	int		s_quote;
./srcs/read/syntax_color_rest.c:
./srcs/read/syntax_color_rest.c:	quote = 1;
./srcs/read/syntax_color_rest.c:	s_quote = 1;
./srcs/read/syntax_color_rest.c:	i = 0;
./srcs/read/syntax_color_rest.c:	while (str[i])
./srcs/read/syntax_color_rest.c:	{
./srcs/read/syntax_color_rest.c:		if (str[i] == '"')
./srcs/read/syntax_color_rest.c:		{
./srcs/read/syntax_color_rest.c:			++i;
./srcs/read/syntax_color_rest.c:			while (str[i] != '"' && str[i])
./srcs/read/syntax_color_rest.c:				++i;
./srcs/read/syntax_color_rest.c:			if (!str[i])
./srcs/read/syntax_color_rest.c:				quote = 0;
./srcs/read/syntax_color_rest.c:		}
./srcs/read/syntax_color_rest.c:		else if (str[i] == '\'')
./srcs/read/syntax_color_rest.c:		{
./srcs/read/syntax_color_rest.c:			++i;
./srcs/read/syntax_color_rest.c:			while (str[i] != '\'' && str[i])
./srcs/read/syntax_color_rest.c:				++i;
./srcs/read/syntax_color_rest.c:			if (!str[i])
./srcs/read/syntax_color_rest.c:				s_quote = 0;
./srcs/read/syntax_color_rest.c:		}
./srcs/read/syntax_color_rest.c:		++i;
./srcs/read/syntax_color_rest.c:	}
./srcs/read/syntax_color_rest.c:	i = 0;
./srcs/read/syntax_color_rest.c:	while (str[i])
./srcs/read/syntax_color_rest.c:	{
./srcs/read/syntax_color_rest.c:		if (str[i] == '"' && quote == 0)
./srcs/read/syntax_color_rest.c:			ft_putstr(RED);
./srcs/read/syntax_color_rest.c:		else if (str[i] == '"' && quote == 1)
./srcs/read/syntax_color_rest.c:		{
./srcs/read/syntax_color_rest.c:			ft_putstr(YEL);
./srcs/read/syntax_color_rest.c:			ft_putchar(str[i++]);
./srcs/read/syntax_color_rest.c:			while (str[i] != '"' && str[i])
./srcs/read/syntax_color_rest.c:				ft_putchar(str[i++]);
./srcs/read/syntax_color_rest.c:			ft_putchar(str[i]);
./srcs/read/syntax_color_rest.c:			ft_putstr(DEF);
./srcs/read/syntax_color_rest.c:			++i;
./srcs/read/syntax_color_rest.c:		}
./srcs/read/syntax_color_rest.c:		else if (str[i] == '\'' && s_quote == 0)
./srcs/read/syntax_color_rest.c:			ft_putstr(RED);
./srcs/read/syntax_color_rest.c:		else if (str[i] == '\'' && s_quote == 1)
./srcs/read/syntax_color_rest.c:		{
./srcs/read/syntax_color_rest.c:			ft_putstr(YEL);
./srcs/read/syntax_color_rest.c:			ft_putchar(str[i++]);
./srcs/read/syntax_color_rest.c:			while (str[i] != '\'' && str[i])
./srcs/read/syntax_color_rest.c:				ft_putchar(str[i++]);
./srcs/read/syntax_color_rest.c:			ft_putchar(str[i]);
./srcs/read/syntax_color_rest.c:			ft_putstr(DEF);
./srcs/read/syntax_color_rest.c:			++i;
./srcs/read/syntax_color_rest.c:		}
./srcs/read/syntax_color_rest.c:		if (*(str + i) != '\0')
./srcs/read/syntax_color_rest.c:		{
./srcs/read/syntax_color_rest.c:			write(1, &str[i], 1);
./srcs/read/syntax_color_rest.c:			++i;
./srcs/read/syntax_color_rest.c:		}
./srcs/read/syntax_color_rest.c:	}
./srcs/read/syntax_color_rest.c:	ft_putstr(DEF);
./srcs/read/syntax_color_rest.c:	free(str);
./srcs/read/syntax_color_rest.c:}
Binary file ./srcs/read/show_option.o matches
Binary file ./srcs/read/actions.o matches
Binary file ./srcs/read/t_options.o matches
./srcs/read/parser_color.c:/* ************************************************************************** */
./srcs/read/parser_color.c:/*                                                                            */
./srcs/read/parser_color.c:/*                                                        :::      ::::::::   */
./srcs/read/parser_color.c:/*   parser_color.c                                     :+:      :+:    :+:   */
./srcs/read/parser_color.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/parser_color.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/parser_color.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/parser_color.c:/*   Created: 2014/02/27 08:31:33 by lsolofri          #+#    #+#             */
./srcs/read/parser_color.c:/*   Updated: 2014/03/23 20:51:53 by lsolofri         ###   ########.fr       */
./srcs/read/parser_color.c:/*                                                                            */
./srcs/read/parser_color.c:/* ************************************************************************** */
./srcs/read/parser_color.c:
./srcs/read/parser_color.c:#include "../../includes/msh.h"
./srcs/read/parser_color.c:
./srcs/read/parser_color.c:void	print_quote(char *cmd)
./srcs/read/parser_color.c:{
./srcs/read/parser_color.c:	int		j;
./srcs/read/parser_color.c:
./srcs/read/parser_color.c:	j = 0;
./srcs/read/parser_color.c:	while (cmd[j])
./srcs/read/parser_color.c:	{
./srcs/read/parser_color.c:		if (cmd[j] == '\\')
./srcs/read/parser_color.c:		{
./srcs/read/parser_color.c:			ft_putstr(RED2);
./srcs/read/parser_color.c:			ft_putchar(cmd[j]);
./srcs/read/parser_color.c:			if (cmd[++j])
./srcs/read/parser_color.c:				ft_putchar(cmd[j]);
./srcs/read/parser_color.c:			ft_putstr(YEL);
./srcs/read/parser_color.c:		}
./srcs/read/parser_color.c:		else if (cmd[j] == '$')
./srcs/read/parser_color.c:		{
./srcs/read/parser_color.c:			ft_putstr(GRE2);
./srcs/read/parser_color.c:			ft_putchar(cmd[j++]);
./srcs/read/parser_color.c:			while (ft_isalpha(cmd[j]) && cmd[j])
./srcs/read/parser_color.c:				ft_putchar(cmd[j++]);
./srcs/read/parser_color.c:			--j;
./srcs/read/parser_color.c:			ft_putstr(YEL);
./srcs/read/parser_color.c:		}
./srcs/read/parser_color.c:		else
./srcs/read/parser_color.c:			ft_putchar(cmd[j]);
./srcs/read/parser_color.c:		++j;
./srcs/read/parser_color.c:	}
./srcs/read/parser_color.c:}
./srcs/read/parser_color.c:
./srcs/read/parser_color.c:void	write_cmd(char *cmd, int i, int command)
./srcs/read/parser_color.c:{
./srcs/read/parser_color.c:	int			v;
./srcs/read/parser_color.c:	char		*tmp;
./srcs/read/parser_color.c:
./srcs/read/parser_color.c:	tmp = NULL;
./srcs/read/parser_color.c:	while (cmd[i] && cmd[i] == ' ')
./srcs/read/parser_color.c:		ft_putchar(cmd[i++]);
./srcs/read/parser_color.c:	if (!cmd[i])
./srcs/read/parser_color.c:		return ;
./srcs/read/parser_color.c:	else if (cmd[i] == '"')
./srcs/read/parser_color.c:	{
./srcs/read/parser_color.c:		++i;
./srcs/read/parser_color.c:		v = i;
./srcs/read/parser_color.c:		while (cmd[i] != '"' && cmd[i])
./srcs/read/parser_color.c:		{
./srcs/read/parser_color.c:			if (cmd[i] == '\\')
./srcs/read/parser_color.c:				++i;
./srcs/read/parser_color.c:			++i;
./srcs/read/parser_color.c:		}
./srcs/read/parser_color.c:		if (cmd[i])
./srcs/read/parser_color.c:		{
./srcs/read/parser_color.c:			ft_putstr(YEL);
./srcs/read/parser_color.c:			++i;
./srcs/read/parser_color.c:			ft_putchar('"');
./srcs/read/parser_color.c:			print_quote(ft_strsub(cmd, v, (i - v)));
./srcs/read/parser_color.c:		}
./srcs/read/parser_color.c:		else
./srcs/read/parser_color.c:		{
./srcs/read/parser_color.c:			ft_putstr(RED);
./srcs/read/parser_color.c:			ft_putchar('"');
./srcs/read/parser_color.c:			write(1, &cmd[v], (i - v));
./srcs/read/parser_color.c:		}
./srcs/read/parser_color.c:		ft_putstr(DEF);
./srcs/read/parser_color.c:	}
./srcs/read/parser_color.c:	else if (cmd[i] == '\'')
./srcs/read/parser_color.c:	{
./srcs/read/parser_color.c:		++i;
./srcs/read/parser_color.c:		v = i;
./srcs/read/parser_color.c:		while (cmd[i] != '\'' && cmd[i])
./srcs/read/parser_color.c:			++i;
./srcs/read/parser_color.c:		if (cmd[i])
./srcs/read/parser_color.c:		{
./srcs/read/parser_color.c:			ft_putstr(YEL);
./srcs/read/parser_color.c:			++i;
./srcs/read/parser_color.c:		}
./srcs/read/parser_color.c:		else
./srcs/read/parser_color.c:			ft_putstr(RED);
./srcs/read/parser_color.c:		ft_putchar('\'');
./srcs/read/parser_color.c:		write(1, &cmd[v], (i - v));
./srcs/read/parser_color.c:		ft_putstr(DEF);
./srcs/read/parser_color.c:	}
./srcs/read/parser_color.c:	else if (cmd[i] == '>')
./srcs/read/parser_color.c:	{
./srcs/read/parser_color.c:		ft_putstr(MAG);
./srcs/read/parser_color.c:		if (cmd[i + 1] == '>')
./srcs/read/parser_color.c:			ft_putchar(cmd[i++]);
./srcs/read/parser_color.c:		ft_putchar(cmd[i++]);
./srcs/read/parser_color.c:		ft_putstr(DEF);
./srcs/read/parser_color.c:		while (cmd[i] == ' ' && cmd[i])
./srcs/read/parser_color.c:			ft_putchar(cmd[i++]);
./srcs/read/parser_color.c:		v = i;
./srcs/read/parser_color.c:		while (cmd[i] != ' ' && cmd[i] != ';' && cmd[i] != '|' && cmd[i])
./srcs/read/parser_color.c:			++i;
./srcs/read/parser_color.c:		ft_putstr(GRE);
./srcs/read/parser_color.c:		write(1, &cmd[v], (i - v));
./srcs/read/parser_color.c:		ft_putstr(DEF);
./srcs/read/parser_color.c:	}
./srcs/read/parser_color.c:	else if (cmd[i] == '<')
./srcs/read/parser_color.c:	{
./srcs/read/parser_color.c:		ft_putstr(MAG);
./srcs/read/parser_color.c:		if (cmd[i + 1] == '<')
./srcs/read/parser_color.c:			ft_putchar(cmd[i++]);
./srcs/read/parser_color.c:		ft_putchar(cmd[i++]);
./srcs/read/parser_color.c:		ft_putstr(DEF);
./srcs/read/parser_color.c:		while (cmd[i] == ' ' && cmd[i])
./srcs/read/parser_color.c:			ft_putchar(cmd[i++]);
./srcs/read/parser_color.c:		v = i;
./srcs/read/parser_color.c:		while (cmd[i] != ' ' && cmd[i] != ';' && cmd[i] != '|' && cmd[i])
./srcs/read/parser_color.c:			++i;
./srcs/read/parser_color.c:		ft_putstr(GRE);
./srcs/read/parser_color.c:		write(1, &cmd[v], (i - v));
./srcs/read/parser_color.c:		ft_putstr(DEF);
./srcs/read/parser_color.c:	}
./srcs/read/parser_color.c:	else if (cmd[i] == '|' || cmd[i] == ';' || cmd[i] == '&' || cmd[i] == '(' || cmd[i] == ')')
./srcs/read/parser_color.c:	{
./srcs/read/parser_color.c:		ft_putstr(MAG);
./srcs/read/parser_color.c:		ft_putchar(cmd[i++]);
./srcs/read/parser_color.c:		ft_putstr(DEF);
./srcs/read/parser_color.c:		command = 0;
./srcs/read/parser_color.c:	}
./srcs/read/parser_color.c:	else
./srcs/read/parser_color.c:	{
./srcs/read/parser_color.c:		if (command == 0)
./srcs/read/parser_color.c:		{
./srcs/read/parser_color.c:			v = i;
./srcs/read/parser_color.c:			while (cmd[i] != ' ' && cmd[i] != ';' && cmd[i] != '|' && cmd[i] != '(' && cmd[i] != ')' && cmd[i])
./srcs/read/parser_color.c:				++i;
./srcs/read/parser_color.c:			tmp = ft_strsub(cmd, v, (i - v));
./srcs/read/parser_color.c:			if (check_prog(tmp))
./srcs/read/parser_color.c:				ft_putstr(BLUE);
./srcs/read/parser_color.c:			else
./srcs/read/parser_color.c:				ft_putstr(RED);
./srcs/read/parser_color.c:			i = v;
./srcs/read/parser_color.c:		}
./srcs/read/parser_color.c:		if (cmd[i] == '-')
./srcs/read/parser_color.c:		{
./srcs/read/parser_color.c:			ft_putstr(SBLUE);
./srcs/read/parser_color.c:			v = -1;
./srcs/read/parser_color.c:		}
./srcs/read/parser_color.c:		while (cmd[i] != ' ' && cmd[i] != ';' && cmd[i] != '|' && cmd[i])
./srcs/read/parser_color.c:		{
./srcs/read/parser_color.c:			if (command == 1 && v != -1)
./srcs/read/parser_color.c:				ft_putstr(SBLUE2);
./srcs/read/parser_color.c:			ft_putchar(cmd[i++]);
./srcs/read/parser_color.c:		}
./srcs/read/parser_color.c:		if (tmp)
./srcs/read/parser_color.c:		{
./srcs/read/parser_color.c:			if (!cmd[i] && check_prog(tmp))
./srcs/read/parser_color.c:				show_options_in_line(tmp);
./srcs/read/parser_color.c:		}
./srcs/read/parser_color.c:		if (command == 0)
./srcs/read/parser_color.c:			command = 1;
./srcs/read/parser_color.c:		ft_putstr(DEF);
./srcs/read/parser_color.c:	}
./srcs/read/parser_color.c:	if (!cmd[i])
./srcs/read/parser_color.c:		return ;
./srcs/read/parser_color.c:	write_cmd(cmd, i, command);
./srcs/read/parser_color.c:}
./srcs/read/actions.c:/* ************************************************************************** */
./srcs/read/actions.c:/*                                                                            */
./srcs/read/actions.c:/*                                                        :::      ::::::::   */
./srcs/read/actions.c:/*   actions.c                                          :+:      :+:    :+:   */
./srcs/read/actions.c:/*                                                    +:+ +:+         +:+     */
./srcs/read/actions.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/read/actions.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/read/actions.c:/*   Created: 2014/02/12 11:34:17 by lsolofri          #+#    #+#             */
./srcs/read/actions.c:/*   Updated: 2014/03/23 12:55:26 by lsolofri         ###   ########.fr       */
./srcs/read/actions.c:/*                                                                            */
./srcs/read/actions.c:/* ************************************************************************** */
./srcs/read/actions.c:
./srcs/read/actions.c:#include "../../includes/msh.h"
./srcs/read/actions.c:
./srcs/read/actions.c:char	*del_c(char *result, int *i)
./srcs/read/actions.c:{
./srcs/read/actions.c:	int		tmp;
./srcs/read/actions.c:
./srcs/read/actions.c:	if (*i != 0)
./srcs/read/actions.c:	{
./srcs/read/actions.c:		if (*i != 1)
./srcs/read/actions.c:			ft_putstr(tgetstr("le", NULL));
./srcs/read/actions.c:		ft_putstr(tgetstr("le", NULL));
./srcs/read/actions.c:		--*i;
./srcs/read/actions.c:		tmp = *i;
./srcs/read/actions.c:		while (result[*i + 1])
./srcs/read/actions.c:		{
./srcs/read/actions.c:			result[*i] = result[*i + 1];
./srcs/read/actions.c:			++*i;
./srcs/read/actions.c:		}
./srcs/read/actions.c:		result[*i] = '\0';
./srcs/read/actions.c:		*i = tmp;
./srcs/read/actions.c:	}
./srcs/read/actions.c:	return (result);
./srcs/read/actions.c:}
Binary file ./srcs/read/spe_autocomp.o matches
Binary file ./srcs/read/read.o matches
Binary file ./srcs/read/syntax_color.o matches
Binary file ./srcs/read/show_autocomplete.o matches
Binary file ./srcs/read/history.o matches
Binary file ./srcs/read/parsing_man.o matches
Binary file ./srcs/pipe/check_redirection.o matches
./srcs/pipe/pipe.c:/* ************************************************************************** */
./srcs/pipe/pipe.c:/*                                                                            */
./srcs/pipe/pipe.c:/*                                                        :::      ::::::::   */
./srcs/pipe/pipe.c:/*   pipe.c                                             :+:      :+:    :+:   */
./srcs/pipe/pipe.c:/*                                                    +:+ +:+         +:+     */
./srcs/pipe/pipe.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/pipe/pipe.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/pipe/pipe.c:/*   Created: 2014/02/25 13:54:10 by lsolofri          #+#    #+#             */
./srcs/pipe/pipe.c:/*   Updated: 2014/03/23 12:55:57 by lsolofri         ###   ########.fr       */
./srcs/pipe/pipe.c:/*                                                                            */
./srcs/pipe/pipe.c:/* ************************************************************************** */
./srcs/pipe/pipe.c:
./srcs/pipe/pipe.c:#include "../../includes/msh.h"
./srcs/pipe/pipe.c:
./srcs/pipe/pipe.c:void	go_pipe(char **tab2)
./srcs/pipe/pipe.c:{
./srcs/pipe/pipe.c:	int		fd_pipe[2];
./srcs/pipe/pipe.c:	int		fd_in;
./srcs/pipe/pipe.c:	int		i;
./srcs/pipe/pipe.c:	char	**tab;
./srcs/pipe/pipe.c:	t_command	*list;
./srcs/pipe/pipe.c:
./srcs/pipe/pipe.c:	tab = join_tab(tab2);
./srcs/pipe/pipe.c:	i = 0;
./srcs/pipe/pipe.c:	while (tab[i])
./srcs/pipe/pipe.c:	{
./srcs/pipe/pipe.c:		pipe(fd_pipe);
./srcs/pipe/pipe.c:		if (!fork())
./srcs/pipe/pipe.c:		{
./srcs/pipe/pipe.c:			dup2(fd_in, 0);
./srcs/pipe/pipe.c:			if (tab[i + 1])
./srcs/pipe/pipe.c:				dup2(fd_pipe[1], 1);
./srcs/pipe/pipe.c:			close(fd_pipe[0]);
./srcs/pipe/pipe.c:			list = quick_parse(tab[i]);
./srcs/pipe/pipe.c:			exec_cmd(list->cmd);
./srcs/pipe/pipe.c:		}
./srcs/pipe/pipe.c:		else
./srcs/pipe/pipe.c:		{
./srcs/pipe/pipe.c:			wait(0);
./srcs/pipe/pipe.c:			close(fd_pipe[1]);
./srcs/pipe/pipe.c:			fd_in = fd_pipe[0];
./srcs/pipe/pipe.c:			++i;
./srcs/pipe/pipe.c:		}
./srcs/pipe/pipe.c:	}
./srcs/pipe/pipe.c:	_exit(0);
./srcs/pipe/pipe.c:}
./srcs/pipe/check_redirection.c:/* ************************************************************************** */
./srcs/pipe/check_redirection.c:/*                                                                            */
./srcs/pipe/check_redirection.c:/*                                                        :::      ::::::::   */
./srcs/pipe/check_redirection.c:/*   check_redirection.c                                :+:      :+:    :+:   */
./srcs/pipe/check_redirection.c:/*                                                    +:+ +:+         +:+     */
./srcs/pipe/check_redirection.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/pipe/check_redirection.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/pipe/check_redirection.c:/*   Created: 2014/02/25 11:32:03 by lsolofri          #+#    #+#             */
./srcs/pipe/check_redirection.c:/*   Updated: 2014/03/13 12:29:42 by lsolofri         ###   ########.fr       */
./srcs/pipe/check_redirection.c:/*                                                                            */
./srcs/pipe/check_redirection.c:/* ************************************************************************** */
./srcs/pipe/check_redirection.c:
./srcs/pipe/check_redirection.c:#include "../../includes/msh.h"
./srcs/pipe/check_redirection.c:
./srcs/pipe/check_redirection.c:int		check_redirection(char **tab)
./srcs/pipe/check_redirection.c:{
./srcs/pipe/check_redirection.c:	int		i;
./srcs/pipe/check_redirection.c:	int		v;
./srcs/pipe/check_redirection.c:
./srcs/pipe/check_redirection.c:	i = 0;
./srcs/pipe/check_redirection.c:	v = -1;
./srcs/pipe/check_redirection.c:	while (tab[i])
./srcs/pipe/check_redirection.c:	{
./srcs/pipe/check_redirection.c:		if (!ft_strcmp(tab[i], "<"))
./srcs/pipe/check_redirection.c:		{
./srcs/pipe/check_redirection.c:			infile(tab[i + 1]);
./srcs/pipe/check_redirection.c:			re_tab(tab, i);
./srcs/pipe/check_redirection.c:		}
./srcs/pipe/check_redirection.c:		else
./srcs/pipe/check_redirection.c:			++i;
./srcs/pipe/check_redirection.c:	}
./srcs/pipe/check_redirection.c:	i = 0;
./srcs/pipe/check_redirection.c:	if (!tab[i])
./srcs/pipe/check_redirection.c:	{
./srcs/pipe/check_redirection.c:		pre_exec("cat");
./srcs/pipe/check_redirection.c:		_exit(0);
./srcs/pipe/check_redirection.c:	}
./srcs/pipe/check_redirection.c:	while (tab[i])
./srcs/pipe/check_redirection.c:	{
./srcs/pipe/check_redirection.c:		if (!ft_strcmp(tab[i], "<<"))
./srcs/pipe/check_redirection.c:		{
./srcs/pipe/check_redirection.c:			if (v != -1)
./srcs/pipe/check_redirection.c:			{
./srcs/pipe/check_redirection.c:				re_tab(tab, v);
./srcs/pipe/check_redirection.c:				i -= 2;
./srcs/pipe/check_redirection.c:			}
./srcs/pipe/check_redirection.c:			v = i;
./srcs/pipe/check_redirection.c:		}
./srcs/pipe/check_redirection.c:		++i;
./srcs/pipe/check_redirection.c:	}
./srcs/pipe/check_redirection.c:	if (v != -1)
./srcs/pipe/check_redirection.c:	{
./srcs/pipe/check_redirection.c:		spe_infile(tab[v + 1]);
./srcs/pipe/check_redirection.c:		re_tab(tab, v);
./srcs/pipe/check_redirection.c:	}
./srcs/pipe/check_redirection.c:	i = 0;
./srcs/pipe/check_redirection.c:	while (tab[i])
./srcs/pipe/check_redirection.c:	{
./srcs/pipe/check_redirection.c:		if (!ft_strcmp(tab[i], ">"))
./srcs/pipe/check_redirection.c:		{
./srcs/pipe/check_redirection.c:			outfile(tab[i + 1]);
./srcs/pipe/check_redirection.c:			re_tab(tab, i);
./srcs/pipe/check_redirection.c:		}
./srcs/pipe/check_redirection.c:		else
./srcs/pipe/check_redirection.c:			++i;
./srcs/pipe/check_redirection.c:	}
./srcs/pipe/check_redirection.c:	i = 0;
./srcs/pipe/check_redirection.c:	while (tab[i])
./srcs/pipe/check_redirection.c:	{
./srcs/pipe/check_redirection.c:		if (!ft_strcmp(tab[i], ">>"))
./srcs/pipe/check_redirection.c:		{
./srcs/pipe/check_redirection.c:			spe_outfile(tab[i + 1]);
./srcs/pipe/check_redirection.c:			re_tab(tab, i);
./srcs/pipe/check_redirection.c:		}
./srcs/pipe/check_redirection.c:		else
./srcs/pipe/check_redirection.c:			++i;
./srcs/pipe/check_redirection.c:	}
./srcs/pipe/check_redirection.c:	i = 0;
./srcs/pipe/check_redirection.c:	while (tab[i] && ft_strcmp(tab[i], "|"))
./srcs/pipe/check_redirection.c:		++i;
./srcs/pipe/check_redirection.c:	if (tab[i])
./srcs/pipe/check_redirection.c:	{
./srcs/pipe/check_redirection.c:		go_pipe(tab);
./srcs/pipe/check_redirection.c:		return (0);
./srcs/pipe/check_redirection.c:	}
./srcs/pipe/check_redirection.c:	return (1);
./srcs/pipe/check_redirection.c:}
Binary file ./srcs/pipe/pipe.o matches
Binary file ./srcs/pipe/redirection.o matches
./srcs/pipe/pipe_function.c:/* ************************************************************************** */
./srcs/pipe/pipe_function.c:/*                                                                            */
./srcs/pipe/pipe_function.c:/*                                                        :::      ::::::::   */
./srcs/pipe/pipe_function.c:/*   pipe_function.c                                    :+:      :+:    :+:   */
./srcs/pipe/pipe_function.c:/*                                                    +:+ +:+         +:+     */
./srcs/pipe/pipe_function.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/pipe/pipe_function.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/pipe/pipe_function.c:/*   Created: 2014/02/25 13:46:37 by lsolofri          #+#    #+#             */
./srcs/pipe/pipe_function.c:/*   Updated: 2014/03/23 16:32:53 by lsolofri         ###   ########.fr       */
./srcs/pipe/pipe_function.c:/*                                                                            */
./srcs/pipe/pipe_function.c:/* ************************************************************************** */
./srcs/pipe/pipe_function.c:
./srcs/pipe/pipe_function.c:#include "../../includes/msh.h"
./srcs/pipe/pipe_function.c:
./srcs/pipe/pipe_function.c:char	**join_tab(char **tab)
./srcs/pipe/pipe_function.c:{
./srcs/pipe/pipe_function.c:	char	*result;
./srcs/pipe/pipe_function.c:	char	**result_tab;
./srcs/pipe/pipe_function.c:	int		i;
./srcs/pipe/pipe_function.c:
./srcs/pipe/pipe_function.c:	i = 0;
./srcs/pipe/pipe_function.c:	while (tab[i])
./srcs/pipe/pipe_function.c:	{
./srcs/pipe/pipe_function.c:		if (i == 0)
./srcs/pipe/pipe_function.c:			result = ft_strdup(tab[i]);
./srcs/pipe/pipe_function.c:		else
./srcs/pipe/pipe_function.c:			result = ft_strjoin(result, tab[i]);
./srcs/pipe/pipe_function.c:		if (tab[i + 1])
./srcs/pipe/pipe_function.c:			result = ft_strjoin(result, " ");
./srcs/pipe/pipe_function.c:		++i;
./srcs/pipe/pipe_function.c:	}
./srcs/pipe/pipe_function.c:	result_tab = ft_strsplit(result, '|');
./srcs/pipe/pipe_function.c:	return (result_tab);
./srcs/pipe/pipe_function.c:}
./srcs/pipe/pipe_function.c:
./srcs/pipe/pipe_function.c:char	*join_spe_tab(char **tab, int beg, int end)
./srcs/pipe/pipe_function.c:{
./srcs/pipe/pipe_function.c:	char	*result;
./srcs/pipe/pipe_function.c:
./srcs/pipe/pipe_function.c:	result = NULL;
./srcs/pipe/pipe_function.c:	while (beg < end)
./srcs/pipe/pipe_function.c:	{
./srcs/pipe/pipe_function.c:		if (!result)
./srcs/pipe/pipe_function.c:			result = ft_strdup(tab[beg]);
./srcs/pipe/pipe_function.c:		else
./srcs/pipe/pipe_function.c:			result = ft_strjoin(result, tab[beg]);
./srcs/pipe/pipe_function.c:		result = ft_strjoin(result, " ");
./srcs/pipe/pipe_function.c:		beg++;
./srcs/pipe/pipe_function.c:	}
./srcs/pipe/pipe_function.c:	return (result);
./srcs/pipe/pipe_function.c:}
Binary file ./srcs/pipe/pipe_function.o matches
./srcs/pipe/redirection.c:/* ************************************************************************** */
./srcs/pipe/redirection.c:/*                                                                            */
./srcs/pipe/redirection.c:/*                                                        :::      ::::::::   */
./srcs/pipe/redirection.c:/*   redirection.c                                      :+:      :+:    :+:   */
./srcs/pipe/redirection.c:/*                                                    +:+ +:+         +:+     */
./srcs/pipe/redirection.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/pipe/redirection.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/pipe/redirection.c:/*   Created: 2014/02/25 11:34:13 by lsolofri          #+#    #+#             */
./srcs/pipe/redirection.c:/*   Updated: 2014/03/13 09:06:46 by lsolofri         ###   ########.fr       */
./srcs/pipe/redirection.c:/*                                                                            */
./srcs/pipe/redirection.c:/* ************************************************************************** */
./srcs/pipe/redirection.c:
./srcs/pipe/redirection.c:#include "../../includes/msh.h"
./srcs/pipe/redirection.c:
./srcs/pipe/redirection.c:void	infile(char *str)
./srcs/pipe/redirection.c:{
./srcs/pipe/redirection.c:	int		fd;
./srcs/pipe/redirection.c:
./srcs/pipe/redirection.c:	fd = open(str, O_RDONLY);
./srcs/pipe/redirection.c:	if (fd == -1)
./srcs/pipe/redirection.c:	{
./srcs/pipe/redirection.c:		err_no_file(str);
./srcs/pipe/redirection.c:		_exit(0);
./srcs/pipe/redirection.c:	}
./srcs/pipe/redirection.c:	else
./srcs/pipe/redirection.c:		dup2(fd, 0);
./srcs/pipe/redirection.c:	close(fd);
./srcs/pipe/redirection.c:}
./srcs/pipe/redirection.c:
./srcs/pipe/redirection.c:void	spe_infile(char *str)
./srcs/pipe/redirection.c:{
./srcs/pipe/redirection.c:	char	*buffer;
./srcs/pipe/redirection.c:	int		fd_pipe[2];
./srcs/pipe/redirection.c:	char	*result;
./srcs/pipe/redirection.c:	int		i;
./srcs/pipe/redirection.c:
./srcs/pipe/redirection.c:	i = 0;
./srcs/pipe/redirection.c:	if (pipe(fd_pipe))
./srcs/pipe/redirection.c:		return ;
./srcs/pipe/redirection.c:	buffer = NULL;
./srcs/pipe/redirection.c:	while (1)
./srcs/pipe/redirection.c:	{
./srcs/pipe/redirection.c:		ft_putstr("manual_entry>");
./srcs/pipe/redirection.c:		buffer = take_cmd(1);
./srcs/pipe/redirection.c:		if (ft_strcmp(buffer, str))
./srcs/pipe/redirection.c:		{
./srcs/pipe/redirection.c:			if (i == 0)
./srcs/pipe/redirection.c:				result = ft_strdup(buffer);
./srcs/pipe/redirection.c:			else
./srcs/pipe/redirection.c:				result = ft_strjoin(ft_strjoin(result, "\n"), buffer);
./srcs/pipe/redirection.c:			write(fd_pipe[1], buffer, ft_strlen(buffer));
./srcs/pipe/redirection.c:			write(fd_pipe[1], "\n", 1);
./srcs/pipe/redirection.c:		}
./srcs/pipe/redirection.c:		else
./srcs/pipe/redirection.c:			break ;
./srcs/pipe/redirection.c:		buffer = NULL;
./srcs/pipe/redirection.c:		++i;
./srcs/pipe/redirection.c:	}
./srcs/pipe/redirection.c:	close(fd_pipe[1]);
./srcs/pipe/redirection.c:	dup2(fd_pipe[0], 0);
./srcs/pipe/redirection.c:	close(fd_pipe[0]);
./srcs/pipe/redirection.c:}
./srcs/pipe/redirection.c:
./srcs/pipe/redirection.c:void	outfile(char *str)
./srcs/pipe/redirection.c:{
./srcs/pipe/redirection.c:	int		fd;
./srcs/pipe/redirection.c:
./srcs/pipe/redirection.c:	fd = open(str, O_TRUNC | O_WRONLY | O_CREAT, 0777);
./srcs/pipe/redirection.c:	dup2(fd, 1);
./srcs/pipe/redirection.c:	close(fd);
./srcs/pipe/redirection.c:}
./srcs/pipe/redirection.c:
./srcs/pipe/redirection.c:void	spe_outfile(char *str)
./srcs/pipe/redirection.c:{
./srcs/pipe/redirection.c:	int		fd;
./srcs/pipe/redirection.c:
./srcs/pipe/redirection.c:	fd = open(str, O_APPEND | O_WRONLY | O_CREAT, 0777);
./srcs/pipe/redirection.c:	dup2(fd, 1);
./srcs/pipe/redirection.c:	close(fd);
./srcs/pipe/redirection.c:}
./srcs/pipe/redirection.c:
./srcs/pipe/redirection.c:char	**re_tab(char **tab, int i)
./srcs/pipe/redirection.c:{
./srcs/pipe/redirection.c:	while (tab[i + 2])
./srcs/pipe/redirection.c:	{
./srcs/pipe/redirection.c:		tab[i] = tab[i + 2];
./srcs/pipe/redirection.c:		++i;
./srcs/pipe/redirection.c:	}
./srcs/pipe/redirection.c:	tab[i] = NULL;
./srcs/pipe/redirection.c:	return (tab);
./srcs/pipe/redirection.c:}
./srcs/operators/operator.c:/* ************************************************************************** */
./srcs/operators/operator.c:/*                                                                            */
./srcs/operators/operator.c:/*                                                        :::      ::::::::   */
./srcs/operators/operator.c:/*   operator.c                                         :+:      :+:    :+:   */
./srcs/operators/operator.c:/*                                                    +:+ +:+         +:+     */
./srcs/operators/operator.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/operators/operator.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/operators/operator.c:/*   Created: 2014/03/13 11:59:40 by lsolofri          #+#    #+#             */
./srcs/operators/operator.c:/*   Updated: 2014/03/23 16:32:18 by lsolofri         ###   ########.fr       */
./srcs/operators/operator.c:/*                                                                            */
./srcs/operators/operator.c:/* ************************************************************************** */
./srcs/operators/operator.c:
./srcs/operators/operator.c:#include "../../includes/msh.h"
./srcs/operators/operator.c:
./srcs/operators/operator.c:char	*split_tab(char **tab, int i)
./srcs/operators/operator.c:{
./srcs/operators/operator.c:	char	*beg;
./srcs/operators/operator.c:	int		v;
./srcs/operators/operator.c:
./srcs/operators/operator.c:	v = 0;
./srcs/operators/operator.c:	while (v < i && tab[i])
./srcs/operators/operator.c:	{
./srcs/operators/operator.c:		if (v == 0)
./srcs/operators/operator.c:			beg = ft_strdup(tab[v]);
./srcs/operators/operator.c:		else
./srcs/operators/operator.c:			beg = ft_strjoin(beg, tab[v]);
./srcs/operators/operator.c:		beg = ft_strjoin(beg, " ");
./srcs/operators/operator.c:		++v;
./srcs/operators/operator.c:	}
./srcs/operators/operator.c:	v = 0;
./srcs/operators/operator.c:	++i;
./srcs/operators/operator.c:	while (tab[i])
./srcs/operators/operator.c:	{
./srcs/operators/operator.c:		tab[v] = tab[i];
./srcs/operators/operator.c:		++v;
./srcs/operators/operator.c:		++i;
./srcs/operators/operator.c:	}
./srcs/operators/operator.c:	tab[v] = NULL;
./srcs/operators/operator.c:	return (beg);
./srcs/operators/operator.c:}
./srcs/operators/operator.c:
./srcs/operators/operator.c:void	check_operators(char **tab)
./srcs/operators/operator.c:{
./srcs/operators/operator.c:		int		i;
./srcs/operators/operator.c:		int		v;
./srcs/operators/operator.c:
./srcs/operators/operator.c:		i = 0;
./srcs/operators/operator.c:		while (tab[i])
./srcs/operators/operator.c:		{
./srcs/operators/operator.c:			if (!ft_strcmp(tab[i], "("))
./srcs/operators/operator.c:			{
./srcs/operators/operator.c:				v = i;
./srcs/operators/operator.c:				while (ft_strcmp(tab[i], ")") && tab[i])
./srcs/operators/operator.c:					++i;
./srcs/operators/operator.c:				if (!fork())
./srcs/operators/operator.c:					pre_exec(join_spe_tab(tab, v + 1, i));
./srcs/operators/operator.c:				wait(0);
./srcs/operators/operator.c:				_exit(0);
./srcs/operators/operator.c:			}
./srcs/operators/operator.c:			if (!(ft_strcmp(tab[i], "&&")))
./srcs/operators/operator.c:			{
./srcs/operators/operator.c:				if (pre_exec(split_tab(tab, i)))
./srcs/operators/operator.c:					_exit(0);
./srcs/operators/operator.c:			}
./srcs/operators/operator.c:			else if (!ft_strcmp(tab[i], "&"))
./srcs/operators/operator.c:			{
./srcs/operators/operator.c:				pre_exec_nowait(split_tab(tab, i));
./srcs/operators/operator.c:				check_operators(tab);
./srcs/operators/operator.c:			}
./srcs/operators/operator.c:			else if (!(ft_strcmp(tab[i], "||")))
./srcs/operators/operator.c:			{
./srcs/operators/operator.c:				v = pre_exec(split_tab(tab, i));
./srcs/operators/operator.c:				if (v == 0 || v == 2)
./srcs/operators/operator.c:					_exit(0);
./srcs/operators/operator.c:			}
./srcs/operators/operator.c:			++i;
./srcs/operators/operator.c:		}
./srcs/operators/operator.c:}
Binary file ./srcs/operators/operator.o matches
./srcs/autocomplete/autocomp.c:/* ************************************************************************** */
./srcs/autocomplete/autocomp.c:/*                                                                            */
./srcs/autocomplete/autocomp.c:/*                                                        :::      ::::::::   */
./srcs/autocomplete/autocomp.c:/*   autocomp.c                                         :+:      :+:    :+:   */
./srcs/autocomplete/autocomp.c:/*                                                    +:+ +:+         +:+     */
./srcs/autocomplete/autocomp.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/autocomplete/autocomp.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/autocomplete/autocomp.c:/*   Created: 2014/03/16 18:13:32 by lsolofri          #+#    #+#             */
./srcs/autocomplete/autocomp.c:/*   Updated: 2014/03/18 16:41:01 by lsolofri         ###   ########.fr       */
./srcs/autocomplete/autocomp.c:/*                                                                            */
./srcs/autocomplete/autocomp.c:/* ************************************************************************** */
./srcs/autocomplete/autocomp.c:
./srcs/autocomplete/autocomp.c:#include "../../includes/msh.h"
./srcs/autocomplete/autocomp.c:
./srcs/autocomplete/autocomp.c:char	*argument_completion(char *str)
./srcs/autocomplete/autocomp.c:{
./srcs/autocomplete/autocomp.c:	int		i;
./srcs/autocomplete/autocomp.c:	char	*word;
./srcs/autocomplete/autocomp.c:	glob_t	list;
./srcs/autocomplete/autocomp.c:
./srcs/autocomplete/autocomp.c:	if (str)
./srcs/autocomplete/autocomp.c:	{
./srcs/autocomplete/autocomp.c:		i = ft_strlen(str);
./srcs/autocomplete/autocomp.c:		while (str[i] != ' ' && i > 0)
./srcs/autocomplete/autocomp.c:			--i;
./srcs/autocomplete/autocomp.c:		word = ft_strsub(str, i + 1, ft_strlen(str) - i);
./srcs/autocomplete/autocomp.c:		glob(ft_strjoin(word, "*"), GLOB_NOCHECK, 0, &list);
./srcs/autocomplete/autocomp.c:		i = 0;
./srcs/autocomplete/autocomp.c:		ft_putstr("\n");
./srcs/autocomplete/autocomp.c:		if (list.gl_pathc == 0)
./srcs/autocomplete/autocomp.c:			return (NULL);
./srcs/autocomplete/autocomp.c:		while (list.gl_pathv[i])
./srcs/autocomplete/autocomp.c:			ft_putendl(list.gl_pathv[i++]);
./srcs/autocomplete/autocomp.c:		prompt();
./srcs/autocomplete/autocomp.c:		ft_putstr("     ");
./srcs/autocomplete/autocomp.c:	}
./srcs/autocomplete/autocomp.c:	return (NULL);
./srcs/autocomplete/autocomp.c:}
Binary file ./srcs/autocomplete/autocomp.o matches
Binary file ./srcs/environ/get_man_path.o matches
./srcs/environ/get_man_path.c:/* ************************************************************************** */
./srcs/environ/get_man_path.c:/*                                                                            */
./srcs/environ/get_man_path.c:/*                                                        :::      ::::::::   */
./srcs/environ/get_man_path.c:/*   get_man_path.c                                     :+:      :+:    :+:   */
./srcs/environ/get_man_path.c:/*                                                    +:+ +:+         +:+     */
./srcs/environ/get_man_path.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/environ/get_man_path.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/environ/get_man_path.c:/*   Created: 2014/02/14 10:04:37 by lsolofri          #+#    #+#             */
./srcs/environ/get_man_path.c:/*   Updated: 2014/03/13 08:52:51 by lsolofri         ###   ########.fr       */
./srcs/environ/get_man_path.c:/*                                                                            */
./srcs/environ/get_man_path.c:/* ************************************************************************** */
./srcs/environ/get_man_path.c:
./srcs/environ/get_man_path.c:#include "../../includes/msh.h"
./srcs/environ/get_man_path.c:
./srcs/environ/get_man_path.c:char	*get_man_path(void)
./srcs/environ/get_man_path.c:{
./srcs/environ/get_man_path.c:	char	*cmd[] = {"/usr/bin/man", "--path", NULL};
./srcs/environ/get_man_path.c:	char	*result;
./srcs/environ/get_man_path.c:	int		fd[2];
./srcs/environ/get_man_path.c:	int		ret;
./srcs/environ/get_man_path.c:
./srcs/environ/get_man_path.c:	if (pipe(fd) == -1)
./srcs/environ/get_man_path.c:		return (NULL);
./srcs/environ/get_man_path.c:	result = (char *)ft_memalloc(sizeof(char) * 1500);
./srcs/environ/get_man_path.c:	if (!result)
./srcs/environ/get_man_path.c:		return (NULL);
./srcs/environ/get_man_path.c:	if (fork() == 0)
./srcs/environ/get_man_path.c:	{
./srcs/environ/get_man_path.c:		if (close(fd[0]) == -1)
./srcs/environ/get_man_path.c:			return (NULL);
./srcs/environ/get_man_path.c:		if (dup2(fd[1], 1) == -1)
./srcs/environ/get_man_path.c:			return (NULL);
./srcs/environ/get_man_path.c:		if (close(fd[1]) == -1)
./srcs/environ/get_man_path.c:			return (NULL);
./srcs/environ/get_man_path.c:		if (execve(cmd[0], cmd, NULL) == -1)
./srcs/environ/get_man_path.c:			return (NULL);
./srcs/environ/get_man_path.c:	}
./srcs/environ/get_man_path.c:	else
./srcs/environ/get_man_path.c:	{
./srcs/environ/get_man_path.c:		wait(0);
./srcs/environ/get_man_path.c:		if (close(fd[1]) == -1)
./srcs/environ/get_man_path.c:			return (NULL);
./srcs/environ/get_man_path.c:		if ((ret = read(fd[0], result, 1500)) != 0)
./srcs/environ/get_man_path.c:			result[ret - 1] = '\0';
./srcs/environ/get_man_path.c:	}
./srcs/environ/get_man_path.c:	close(fd[0]);
./srcs/environ/get_man_path.c:	close(fd[1]);
./srcs/environ/get_man_path.c:	return (result);
./srcs/environ/get_man_path.c:}
Binary file ./srcs/environ/ft_env.o matches
./srcs/environ/ft_env.c:/* ************************************************************************** */
./srcs/environ/ft_env.c:/*                                                                            */
./srcs/environ/ft_env.c:/*                                                        :::      ::::::::   */
./srcs/environ/ft_env.c:/*   ft_env2.c                                          :+:      :+:    :+:   */
./srcs/environ/ft_env.c:/*                                                    +:+ +:+         +:+     */
./srcs/environ/ft_env.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/environ/ft_env.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/environ/ft_env.c:/*   Created: 2014/02/25 00:46:22 by lsolofri          #+#    #+#             */
./srcs/environ/ft_env.c:/*   Updated: 2014/03/23 15:38:12 by lsolofri         ###   ########.fr       */
./srcs/environ/ft_env.c:/*                                                                            */
./srcs/environ/ft_env.c:/* ************************************************************************** */
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:#include "../../includes/msh.h"
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:t_env	*add_env(t_env *env, char *name, char *value, int protect)
./srcs/environ/ft_env.c:{
./srcs/environ/ft_env.c:	t_env	*tmp;
./srcs/environ/ft_env.c:	t_env	*tmp2;
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:	tmp2 = env;
./srcs/environ/ft_env.c:	tmp = (t_env *)ft_memalloc(sizeof(t_env));
./srcs/environ/ft_env.c:	tmp->name = name;
./srcs/environ/ft_env.c:	tmp->value = value;
./srcs/environ/ft_env.c:	tmp->protect = protect;
./srcs/environ/ft_env.c:	tmp->next = NULL;
./srcs/environ/ft_env.c:	if (env == NULL)
./srcs/environ/ft_env.c:		return (tmp);
./srcs/environ/ft_env.c:	while (tmp2->next != NULL)
./srcs/environ/ft_env.c:		tmp2 = tmp2->next;
./srcs/environ/ft_env.c:	tmp2->next = tmp;
./srcs/environ/ft_env.c:	return (env);
./srcs/environ/ft_env.c:}
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:void	new_env(char **env)
./srcs/environ/ft_env.c:{
./srcs/environ/ft_env.c:	char	**tmp;
./srcs/environ/ft_env.c:	int		i;
./srcs/environ/ft_env.c:	int		protect;
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:	i = 0;
./srcs/environ/ft_env.c:	while (env[i])
./srcs/environ/ft_env.c:		++i;
./srcs/environ/ft_env.c:	if (i == 0)
./srcs/environ/ft_env.c:		show_error_exit("Could not set environnement");
./srcs/environ/ft_env.c:	while (*env)
./srcs/environ/ft_env.c:	{
./srcs/environ/ft_env.c:		protect = 0;
./srcs/environ/ft_env.c:		tmp = ft_strsplit(*env, '=');
./srcs/environ/ft_env.c:		if (tmp[0] && tmp[1])
./srcs/environ/ft_env.c:		{
./srcs/environ/ft_env.c:			if (!ft_strcmp(tmp[0], "PATH") || !ft_strcmp(tmp[0], "HOME") || !ft_strcmp(tmp[0], "USER"))
./srcs/environ/ft_env.c:				protect = 1;
./srcs/environ/ft_env.c:			g_env = add_env(g_env, tmp[0], tmp[1], protect);
./srcs/environ/ft_env.c:		}
./srcs/environ/ft_env.c:		env++;
./srcs/environ/ft_env.c:	}
./srcs/environ/ft_env.c:}
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:void	print_list(t_env *env)
./srcs/environ/ft_env.c:{
./srcs/environ/ft_env.c:	while (env)
./srcs/environ/ft_env.c:	{
./srcs/environ/ft_env.c:		ft_putstr(env->name);
./srcs/environ/ft_env.c:		ft_putstr("=");
./srcs/environ/ft_env.c:		if (env->value)
./srcs/environ/ft_env.c:			ft_putendl(env->value);
./srcs/environ/ft_env.c:		else
./srcs/environ/ft_env.c:			ft_putchar('\n');
./srcs/environ/ft_env.c:		env = env->next;
./srcs/environ/ft_env.c:	}
./srcs/environ/ft_env.c:}
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:char	*find_value_envir(t_env *env, char *str)
./srcs/environ/ft_env.c:{
./srcs/environ/ft_env.c:	while (env != NULL && (ft_strcmp(env->name, str) != 0))
./srcs/environ/ft_env.c:		env = env->next;
./srcs/environ/ft_env.c:	if (env)
./srcs/environ/ft_env.c:		return (env->value);
./srcs/environ/ft_env.c:	else
./srcs/environ/ft_env.c:		return (NULL);
./srcs/environ/ft_env.c:}
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:t_env	*ft_unsetenv(t_env *env, char *str)
./srcs/environ/ft_env.c:{
./srcs/environ/ft_env.c:	t_env	*tmp;
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:	if (!env)
./srcs/environ/ft_env.c:		return (NULL);
./srcs/environ/ft_env.c:	if (!ft_strcmp(env->name, str) && env->protect == 0)
./srcs/environ/ft_env.c:	{
./srcs/environ/ft_env.c:		tmp = env->next;
./srcs/environ/ft_env.c:		free(env);
./srcs/environ/ft_env.c:		tmp = ft_unsetenv(tmp, str);
./srcs/environ/ft_env.c:		return (tmp);
./srcs/environ/ft_env.c:	}
./srcs/environ/ft_env.c:	else
./srcs/environ/ft_env.c:	{
./srcs/environ/ft_env.c:		env->next = ft_unsetenv(env->next, str);
./srcs/environ/ft_env.c:		return (env);
./srcs/environ/ft_env.c:	}
./srcs/environ/ft_env.c:}
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:t_env	*ft_setenv(t_env *env, char *name, char *value)
./srcs/environ/ft_env.c:{
./srcs/environ/ft_env.c:	env = ft_unsetenv(env, name);
./srcs/environ/ft_env.c:	if (!ft_strcmp(name, "MANPATH"))
./srcs/environ/ft_env.c:		env = add_env(env, name, ft_strdup(value), 1);
./srcs/environ/ft_env.c:	else
./srcs/environ/ft_env.c:		env = add_env(env, name, value, 0);
./srcs/environ/ft_env.c:	return (env);
./srcs/environ/ft_env.c:}
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:int		list_len(t_env *env)
./srcs/environ/ft_env.c:{
./srcs/environ/ft_env.c:	int		i;
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:	i = 0;
./srcs/environ/ft_env.c:	while (env)
./srcs/environ/ft_env.c:	{
./srcs/environ/ft_env.c:		++i;
./srcs/environ/ft_env.c:		env = env->next;
./srcs/environ/ft_env.c:	}
./srcs/environ/ft_env.c:	return (i);
./srcs/environ/ft_env.c:}
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:char	**make_env_tab(t_env *env)
./srcs/environ/ft_env.c:{
./srcs/environ/ft_env.c:	int		i;
./srcs/environ/ft_env.c:	char	**result;
./srcs/environ/ft_env.c:
./srcs/environ/ft_env.c:	i = list_len(env);
./srcs/environ/ft_env.c:	result = (char **)ft_memalloc(sizeof(char *) * i + 1);
./srcs/environ/ft_env.c:	i = 0;
./srcs/environ/ft_env.c:	while (env)
./srcs/environ/ft_env.c:	{
./srcs/environ/ft_env.c:		result[i++] = ft_strjoin(env->name, ft_strjoin("=", env->value));
./srcs/environ/ft_env.c:		env = env->next;
./srcs/environ/ft_env.c:	}
./srcs/environ/ft_env.c:	result[i] = NULL;
./srcs/environ/ft_env.c:	return (result);
./srcs/environ/ft_env.c:}
./srcs/prompt/prompt.c:/* ************************************************************************** */
./srcs/prompt/prompt.c:/*                                                                            */
./srcs/prompt/prompt.c:/*                                                        :::      ::::::::   */
./srcs/prompt/prompt.c:/*   prompt_interpreter.c                               :+:      :+:    :+:   */
./srcs/prompt/prompt.c:/*                                                    +:+ +:+         +:+     */
./srcs/prompt/prompt.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/prompt/prompt.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/prompt/prompt.c:/*   Created: 2014/02/21 15:55:53 by lsolofri          #+#    #+#             */
./srcs/prompt/prompt.c:/*   Updated: 2014/02/25 02:02:48 by lsolofri         ###   ########.fr       */
./srcs/prompt/prompt.c:/*                                                                            */
./srcs/prompt/prompt.c:/* ************************************************************************** */
./srcs/prompt/prompt.c:
./srcs/prompt/prompt.c:#include "../../includes/msh.h"
./srcs/prompt/prompt.c:
./srcs/prompt/prompt.c:void	basic_prompt(void)
./srcs/prompt/prompt.c:{
./srcs/prompt/prompt.c:	if (find_value_envir(g_env, "USER"))
./srcs/prompt/prompt.c:		ft_putstr(find_value_envir(g_env, "USER"));
./srcs/prompt/prompt.c:	else
./srcs/prompt/prompt.c:		ft_putstr("user");
./srcs/prompt/prompt.c:	ft_putchar('@');
./srcs/prompt/prompt.c:	if (find_value_envir(g_env, "GROUP"))
./srcs/prompt/prompt.c:		ft_putstr(find_value_envir(g_env, "GROUP"));
./srcs/prompt/prompt.c:	else
./srcs/prompt/prompt.c:		ft_putstr("group");
./srcs/prompt/prompt.c:	ft_putstr("-> ");
./srcs/prompt/prompt.c:}
./srcs/prompt/prompt.c:
./srcs/prompt/prompt.c:void	prompt(void)
./srcs/prompt/prompt.c:{
./srcs/prompt/prompt.c:	if (find_value_envir(g_env, "PROMPT"))
./srcs/prompt/prompt.c:		prompt_interpreter(find_value_envir(g_env, "PROMPT"));
./srcs/prompt/prompt.c:	else
./srcs/prompt/prompt.c:		basic_prompt();
./srcs/prompt/prompt.c:}
./srcs/prompt/prompt_interpreter.c:/* ************************************************************************** */
./srcs/prompt/prompt_interpreter.c:/*                                                                            */
./srcs/prompt/prompt_interpreter.c:/*                                                        :::      ::::::::   */
./srcs/prompt/prompt_interpreter.c:/*   prompt_interpreter.c                               :+:      :+:    :+:   */
./srcs/prompt/prompt_interpreter.c:/*                                                    +:+ +:+         +:+     */
./srcs/prompt/prompt_interpreter.c:/*   By: lsolofri <lsolofri@student.42.fr>          +#+  +:+       +#+        */
./srcs/prompt/prompt_interpreter.c:/*                                                +#+#+#+#+#+   +#+           */
./srcs/prompt/prompt_interpreter.c:/*   Created: 2014/02/21 16:30:44 by lsolofri          #+#    #+#             */
./srcs/prompt/prompt_interpreter.c:/*   Updated: 2014/03/18 19:28:40 by lsolofri         ###   ########.fr       */
./srcs/prompt/prompt_interpreter.c:/*                                                                            */
./srcs/prompt/prompt_interpreter.c:/* ************************************************************************** */
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:#include "../../includes/msh.h"
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:void	show_value_envir(char *str)
./srcs/prompt/prompt_interpreter.c:{
./srcs/prompt/prompt_interpreter.c:	if (find_value_envir(g_env, str))
./srcs/prompt/prompt_interpreter.c:		ft_putstr(find_value_envir(g_env, str));
./srcs/prompt/prompt_interpreter.c:}
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:void	home_pwd(void)
./srcs/prompt/prompt_interpreter.c:{
./srcs/prompt/prompt_interpreter.c:	char	*home;
./srcs/prompt/prompt_interpreter.c:	char	*pwd;
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:	home = find_value_envir(g_env, "HOME");
./srcs/prompt/prompt_interpreter.c:	pwd = find_value_envir(g_env, "PWD");
./srcs/prompt/prompt_interpreter.c:	if (home && pwd)
./srcs/prompt/prompt_interpreter.c:	{
./srcs/prompt/prompt_interpreter.c:		if (ft_strncmp(pwd, "/nfs", 4))
./srcs/prompt/prompt_interpreter.c:			home = ft_strjoin("/Volumes/DATA", home);
./srcs/prompt/prompt_interpreter.c:		if (ft_strncmp(home, pwd, ft_strlen(home)) == 0)
./srcs/prompt/prompt_interpreter.c:		{
./srcs/prompt/prompt_interpreter.c:			ft_putchar('~');
./srcs/prompt/prompt_interpreter.c:			write(1, &pwd[ft_strlen(home)], (ft_strlen(pwd) - ft_strlen(home)));
./srcs/prompt/prompt_interpreter.c:		}
./srcs/prompt/prompt_interpreter.c:		else
./srcs/prompt/prompt_interpreter.c:			ft_putstr(pwd);
./srcs/prompt/prompt_interpreter.c:	}
./srcs/prompt/prompt_interpreter.c:}
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:void	prompt_termcaps(char *str)
./srcs/prompt/prompt_interpreter.c:{
./srcs/prompt/prompt_interpreter.c:	struct termios	term;
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:	init_flag(&term);
./srcs/prompt/prompt_interpreter.c:	ft_putstr(tgetstr(str, NULL));
./srcs/prompt/prompt_interpreter.c:}
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:void	interprate_color(char *c)
./srcs/prompt/prompt_interpreter.c:{
./srcs/prompt/prompt_interpreter.c:	if (c)
./srcs/prompt/prompt_interpreter.c:	{
./srcs/prompt/prompt_interpreter.c:		if (ft_strcmp("RED", c) == 0)
./srcs/prompt/prompt_interpreter.c:			ft_putstr(RED);
./srcs/prompt/prompt_interpreter.c:		else if (ft_strcmp("BLUE", c) == 0)
./srcs/prompt/prompt_interpreter.c:			ft_putstr(BLUE);
./srcs/prompt/prompt_interpreter.c:		else if (ft_strcmp("GRAY", c) == 0)
./srcs/prompt/prompt_interpreter.c:			ft_putstr(GRAY);
./srcs/prompt/prompt_interpreter.c:		else if (ft_strcmp("YEL", c) == 0)
./srcs/prompt/prompt_interpreter.c:			ft_putstr(YEL);
./srcs/prompt/prompt_interpreter.c:		else if (ft_strcmp("GRE", c) == 0)
./srcs/prompt/prompt_interpreter.c:			ft_putstr(GRE);
./srcs/prompt/prompt_interpreter.c:		else if (ft_strcmp("MAG", c) == 0)
./srcs/prompt/prompt_interpreter.c:			ft_putstr(MAG);
./srcs/prompt/prompt_interpreter.c:		else if (ft_strcmp("SBLUE", c) == 0)
./srcs/prompt/prompt_interpreter.c:			ft_putstr(SBLUE);
./srcs/prompt/prompt_interpreter.c:		else if (ft_strcmp("DEF", c) == 0)
./srcs/prompt/prompt_interpreter.c:			ft_putstr(DEF);
./srcs/prompt/prompt_interpreter.c:	}
./srcs/prompt/prompt_interpreter.c:}
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:int		show_color(char *str, int i)
./srcs/prompt/prompt_interpreter.c:{
./srcs/prompt/prompt_interpreter.c:	int		v;
./srcs/prompt/prompt_interpreter.c:	int		j;
./srcs/prompt/prompt_interpreter.c:	char	*c;
./srcs/prompt/prompt_interpreter.c:	v = i + 1;
./srcs/prompt/prompt_interpreter.c:	j = 0;
./srcs/prompt/prompt_interpreter.c:	while (str[i] != '}' && str[i])
./srcs/prompt/prompt_interpreter.c:	{
./srcs/prompt/prompt_interpreter.c:		++i;
./srcs/prompt/prompt_interpreter.c:		++j;
./srcs/prompt/prompt_interpreter.c:	}
./srcs/prompt/prompt_interpreter.c:	c = ft_strsub(str, v, j - 1);
./srcs/prompt/prompt_interpreter.c:	interprate_color(c);
./srcs/prompt/prompt_interpreter.c:	return (i);
./srcs/prompt/prompt_interpreter.c:}
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:void	prompt_git(void)
./srcs/prompt/prompt_interpreter.c:{
./srcs/prompt/prompt_interpreter.c:	char	*result;
./srcs/prompt/prompt_interpreter.c:	int		i;
./srcs/prompt/prompt_interpreter.c:	int		v;
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:	i = 0;
./srcs/prompt/prompt_interpreter.c:	result = result_cmd("git branch");
./srcs/prompt/prompt_interpreter.c:	if (result)
./srcs/prompt/prompt_interpreter.c:	{
./srcs/prompt/prompt_interpreter.c:		if (ft_strncmp("fatal", result, 5))
./srcs/prompt/prompt_interpreter.c:		{
./srcs/prompt/prompt_interpreter.c:			while (result[i] && result[i] != '*')
./srcs/prompt/prompt_interpreter.c:				++i;
./srcs/prompt/prompt_interpreter.c:			v = i + 2;
./srcs/prompt/prompt_interpreter.c:			while (result[i] != '\n' && result[i])
./srcs/prompt/prompt_interpreter.c:				++i;
./srcs/prompt/prompt_interpreter.c:			ft_putstr(YEL);
./srcs/prompt/prompt_interpreter.c:			ft_putstr("(");
./srcs/prompt/prompt_interpreter.c:			write(1, &result[v], (i - v));
./srcs/prompt/prompt_interpreter.c:			ft_putstr(")");
./srcs/prompt/prompt_interpreter.c:			ft_putstr(DEF);
./srcs/prompt/prompt_interpreter.c:		}
./srcs/prompt/prompt_interpreter.c:		free(result);
./srcs/prompt/prompt_interpreter.c:	}
./srcs/prompt/prompt_interpreter.c:}
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:void	show_time(void)
./srcs/prompt/prompt_interpreter.c:{
./srcs/prompt/prompt_interpreter.c:	char	*result;
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:	result = result_cmd("date");
./srcs/prompt/prompt_interpreter.c:	if (result)
./srcs/prompt/prompt_interpreter.c:		write(1, &result[11], 5);
./srcs/prompt/prompt_interpreter.c:}
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:void	spe_pwd(char *str)
./srcs/prompt/prompt_interpreter.c:{
./srcs/prompt/prompt_interpreter.c:	int		i;
./srcs/prompt/prompt_interpreter.c:	int		v;
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:	i = 0;
./srcs/prompt/prompt_interpreter.c:	while (str[i])
./srcs/prompt/prompt_interpreter.c:	{
./srcs/prompt/prompt_interpreter.c:		if (str[i] == '/')
./srcs/prompt/prompt_interpreter.c:		{
./srcs/prompt/prompt_interpreter.c:			ft_putchar(str[i]);
./srcs/prompt/prompt_interpreter.c:			ft_putchar(str[++i]);
./srcs/prompt/prompt_interpreter.c:			v = i;
./srcs/prompt/prompt_interpreter.c:			while (str[i] != '/' && str[i])
./srcs/prompt/prompt_interpreter.c:				++i;
./srcs/prompt/prompt_interpreter.c:			if (!str[i])
./srcs/prompt/prompt_interpreter.c:			{
./srcs/prompt/prompt_interpreter.c:				v++;
./srcs/prompt/prompt_interpreter.c:				while (str[v])
./srcs/prompt/prompt_interpreter.c:					ft_putchar(str[v++]);
./srcs/prompt/prompt_interpreter.c:			}
./srcs/prompt/prompt_interpreter.c:			else
./srcs/prompt/prompt_interpreter.c:				i = v;
./srcs/prompt/prompt_interpreter.c:		}
./srcs/prompt/prompt_interpreter.c:		++i;
./srcs/prompt/prompt_interpreter.c:	}
./srcs/prompt/prompt_interpreter.c:}
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:void	prompt_interpreter(char *str)
./srcs/prompt/prompt_interpreter.c:{
./srcs/prompt/prompt_interpreter.c:	int		i;
./srcs/prompt/prompt_interpreter.c:
./srcs/prompt/prompt_interpreter.c:	i = 0;
./srcs/prompt/prompt_interpreter.c:	while (str[i])
./srcs/prompt/prompt_interpreter.c:	{
./srcs/prompt/prompt_interpreter.c:		if (str[i] == '%')
./srcs/prompt/prompt_interpreter.c:		{
./srcs/prompt/prompt_interpreter.c:			++i;
./srcs/prompt/prompt_interpreter.c:			if (str[i] == 'n')
./srcs/prompt/prompt_interpreter.c:				show_value_envir("USER");
./srcs/prompt/prompt_interpreter.c:			else if (str[i] == 'h')
./srcs/prompt/prompt_interpreter.c:				home_pwd();
./srcs/prompt/prompt_interpreter.c:			else if (str[i] == 'p')
./srcs/prompt/prompt_interpreter.c:				show_value_envir("PWD");
./srcs/prompt/prompt_interpreter.c:			else if (str[i] == 'g')
./srcs/prompt/prompt_interpreter.c:				show_value_envir("GROUP");
./srcs/prompt/prompt_interpreter.c:			else if (str[i] == 'u')
./srcs/prompt/prompt_interpreter.c:				prompt_termcaps("us");
./srcs/prompt/prompt_interpreter.c:			else if (str[i] == 's')
./srcs/prompt/prompt_interpreter.c:				prompt_termcaps("mr");
./srcs/prompt/prompt_interpreter.c:			else if (str[i] == 'e')
./srcs/prompt/prompt_interpreter.c:				prompt_termcaps("me");
./srcs/prompt/prompt_interpreter.c:			else if (str[i] == 'c')
./srcs/prompt/prompt_interpreter.c:				i = show_color(str, i + 1);
./srcs/prompt/prompt_interpreter.c:			else if (str[i] == 'G')
./srcs/prompt/prompt_interpreter.c:				prompt_git();
./srcs/prompt/prompt_interpreter.c:			else if (str[i] == 't')
./srcs/prompt/prompt_interpreter.c:				show_time();
./srcs/prompt/prompt_interpreter.c:			else if (str[i] == 'P')
./srcs/prompt/prompt_interpreter.c:				spe_pwd(find_value_envir(g_env, "PWD"));
./srcs/prompt/prompt_interpreter.c:			++i;
./srcs/prompt/prompt_interpreter.c:		}
./srcs/prompt/prompt_interpreter.c:		if (str[i] != '%')
./srcs/prompt/prompt_interpreter.c:		{
./srcs/prompt/prompt_interpreter.c:			ft_putchar(str[i]);
./srcs/prompt/prompt_interpreter.c:			++i;
./srcs/prompt/prompt_interpreter.c:		}
./srcs/prompt/prompt_interpreter.c:	}
./srcs/prompt/prompt_interpreter.c:}
Binary file ./srcs/prompt/prompt_interpreter.o matches
Binary file ./srcs/prompt/prompt.o matches
./Makefile:#******************************************************************************#
./Makefile:#                                                                              #
./Makefile:#                                                         :::      ::::::::    #
./Makefile:#    Makefile                                           :+:      :+:    :+:    #
./Makefile:#                                                     +:+ +:+         +:+      #
./Makefile:#    By: aardjoun <marvin@42.fr>                    +#+  +:+       +#+         #
./Makefile:#                                                 +#+#+#+#+#+   +#+            #
./Makefile:#    Created: 2014/02/14 17:00:44 by aardjoun          #+#    #+#              #
./Makefile:#    Updated: 2014/03/23 18:30:37 by lsolofri         ###   ########.fr        #
./Makefile:#                                                                              #
./Makefile:#******************************************************************************#
./Makefile:
./Makefile:NAME	=	MiShell
./Makefile:
./Makefile:SRCS	=	srcs/main/main.c\
./Makefile:			srcs/main/ft_mishell.c\
./Makefile:			srcs/main/built.c\
./Makefile:			srcs/main/options.c\
./Makefile:			srcs/environ/ft_env.c\
./Makefile:			srcs/environ/get_man_path.c\
./Makefile:			srcs/errors/error.c\
./Makefile:			srcs/errors/cd_error.c\
./Makefile:			srcs/functions/ft_isdigit.c\
./Makefile:			srcs/functions/ft_get_path.c\
./Makefile:			srcs/functions/ft_isprint.c\
./Makefile:			srcs/functions/ft_new_tab.c\
./Makefile:			srcs/functions/ft_putchar.c\
./Makefile:			srcs/functions/ft_putendl.c\
./Makefile:			srcs/functions/ft_putnbr.c\
./Makefile:			srcs/functions/ft_putstr.c\
./Makefile:			srcs/functions/ft_strcmp.c\
./Makefile:			srcs/functions/ft_strdup.c\
./Makefile:			srcs/functions/ft_strjoin.c\
./Makefile:			srcs/functions/ft_strlen.c\
./Makefile:			srcs/functions/ft_strncmp.c\
./Makefile:			srcs/functions/ft_strsplit.c\
./Makefile:			srcs/functions/ft_strsub.c\
./Makefile:			srcs/functions/ft_tablen.c\
./Makefile:			srcs/functions/ft_isalpha.c\
./Makefile:			srcs/functions/ft_itoa.c\
./Makefile:			srcs/functions/ft_tabncmp.c\
./Makefile:			srcs/functions/get_next_line.c\
./Makefile:			srcs/functions/ft_atoi.c\
./Makefile:			srcs/functions/ft_cmd_result.c\
./Makefile:			srcs/functions/welcome.c\
./Makefile:			srcs/functions/ft_insert_tab.c\
./Makefile:			srcs/functions/ft_memalloc.c\
./Makefile:			srcs/functions/ft_gc.c\
./Makefile:			srcs/functions/ft_gchelper.c\
./Makefile:			srcs/functions/ft_bzero.c\
./Makefile:			srcs/functions/ft_strnew.c\
./Makefile:			srcs/functions/ft_memcpy.c\
./Makefile:			srcs/read/actions.c\
./Makefile:			srcs/read/buttons.c\
./Makefile:			srcs/read/history.c\
./Makefile:			srcs/read/read.c\
./Makefile:			srcs/read/syntax_color.c\
./Makefile:			srcs/read/termcap.c\
./Makefile:			srcs/read/autocomplete.c\
./Makefile:			srcs/read/t_options.c\
./Makefile:			srcs/read/show_autocomplete.c\
./Makefile:			srcs/read/syntax_color_rest.c\
./Makefile:			srcs/read/show_option.c\
./Makefile:			srcs/read/parser_color.c\
./Makefile:			srcs/read/parsing_man.c\
./Makefile:			srcs/read/spe_autocomp.c\
./Makefile:			srcs/read/autocomplete_too_long.c\
./Makefile:			srcs/builtin/exit.c\
./Makefile:			srcs/builtin/echo.c\
./Makefile:			srcs/builtin/cd.c\
./Makefile:			srcs/builtin/variable.c\
./Makefile:			srcs/builtin/conf.c\
./Makefile:			srcs/builtin/no_conf.c\
./Makefile:			srcs/builtin/alias.c\
./Makefile:			srcs/builtin/jobs.c\
./Makefile:			srcs/prompt/prompt_interpreter.c\
./Makefile:			srcs/prompt/prompt.c\
./Makefile:			srcs/parser/parser.c\
./Makefile:			srcs/parser/lex.c\
./Makefile:			srcs/parser/check_line.c\
./Makefile:			srcs/pipe/check_redirection.c\
./Makefile:			srcs/pipe/pipe.c\
./Makefile:			srcs/pipe/pipe_function.c\
./Makefile:			srcs/pipe/redirection.c\
./Makefile:			srcs/signal/signal.c\
./Makefile:			srcs/signal/show_stop.c\
./Makefile:			srcs/signal/function_list.c\
./Makefile:			srcs/operators/operator.c \
./Makefile:			srcs/autocomplete/autocomp.c
./Makefile:
./Makefile:
./Makefile:HDRS	=	includes/msh.h
./Makefile:
./Makefile:CFLAGS = -g -Wall -Wextra -Werror
./Makefile:
./Makefile:CC		=	gcc
./Makefile:
./Makefile:LIBS	=	-L/usr/lib/ -ltermcap
./Makefile:
./Makefile:OBJS	=	$(SRCS:.c=.o)
./Makefile:
./Makefile:all		:	$(NAME)
./Makefile:
./Makefile:msh		:
./Makefile:	@echo "MMMMMMMM               MMMMMMMM   SSSSSSSSSSSSSSS HHHHHHHHH     HHHHHHHHH"
./Makefile:	@echo "M:::::::M             M:::::::M SS:::::::::::::::SH:::::::H     H:::::::H"
./Makefile:	@echo "M::::::::M           M::::::::MS:::::SSSSSS::::::SH:::::::H     H:::::::H"
./Makefile:	@echo "M:::::::::M         M:::::::::MS:::::S     SSSSSSSHH::::::H     H::::::HH"
./Makefile:	@echo "M::::::::::M       M::::::::::MS:::::S              H:::::H     H:::::H"
./Makefile:	@echo "M:::::::::::M     M:::::::::::MS:::::S              H:::::H     H:::::H"
./Makefile:	@echo "M:::::::M::::M   M::::M:::::::M S::::SSSS           H::::::HHHHH::::::H"
./Makefile:	@echo "M::::::M M::::M M::::M M::::::M  SS::::::SSSSS      H:::::::::::::::::H"
./Makefile:	@echo "M::::::M  M::::M::::M  M::::::M   SSS::::::::SS     H:::::::::::::::::H"
./Makefile:	@echo "M::::::M   M:::::::M   M::::::M      SSSSSS::::S    H::::::HHHHH::::::H"
./Makefile:	@echo "M::::::M    M:::::M    M::::::M            S:::::S  H:::::H     H:::::H"
./Makefile:	@echo "M::::::M     MMMMM     M::::::M            S:::::S  H:::::H     H:::::H"
./Makefile:	@echo "M::::::M               M::::::MSSSSSSS     S:::::SHH::::::H     H::::::HH"
./Makefile:	@echo "M::::::M               M::::::MS::::::SSSSSS:::::SH:::::::H     H:::::::H"
./Makefile:	@echo "M::::::M               M::::::MS:::::::::::::::SS H:::::::H     H:::::::H"
./Makefile:	@echo "MMMMMMMM               MMMMMMMM SSSSSSSSSSSSSSS   HHHHHHHHH     HHHHHHHHH"
./Makefile:
./Makefile:$(NAME)	:	 $(OBJS) msh
./Makefile:	@$(CC) $(CFLAGS) $(LIBS) $(OBJS) -o $(NAME)
./Makefile:	@echo "done"
./Makefile:
./Makefile:clean	:
./Makefile:	@rm -rf $(OBJS)
./Makefile:	@echo "clean done"
./Makefile:
./Makefile:fclean	:	clean
./Makefile:	@rm -rf $(NAME)
./Makefile:	@echo "fclean done"
./Makefile:
./Makefile:re		:	fclean all
./Makefile:
./Makefile:.PHONY	:	all re fclean clean
./todo:caractere d'echappement done
./todo:autocompletion++
./todo:globing
./todo:Bug prompt
./LICENSE:GNU GENERAL PUBLIC LICENSE
./LICENSE:                       Version 2, June 1991
./LICENSE:
./LICENSE: Copyright (C) 1989, 1991 Free Software Foundation, Inc., <http://fsf.org/>
./LICENSE: 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
./LICENSE: Everyone is permitted to copy and distribute verbatim copies
./LICENSE: of this license document, but changing it is not allowed.
./LICENSE:
./LICENSE:                            Preamble
./LICENSE:
./LICENSE:  The licenses for most software are designed to take away your
./LICENSE:freedom to share and change it.  By contrast, the GNU General Public
./LICENSE:License is intended to guarantee your freedom to share and change free
./LICENSE:software--to make sure the software is free for all its users.  This
./LICENSE:General Public License applies to most of the Free Software
./LICENSE:Foundation's software and to any other program whose authors commit to
./LICENSE:using it.  (Some other Free Software Foundation software is covered by
./LICENSE:the GNU Lesser General Public License instead.)  You can apply it to
./LICENSE:your programs, too.
./LICENSE:
./LICENSE:  When we speak of free software, we are referring to freedom, not
./LICENSE:price.  Our General Public Licenses are designed to make sure that you
./LICENSE:have the freedom to distribute copies of free software (and charge for
./LICENSE:this service if you wish), that you receive source code or can get it
./LICENSE:if you want it, that you can change the software or use pieces of it
./LICENSE:in new free programs; and that you know you can do these things.
./LICENSE:
./LICENSE:  To protect your rights, we need to make restrictions that forbid
./LICENSE:anyone to deny you these rights or to ask you to surrender the rights.
./LICENSE:These restrictions translate to certain responsibilities for you if you
./LICENSE:distribute copies of the software, or if you modify it.
./LICENSE:
./LICENSE:  For example, if you distribute copies of such a program, whether
./LICENSE:gratis or for a fee, you must give the recipients all the rights that
./LICENSE:you have.  You must make sure that they, too, receive or can get the
./LICENSE:source code.  And you must show them these terms so they know their
./LICENSE:rights.
./LICENSE:
./LICENSE:  We protect your rights with two steps: (1) copyright the software, and
./LICENSE:(2) offer you this license which gives you legal permission to copy,
./LICENSE:distribute and/or modify the software.
./LICENSE:
./LICENSE:  Also, for each author's protection and ours, we want to make certain
./LICENSE:that everyone understands that there is no warranty for this free
./LICENSE:software.  If the software is modified by someone else and passed on, we
./LICENSE:want its recipients to know that what they have is not the original, so
./LICENSE:that any problems introduced by others will not reflect on the original
./LICENSE:authors' reputations.
./LICENSE:
./LICENSE:  Finally, any free program is threatened constantly by software
./LICENSE:patents.  We wish to avoid the danger that redistributors of a free
./LICENSE:program will individually obtain patent licenses, in effect making the
./LICENSE:program proprietary.  To prevent this, we have made it clear that any
./LICENSE:patent must be licensed for everyone's free use or not licensed at all.
./LICENSE:
./LICENSE:  The precise terms and conditions for copying, distribution and
./LICENSE:modification follow.
./LICENSE:
./LICENSE:                    GNU GENERAL PUBLIC LICENSE
./LICENSE:   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
./LICENSE:
./LICENSE:  0. This License applies to any program or other work which contains
./LICENSE:a notice placed by the copyright holder saying it may be distributed
./LICENSE:under the terms of this General Public License.  The "Program", below,
./LICENSE:refers to any such program or work, and a "work based on the Program"
./LICENSE:means either the Program or any derivative work under copyright law:
./LICENSE:that is to say, a work containing the Program or a portion of it,
./LICENSE:either verbatim or with modifications and/or translated into another
./LICENSE:language.  (Hereinafter, translation is included without limitation in
./LICENSE:the term "modification".)  Each licensee is addressed as "you".
./LICENSE:
./LICENSE:Activities other than copying, distribution and modification are not
./LICENSE:covered by this License; they are outside its scope.  The act of
./LICENSE:running the Program is not restricted, and the output from the Program
./LICENSE:is covered only if its contents constitute a work based on the
./LICENSE:Program (independent of having been made by running the Program).
./LICENSE:Whether that is true depends on what the Program does.
./LICENSE:
./LICENSE:  1. You may copy and distribute verbatim copies of the Program's
./LICENSE:source code as you receive it, in any medium, provided that you
./LICENSE:conspicuously and appropriately publish on each copy an appropriate
./LICENSE:copyright notice and disclaimer of warranty; keep intact all the
./LICENSE:notices that refer to this License and to the absence of any warranty;
./LICENSE:and give any other recipients of the Program a copy of this License
./LICENSE:along with the Program.
./LICENSE:
./LICENSE:You may charge a fee for the physical act of transferring a copy, and
./LICENSE:you may at your option offer warranty protection in exchange for a fee.
./LICENSE:
./LICENSE:  2. You may modify your copy or copies of the Program or any portion
./LICENSE:of it, thus forming a work based on the Program, and copy and
./LICENSE:distribute such modifications or work under the terms of Section 1
./LICENSE:above, provided that you also meet all of these conditions:
./LICENSE:
./LICENSE:    a) You must cause the modified files to carry prominent notices
./LICENSE:    stating that you changed the files and the date of any change.
./LICENSE:
./LICENSE:    b) You must cause any work that you distribute or publish, that in
./LICENSE:    whole or in part contains or is derived from the Program or any
./LICENSE:    part thereof, to be licensed as a whole at no charge to all third
./LICENSE:    parties under the terms of this License.
./LICENSE:
./LICENSE:    c) If the modified program normally reads commands interactively
./LICENSE:    when run, you must cause it, when started running for such
./LICENSE:    interactive use in the most ordinary way, to print or display an
./LICENSE:    announcement including an appropriate copyright notice and a
./LICENSE:    notice that there is no warranty (or else, saying that you provide
./LICENSE:    a warranty) and that users may redistribute the program under
./LICENSE:    these conditions, and telling the user how to view a copy of this
./LICENSE:    License.  (Exception: if the Program itself is interactive but
./LICENSE:    does not normally print such an announcement, your work based on
./LICENSE:    the Program is not required to print an announcement.)
./LICENSE:
./LICENSE:These requirements apply to the modified work as a whole.  If
./LICENSE:identifiable sections of that work are not derived from the Program,
./LICENSE:and can be reasonably considered independent and separate works in
./LICENSE:themselves, then this License, and its terms, do not apply to those
./LICENSE:sections when you distribute them as separate works.  But when you
./LICENSE:distribute the same sections as part of a whole which is a work based
./LICENSE:on the Program, the distribution of the whole must be on the terms of
./LICENSE:this License, whose permissions for other licensees extend to the
./LICENSE:entire whole, and thus to each and every part regardless of who wrote it.
./LICENSE:
./LICENSE:Thus, it is not the intent of this section to claim rights or contest
./LICENSE:your rights to work written entirely by you; rather, the intent is to
./LICENSE:exercise the right to control the distribution of derivative or
./LICENSE:collective works based on the Program.
./LICENSE:
./LICENSE:In addition, mere aggregation of another work not based on the Program
./LICENSE:with the Program (or with a work based on the Program) on a volume of
./LICENSE:a storage or distribution medium does not bring the other work under
./LICENSE:the scope of this License.
./LICENSE:
./LICENSE:  3. You may copy and distribute the Program (or a work based on it,
./LICENSE:under Section 2) in object code or executable form under the terms of
./LICENSE:Sections 1 and 2 above provided that you also do one of the following:
./LICENSE:
./LICENSE:    a) Accompany it with the complete corresponding machine-readable
./LICENSE:    source code, which must be distributed under the terms of Sections
./LICENSE:    1 and 2 above on a medium customarily used for software interchange; or,
./LICENSE:
./LICENSE:    b) Accompany it with a written offer, valid for at least three
./LICENSE:    years, to give any third party, for a charge no more than your
./LICENSE:    cost of physically performing source distribution, a complete
./LICENSE:    machine-readable copy of the corresponding source code, to be
./LICENSE:    distributed under the terms of Sections 1 and 2 above on a medium
./LICENSE:    customarily used for software interchange; or,
./LICENSE:
./LICENSE:    c) Accompany it with the information you received as to the offer
./LICENSE:    to distribute corresponding source code.  (This alternative is
./LICENSE:    allowed only for noncommercial distribution and only if you
./LICENSE:    received the program in object code or executable form with such
./LICENSE:    an offer, in accord with Subsection b above.)
./LICENSE:
./LICENSE:The source code for a work means the preferred form of the work for
./LICENSE:making modifications to it.  For an executable work, complete source
./LICENSE:code means all the source code for all modules it contains, plus any
./LICENSE:associated interface definition files, plus the scripts used to
./LICENSE:control compilation and installation of the executable.  However, as a
./LICENSE:special exception, the source code distributed need not include
./LICENSE:anything that is normally distributed (in either source or binary
./LICENSE:form) with the major components (compiler, kernel, and so on) of the
./LICENSE:operating system on which the executable runs, unless that component
./LICENSE:itself accompanies the executable.
./LICENSE:
./LICENSE:If distribution of executable or object code is made by offering
./LICENSE:access to copy from a designated place, then offering equivalent
./LICENSE:access to copy the source code from the same place counts as
./LICENSE:distribution of the source code, even though third parties are not
./LICENSE:compelled to copy the source along with the object code.
./LICENSE:
./LICENSE:  4. You may not copy, modify, sublicense, or distribute the Program
./LICENSE:except as expressly provided under this License.  Any attempt
./LICENSE:otherwise to copy, modify, sublicense or distribute the Program is
./LICENSE:void, and will automatically terminate your rights under this License.
./LICENSE:However, parties who have received copies, or rights, from you under
./LICENSE:this License will not have their licenses terminated so long as such
./LICENSE:parties remain in full compliance.
./LICENSE:
./LICENSE:  5. You are not required to accept this License, since you have not
./LICENSE:signed it.  However, nothing else grants you permission to modify or
./LICENSE:distribute the Program or its derivative works.  These actions are
./LICENSE:prohibited by law if you do not accept this License.  Therefore, by
./LICENSE:modifying or distributing the Program (or any work based on the
./LICENSE:Program), you indicate your acceptance of this License to do so, and
./LICENSE:all its terms and conditions for copying, distributing or modifying
./LICENSE:the Program or works based on it.
./LICENSE:
./LICENSE:  6. Each time you redistribute the Program (or any work based on the
./LICENSE:Program), the recipient automatically receives a license from the
./LICENSE:original licensor to copy, distribute or modify the Program subject to
./LICENSE:these terms and conditions.  You may not impose any further
./LICENSE:restrictions on the recipients' exercise of the rights granted herein.
./LICENSE:You are not responsible for enforcing compliance by third parties to
./LICENSE:this License.
./LICENSE:
./LICENSE:  7. If, as a consequence of a court judgment or allegation of patent
./LICENSE:infringement or for any other reason (not limited to patent issues),
./LICENSE:conditions are imposed on you (whether by court order, agreement or
./LICENSE:otherwise) that contradict the conditions of this License, they do not
./LICENSE:excuse you from the conditions of this License.  If you cannot
./LICENSE:distribute so as to satisfy simultaneously your obligations under this
./LICENSE:License and any other pertinent obligations, then as a consequence you
./LICENSE:may not distribute the Program at all.  For example, if a patent
./LICENSE:license would not permit royalty-free redistribution of the Program by
./LICENSE:all those who receive copies directly or indirectly through you, then
./LICENSE:the only way you could satisfy both it and this License would be to
./LICENSE:refrain entirely from distribution of the Program.
./LICENSE:
./LICENSE:If any portion of this section is held invalid or unenforceable under
./LICENSE:any particular circumstance, the balance of the section is intended to
./LICENSE:apply and the section as a whole is intended to apply in other
./LICENSE:circumstances.
./LICENSE:
./LICENSE:It is not the purpose of this section to induce you to infringe any
./LICENSE:patents or other property right claims or to contest validity of any
./LICENSE:such claims; this section has the sole purpose of protecting the
./LICENSE:integrity of the free software distribution system, which is
./LICENSE:implemented by public license practices.  Many people have made
./LICENSE:generous contributions to the wide range of software distributed
./LICENSE:through that system in reliance on consistent application of that
./LICENSE:system; it is up to the author/donor to decide if he or she is willing
./LICENSE:to distribute software through any other system and a licensee cannot
./LICENSE:impose that choice.
./LICENSE:
./LICENSE:This section is intended to make thoroughly clear what is believed to
./LICENSE:be a consequence of the rest of this License.
./LICENSE:
./LICENSE:  8. If the distribution and/or use of the Program is restricted in
./LICENSE:certain countries either by patents or by copyrighted interfaces, the
./LICENSE:original copyright holder who places the Program under this License
./LICENSE:may add an explicit geographical distribution limitation excluding
./LICENSE:those countries, so that distribution is permitted only in or among
./LICENSE:countries not thus excluded.  In such case, this License incorporates
./LICENSE:the limitation as if written in the body of this License.
./LICENSE:
./LICENSE:  9. The Free Software Foundation may publish revised and/or new versions
./LICENSE:of the General Public License from time to time.  Such new versions will
./LICENSE:be similar in spirit to the present version, but may differ in detail to
./LICENSE:address new problems or concerns.
./LICENSE:
./LICENSE:Each version is given a distinguishing version number.  If the Program
./LICENSE:specifies a version number of this License which applies to it and "any
./LICENSE:later version", you have the option of following the terms and conditions
./LICENSE:either of that version or of any later version published by the Free
./LICENSE:Software Foundation.  If the Program does not specify a version number of
./LICENSE:this License, you may choose any version ever published by the Free Software
./LICENSE:Foundation.
./LICENSE:
./LICENSE:  10. If you wish to incorporate parts of the Program into other free
./LICENSE:programs whose distribution conditions are different, write to the author
./LICENSE:to ask for permission.  For software which is copyrighted by the Free
./LICENSE:Software Foundation, write to the Free Software Foundation; we sometimes
./LICENSE:make exceptions for this.  Our decision will be guided by the two goals
./LICENSE:of preserving the free status of all derivatives of our free software and
./LICENSE:of promoting the sharing and reuse of software generally.
./LICENSE:
./LICENSE:                            NO WARRANTY
./LICENSE:
./LICENSE:  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
./LICENSE:FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
./LICENSE:OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
./LICENSE:PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
./LICENSE:OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
./LICENSE:MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
./LICENSE:TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
./LICENSE:PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
./LICENSE:REPAIR OR CORRECTION.
./LICENSE:
./LICENSE:  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
./LICENSE:WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
./LICENSE:REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
./LICENSE:INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
./LICENSE:OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
./LICENSE:TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
./LICENSE:YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
./LICENSE:PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
./LICENSE:POSSIBILITY OF SUCH DAMAGES.
./LICENSE:
./LICENSE:                     END OF TERMS AND CONDITIONS
./LICENSE:
./LICENSE:            How to Apply These Terms to Your New Programs
./LICENSE:
./LICENSE:  If you develop a new program, and you want it to be of the greatest
./LICENSE:possible use to the public, the best way to achieve this is to make it
./LICENSE:free software which everyone can redistribute and change under these terms.
./LICENSE:
./LICENSE:  To do so, attach the following notices to the program.  It is safest
./LICENSE:to attach them to the start of each source file to most effectively
./LICENSE:convey the exclusion of warranty; and each file should have at least
./LICENSE:the "copyright" line and a pointer to where the full notice is found.
./LICENSE:
./LICENSE:    {description}
./LICENSE:    Copyright (C) {year}  {fullname}
./LICENSE:
./LICENSE:    This program is free software; you can redistribute it and/or modify
./LICENSE:    it under the terms of the GNU General Public License as published by
./LICENSE:    the Free Software Foundation; either version 2 of the License, or
./LICENSE:    (at your option) any later version.
./LICENSE:
./LICENSE:    This program is distributed in the hope that it will be useful,
./LICENSE:    but WITHOUT ANY WARRANTY; without even the implied warranty of
./LICENSE:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
./LICENSE:    GNU General Public License for more details.
./LICENSE:
./LICENSE:    You should have received a copy of the GNU General Public License along
./LICENSE:    with this program; if not, write to the Free Software Foundation, Inc.,
./LICENSE:    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
./LICENSE:
./LICENSE:Also add information on how to contact you by electronic and paper mail.
./LICENSE:
./LICENSE:If the program is interactive, make it output a short notice like this
./LICENSE:when it starts in an interactive mode:
./LICENSE:
./LICENSE:    Gnomovision version 69, Copyright (C) year name of author
./LICENSE:    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
./LICENSE:    This is free software, and you are welcome to redistribute it
./LICENSE:    under certain conditions; type `show c' for details.
./LICENSE:
./LICENSE:The hypothetical commands `show w' and `show c' should show the appropriate
./LICENSE:parts of the General Public License.  Of course, the commands you use may
./LICENSE:be called something other than `show w' and `show c'; they could even be
./LICENSE:mouse-clicks or menu items--whatever suits your program.
./LICENSE:
./LICENSE:You should also get your employer (if you work as a programmer) or your
./LICENSE:school, if any, to sign a "copyright disclaimer" for the program, if
./LICENSE:necessary.  Here is a sample; alter the names:
./LICENSE:
./LICENSE:  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
./LICENSE:  `Gnomovision' (which makes passes at compilers) written by James Hacker.
./LICENSE:
./LICENSE:  {signature of Ty Coon}, 1 April 1989
./LICENSE:  Ty Coon, President of Vice
./LICENSE:
./LICENSE:This General Public License does not permit incorporating your program into
./LICENSE:proprietary programs.  If your program is a subroutine library, you may
./LICENSE:consider it more useful to permit linking proprietary applications with the
./LICENSE:library.  If this is what you want to do, use the GNU Lesser General
./LICENSE:Public License instead of this License.
Binary file ./MiShell matches
./README: .----------------.  .----------------.  .----------------. 
./README: | .--------------. || .--------------. || .--------------. |
./README: | | ____    ____ | || |    _______   | || |  ____  ____  | |
./README: | ||_   \  /   _|| || |   /  ___  |  | || | |_   ||   _| | |
./README: | |  |   \/   |  | || |  |  (__ \_|  | || |   | |__| |   | |
./README: | |  | |\  /| |  | || |   '.___`-.   | || |   |  __  |   | |
./README: | | _| |_\/_| |_ | || |  |`\____) |  | || |  _| |  | |_  | |
./README: | ||_____||_____|| || |  |_______.'  | || | |____||____| | |
./README: | |              | || |              | || |              | |
./README: | '--------------' || '--------------' || '--------------' |
./README:  '----------------'  '----------------'  '----------------' 
./README:
./README:====
./docs/text/index:
./docs/text/index:MMMMMMMM               MMMMMMMM   SSSSSSSSSSSSSSS HHHHHHHHH     HHHHHHHHH
./docs/text/index:M:::::::M             M:::::::M SS:::::::::::::::SH:::::::H     H:::::::H
./docs/text/index:M::::::::M           M::::::::MS:::::SSSSSS::::::SH:::::::H     H:::::::H
./docs/text/index:M:::::::::M         M:::::::::MS:::::S     SSSSSSSHH::::::H     H::::::HH
./docs/text/index:M::::::::::M       M::::::::::MS:::::S              H:::::H     H:::::H
./docs/text/index:M:::::::::::M     M:::::::::::MS:::::S              H:::::H     H:::::H
./docs/text/index:M:::::::M::::M   M::::M:::::::M S::::SSSS           H::::::HHHHH::::::H
./docs/text/index:M::::::M M::::M M::::M M::::::M  SS::::::SSSSS      H:::::::::::::::::H
./docs/text/index:M::::::M  M::::M::::M  M::::::M    SSS::::::::SS    H:::::::::::::::::H
./docs/text/index:M::::::M   M:::::::M   M::::::M       SSSSSS::::S   H::::::HHHHH::::::H
./docs/text/index:M::::::M    M:::::M    M::::::M            S:::::S  H:::::H     H:::::H
./docs/text/index:M::::::M     MMMMM     M::::::M            S:::::S  H:::::H     H:::::H
./docs/text/index:M::::::M               M::::::MSSSSSSS     S:::::SHH::::::H     H::::::HH
./docs/text/index:M::::::M               M::::::MS::::::SSSSSS:::::SH:::::::H     H:::::::H
./docs/text/index:M::::::M               M::::::MS:::::::::::::::SS H:::::::H     H:::::::H
./docs/text/index:MMMMMMMM               MMMMMMMM SSSSSSSSSSSSSSS   HHHHHHHHH     HHHHHHHHH
./docs/text/index:
./docs/text/index:    * Index
./docs/text/index:    * Builtins
./docs/text/index:    * Scripting
./docs/text/index:    * Git
./docs/text/index:
./docs/text/index:MSH is a friendly interactive shell
./docs/text/builtins:
./docs/text/builtins:MMMMMMMM               MMMMMMMM   SSSSSSSSSSSSSSS HHHHHHHHH     HHHHHHHHH
./docs/text/builtins:M:::::::M             M:::::::M SS:::::::::::::::SH:::::::H     H:::::::H
./docs/text/builtins:M::::::::M           M::::::::MS:::::SSSSSS::::::SH:::::::H     H:::::::H
./docs/text/builtins:M:::::::::M         M:::::::::MS:::::S     SSSSSSSHH::::::H     H::::::HH
./docs/text/builtins:M::::::::::M       M::::::::::MS:::::S              H:::::H     H:::::H
./docs/text/builtins:M:::::::::::M     M:::::::::::MS:::::S              H:::::H     H:::::H
./docs/text/builtins:M:::::::M::::M   M::::M:::::::M S::::SSSS           H::::::HHHHH::::::H
./docs/text/builtins:M::::::M M::::M M::::M M::::::M  SS::::::SSSSS      H:::::::::::::::::H
./docs/text/builtins:M::::::M  M::::M::::M  M::::::M    SSS::::::::SS    H:::::::::::::::::H
./docs/text/builtins:M::::::M   M:::::::M   M::::::M       SSSSSS::::S   H::::::HHHHH::::::H
./docs/text/builtins:M::::::M    M:::::M    M::::::M            S:::::S  H:::::H     H:::::H
./docs/text/builtins:M::::::M     MMMMM     M::::::M            S:::::S  H:::::H     H:::::H
./docs/text/builtins:M::::::M               M::::::MSSSSSSS     S:::::SHH::::::H     H::::::HH
./docs/text/builtins:M::::::M               M::::::MS::::::SSSSSS:::::SH:::::::H     H:::::::H
./docs/text/builtins:M::::::M               M::::::MS:::::::::::::::SS H:::::::H     H:::::::H
./docs/text/builtins:MMMMMMMM               MMMMMMMM SSSSSSSSSSSSSSS   HHHHHHHHH     HHHHHHHHH
./docs/text/builtins:
./docs/text/builtins:    * Index
./docs/text/builtins:    * Builtins
./docs/text/builtins:    * Scripting
./docs/text/builtins:    * Git
./docs/text/builtins:
./docs/text/builtins:****** Prompt ******
./docs/text/builtins:Synopsis
./docs/text/builtins:setenv PROMPT "myprompt$>"
./docs/text/builtins:
./docs/text/builtins:Variable of prompt
./docs/text/builtins:
./docs/text/builtins:%n -> $USER
./docs/text/builtins:%p -> $PWD
./docs/text/builtins:%h -> Home pwd
./docs/text/builtins:%g -> $GROUP
./docs/text/builtins:Style of prompt
./docs/text/builtins:%u -> underline
./docs/text/builtins:%s -> surline
./docs/text/builtins:
./docs/text/builtins:
./docs/text/builtins:Color
./docs/text/builtins:%c{NAME_OF_COLOR}
./docs/text/builtins:
./docs/text/builtins:Disponibilty:
./docs/text/builtins:    * GRAY
./docs/text/builtins:    * RED
./docs/text/builtins:    * GRE -> green
./docs/text/builtins:    * YEL -> yellow
./docs/text/builtins:    * BLUE
./docs/text/builtins:    * MAG -> Magenta
./docs/text/builtins:    * SBLUE -> blue sky
./docs/text/builtins:    * DEF -> default
./docs/text/builtins:
./docs/text/builtins:
./docs/text/builtins:Example:
./docs/text/builtins:setenv PROMPT "%c{RED}(%n)%c{BLUE}%u[%h]%e%c{DEF}$> "
./docs/text/builtins:
./docs/text/builtins:
./docs/text/builtins:****** Alias ******
./docs/text/builtins:
./docs/text/builtins:synopsis
./docs/text/builtins:alias my_cmd value
./docs/text/builtins:
./docs/text/builtins:Example
./docs/text/builtins:alias ll "ls -la"
./docs/text/builtins:
./docs/text/builtins:
./docs/text/builtins:****** Configuration file ******
./docs/text/builtins:
./docs/text/builtins:Path = ~/.mshrc
./docs/html/index.html:<html>
./docs/html/index.html:<pre>                                                                              
./docs/html/index.html:MMMMMMMM               MMMMMMMM   SSSSSSSSSSSSSSS HHHHHHHHH     HHHHHHHHH     
./docs/html/index.html:M:::::::M             M:::::::M SS:::::::::::::::SH:::::::H     H:::::::H     
./docs/html/index.html:M::::::::M           M::::::::MS:::::SSSSSS::::::SH:::::::H     H:::::::H     
./docs/html/index.html:M:::::::::M         M:::::::::MS:::::S     SSSSSSSHH::::::H     H::::::HH     
./docs/html/index.html:M::::::::::M       M::::::::::MS:::::S              H:::::H     H:::::H       
./docs/html/index.html:M:::::::::::M     M:::::::::::MS:::::S              H:::::H     H:::::H       
./docs/html/index.html:M:::::::M::::M   M::::M:::::::M S::::SSSS           H::::::HHHHH::::::H       
./docs/html/index.html:M::::::M M::::M M::::M M::::::M  SS::::::SSSSS      H:::::::::::::::::H       
./docs/html/index.html:M::::::M  M::::M::::M  M::::::M    SSS::::::::SS    H:::::::::::::::::H       
./docs/html/index.html:M::::::M   M:::::::M   M::::::M       SSSSSS::::S   H::::::HHHHH::::::H       
./docs/html/index.html:M::::::M    M:::::M    M::::::M            S:::::S  H:::::H     H:::::H       
./docs/html/index.html:M::::::M     MMMMM     M::::::M            S:::::S  H:::::H     H:::::H       
./docs/html/index.html:M::::::M               M::::::MSSSSSSS     S:::::SHH::::::H     H::::::HH     
./docs/html/index.html:M::::::M               M::::::MS::::::SSSSSS:::::SH:::::::H     H:::::::H     
./docs/html/index.html:M::::::M               M::::::MS:::::::::::::::SS H:::::::H     H:::::::H     
./docs/html/index.html:MMMMMMMM               MMMMMMMM SSSSSSSSSSSSSSS   HHHHHHHHH     HHHHHHHHH</pre>
./docs/html/index.html:
./docs/html/index.html:<br />
./docs/html/index.html:<ul>
./docs/html/index.html:	<li><a href="index.html">Index</a></li>
./docs/html/index.html:	<li><a href="builtins.html">Builtins</a></li>
./docs/html/index.html:	<li><a href="#">Scripting</a></li>
./docs/html/index.html:	<li><a href="https://github.com/Ne02ptzero/msh.git">Git</a></li>
./docs/html/index.html:</ul>
./docs/html/index.html:<br />
./docs/html/index.html:<p>MSH is a friendly interactive shell</p>
./docs/html/index.html:</html>
./docs/html/builtins.html:
./docs/html/builtins.html:<html>
./docs/html/builtins.html:<pre>                                                                              
./docs/html/builtins.html:MMMMMMMM               MMMMMMMM   SSSSSSSSSSSSSSS HHHHHHHHH     HHHHHHHHH     
./docs/html/builtins.html:M:::::::M             M:::::::M SS:::::::::::::::SH:::::::H     H:::::::H     
./docs/html/builtins.html:M::::::::M           M::::::::MS:::::SSSSSS::::::SH:::::::H     H:::::::H     
./docs/html/builtins.html:M:::::::::M         M:::::::::MS:::::S     SSSSSSSHH::::::H     H::::::HH     
./docs/html/builtins.html:M::::::::::M       M::::::::::MS:::::S              H:::::H     H:::::H       
./docs/html/builtins.html:M:::::::::::M     M:::::::::::MS:::::S              H:::::H     H:::::H       
./docs/html/builtins.html:M:::::::M::::M   M::::M:::::::M S::::SSSS           H::::::HHHHH::::::H       
./docs/html/builtins.html:M::::::M M::::M M::::M M::::::M  SS::::::SSSSS      H:::::::::::::::::H       
./docs/html/builtins.html:M::::::M  M::::M::::M  M::::::M    SSS::::::::SS    H:::::::::::::::::H       
./docs/html/builtins.html:M::::::M   M:::::::M   M::::::M       SSSSSS::::S   H::::::HHHHH::::::H       
./docs/html/builtins.html:M::::::M    M:::::M    M::::::M            S:::::S  H:::::H     H:::::H       
./docs/html/builtins.html:M::::::M     MMMMM     M::::::M            S:::::S  H:::::H     H:::::H       
./docs/html/builtins.html:M::::::M               M::::::MSSSSSSS     S:::::SHH::::::H     H::::::HH     
./docs/html/builtins.html:M::::::M               M::::::MS::::::SSSSSS:::::SH:::::::H     H:::::::H     
./docs/html/builtins.html:M::::::M               M::::::MS:::::::::::::::SS H:::::::H     H:::::::H     
./docs/html/builtins.html:MMMMMMMM               MMMMMMMM SSSSSSSSSSSSSSS   HHHHHHHHH     HHHHHHHHH</pre>
./docs/html/builtins.html:
./docs/html/builtins.html:<br />
./docs/html/builtins.html:<ul>
./docs/html/builtins.html:	<li><a href="index.html">Index</a></li>
./docs/html/builtins.html:	<li><a href="builtins.html">Builtins</a></li>
./docs/html/builtins.html:	<li><a href="#">Scripting</a></li>
./docs/html/builtins.html:	<li><a href="https://github.com/Ne02ptzero/msh.git">Git</a></li>
./docs/html/builtins.html:</ul>
./docs/html/builtins.html:<br />
./docs/html/builtins.html:<h1>Prompt</h1>
./docs/html/builtins.html:<strong>Synopsis</strong><br />
./docs/html/builtins.html:setenv PROMPT "myprompt$>"<br />
./docs/html/builtins.html:<br />
./docs/html/builtins.html:<strong>Variable of prompt</strong>
./docs/html/builtins.html:<p>
./docs/html/builtins.html:%n -> $USER<br />
./docs/html/builtins.html:%p -> $PWD<br />
./docs/html/builtins.html:%h -> Home pwd<br />
./docs/html/builtins.html:%P -> Special PWD<br />
./docs/html/builtins.html:%g -> $GROUP<br />
./docs/html/builtins.html:%G -> Branch of Git<br />
./docs/html/builtins.html:%t -> Current Time<br />
./docs/html/builtins.html:</p>
./docs/html/builtins.html:
./docs/html/builtins.html:<p></p>
./docs/html/builtins.html:<strong>Style of prompt</strong>
./docs/html/builtins.html:<p>%u -> underline<br />
./docs/html/builtins.html:%s -> surline <br /></p>
./docs/html/builtins.html:
./docs/html/builtins.html:<p></p>
./docs/html/builtins.html:<strong>Color</strong>
./docs/html/builtins.html:<p>
./docs/html/builtins.html:	%c{NAME_OF_COLOR}<br />
./docs/html/builtins.html:	Disponibilty:
./docs/html/builtins.html:	<ul>	
./docs/html/builtins.html:		<li>GRAY</li>
./docs/html/builtins.html:		<li>RED</li>
./docs/html/builtins.html:		<li>GRE -> green</li>
./docs/html/builtins.html:		<li>YEL -> yellow</li>
./docs/html/builtins.html:		<li>BLUE</li>
./docs/html/builtins.html:		<li>MAG -> Magenta</li>
./docs/html/builtins.html:		<li>SBLUE -> blue sky</li>
./docs/html/builtins.html:		<li>DEF -> default</li>
./docs/html/builtins.html:	</ul>
./docs/html/builtins.html:<strong>Example:</strong>
./docs/html/builtins.html:<br />setenv PROMPT "%c{RED}(%n)%c{BLUE}%u[%h]%e%c{DEF}$> "
./docs/html/builtins.html:<br />setenv PROMPT "%c{BLUE}(%n)%c{GRE}%u{%P}%e\n%c{MAG}[%t]-%G->"
./docs/html/builtins.html:</p>
./docs/html/builtins.html:<h1>Alias</h1>
./docs/html/builtins.html:<strong>synopsis</strong><br />
./docs/html/builtins.html:alias my_cmd value
./docs/html/builtins.html:<br />
./docs/html/builtins.html:<br />
./docs/html/builtins.html:<strong>Example</strong><br />
./docs/html/builtins.html:alias ll "ls -la"
./docs/html/builtins.html:<br />
./docs/html/builtins.html:<br />
./docs/html/builtins.html:<h1>Configuration file</h1>
./docs/html/builtins.html:Path = ~/.mshrc
./docs/html/builtins.html:</html>
./WIP:/*builtin*/
./WIP:
./WIP:env----------------------------------------------------------------------------ok
./WIP:setenv-------------------------------------------------------------------------ok
./WIP:unsetenv-----------------------------------------------------------------------ok
./WIP:alias--------------------------------------------------------------------------ok
./WIP:echo---------------------------------------------------------------------------ok
./WIP:variable (set, unset, export)--------------------------------------------------ok
./WIP:globing------------------------------------------------------------------------Mort
./WIP:job-control(job, fg, bg)-------------------------------------------------------ok
./WIP:shell-script-------------------------------------------------------------------Mort
./WIP:
./WIP:cd-----------------------------------------------------------------------------ok
./WIP:cd "-"-------------------------------------------------------------------------ok
./WIP:cd /path/to/dir----------------------------------------------------------------ok
./WIP:cd "~"-------------------------------------------------------------------------ok
./WIP:cd $ENV------------------------------------------------------------------------ok
./WIP:
./WIP:exit---------------------------------------------------------------------------ok
./WIP:
./WIP:<------------------------------------------------------------------------------ok
./WIP:>------------------------------------------------------------------------------ok
./WIP:>>-----------------------------------------------------------------------------ok
./WIP:<<-----------------------------------------------------------------------------ok
./WIP:|------------------------------------------------------------------------------ok
./WIP:;------------------------------------------------------------------------------ok
./WIP:&&-----------------------------------------------------------------------------ok
./WIP:||-----------------------------------------------------------------------------ok
./WIP:&------------------------------------------------------------------------------ok
./WIP:() - SubShell------------------------------------------------------------------ok
./WIP:`command  `--------------------------------------------------------------------ok
./WIP:help---------------------------------------------------------------------------Mort
./WIP:
./WIP:/* READ */
./WIP:
./WIP:basic_read---------------------------------------------------------------------ok
./WIP:modif_in_read------------------------------------------------------------------ok
./WIP:history------------------------------------------------------------------------ok
./WIP:auto-completion----------------------------------------------------------------ok
./WIP:syntaxic coloration------------------------------------------------------------ok
./WIP:builtin syntaxic coloration----------------------------------------------------ok
